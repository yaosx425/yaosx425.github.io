<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2025/08/13/Spring-1/"/>
    <url>/2025/08/13/Spring-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/13/hello-world/"/>
    <url>/2025/08/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统</title>
    <link href="/2021/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>单道批处理系统：单道批处理系统中，内存只允许存放一个作业，当前正在运行的作业驻留内存，执行顺序是先进先出。在单道批处理系统中，一个作业单独进入内存，并且能够独占系统的资源，直到它运行结束之后，下一个作业才能进入该内存。当进行操作时，cpu处于等待的状态。</p></li><li><p>多道批处理系统：系统中可以同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按照一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。</p></li><li><p>脱机输入输出：输入输出工作是在脱离主机的情况下进行的。</p><p>优点：</p><p>（1）减少了CPU的空闲时间</p><p>（2）提高了输入输出的速度</p></li><li><p>联机输入输出：输入输出工作是在主机的控制下进行的。</p></li><li><p>分时系统</p></li><li><p>多道批处理系统和分时系统的出现标志着操作系统的形成。</p></li><li><p>并发是指两个或两个以上的事物在同一时间间隔发生，并行是指两个或两个以上的事物在同一时刻发生。</p></li><li><p>进程控制就是创建进程、撤销进程以及控制进程在运行过程中的状态转换。</p></li><li><p>进程通信的任务就是用来实现相互合作进程之间的信息传递。不同计算机系统中进程之间的通信也称为计算机网络通信。</p></li><li><p>内存保护：为了防止某道程序干扰和破环其他用户程序或系统程序，存储管理必须保证每个用户程序只能访问自己的存储空间，而不能存取任何其他范围内的信息，也就是要提供一定的存储保护机制。</p></li><li><p>网络通信：计算机网络最基本的功能，其任务就是在源计算机和目标计算机之间实现无差别的数据传输。</p></li><li><p>资源共享管理：对网络中的共享资源（硬件和软件）实施有效的管理，协调各个用户对共享资源的使用，保证数据的安全性和一致性。</p></li><li><p>网络服务：主要有电子邮件服务、文件传输、文件存取、文件管理服务、共享硬盘服务及共享打印机服务。</p></li><li><p>进程以及它的扩展-线程是计算机中的活动计算单元。进程可以看作是执行着的程序，需要占有一定的资源，如cpu、内存、文件和I&#x2F;O设备，所以进程是分配资源的基本单位。在大多数的计算机系统中，进程是并发活动的单位。</p></li><li><p>进程可以定义为“并发执行的程序在一个数据集合上的执行过程。”</p></li><li><p>进程作为程序的执行过程，至少有两个方面的性质：一是它的活动性，即进程是动态变化的，且总是有一个创建到消亡的过程，二是它的并发性，即多道程序中每个进程的执行过程，总是与其他执行过程并发执行。进程与程序之间是既有密切联系又有区别的两个完全不同的概念。</p></li><li><p>进程和程序的区别：</p><p>（1）进程的动态性和程序的静态性。进程是程序的执行过程。动态性是进程最基本的特性，进程是有一定生命期的。而程序是一组有序指令的集合，并存放在某种介质上，它本身没有动态的含义，因此程序是个静止的实体。</p><p>（2）进程的并发性和程序的顺序性。</p><p>（3）进程的暂时性和程序的永久性。进程是暂时的，它是程序的执行过程，程序执行完毕，进程也就撤销了。而程序是永久的，不管它是否被执行，它都作为一个实体存在，它可以长久的被保存。</p><p>（4）结构特征。从结构上看，进程是由程序、数据和进程控制块三部分组成的，而程序则不是。</p><p>（5）进程与程序是密切相关的。一个进程可以涉及一个或多个程序的执行，通过多次执行，一个程序可对应多个进程。</p></li><li><p>引入挂起状态的需要：</p><p>（1）内外存对换的需要。</p><p>（2）用户调试程序的需要。</p><p>（3）实时系统中调节负载的需要。</p></li><li><p>由一个数据结构描述进程本身的特性、进程的状态、进程的调度信息及对资源的占有情况等，这个数据结构称为进程控制块（PCB）。进程映像通常由程序、数据、栈和PCB四部分完成。程序段描述了进程本身要完成的功能，而数据段是程序操作的一组存储单元，是程序操作的对象，它由程序相关联的全程变量、局部变量和定义的变量等数据结构组成。栈是一段系统存储单元，用于保存程序调用时的参数、过程调用地址和系统调用地址。进程控制块是在进程创建时建立的，当进程存在于系统时，进程控制块就代表了这个进程；当进程撤销时，进程控制块也随之撤销。因此，进程控制块是进程存在的唯一标识。</p></li><li><p>进程控制块是进程实体的一部分，它是操作系统中最重要的数据结构。进程控制块记录了操作系统所需的用于描述进程情况及控制进程运行的全部信息。作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，是一个能与其他进程并发执行的进程，进程控制块常驻内存。</p></li><li><p>进程控制块中的内容：</p><p>（1）进程描述信息。如进程名、进程标识符、进程所属的用户名等。</p><p>（2）处理机状态信息。处理机状态信息主要由处理机各种寄存器的内容组成。存放处理机状态的寄存器有以下几种：通用寄存器、指令计数器、程序状态字（PSW）寄存器、栈指针。</p><p>（3）进程调度信息。进程的状态、进程的优先级、运行统计信息、进程阻塞的原因。</p><p>（4）进程控制和资源占用信息。包括程序入口地址、程序的外存地址、进程同步及通信机制、资源占用信息、链接指针。</p></li><li><p>管理进程控制块的方式最常用的是链接方式，链接方式把具有相同状态的进程控制块链接在一起，形成一个运行队列、一个就绪队列、若干个阻塞队列和一个空闲队列。</p></li><li><p>通常一些与硬件密切相关的模块放在紧靠硬件的层次上，并且这部分程序常驻内存，以便提高操作系统的运行效率。这部分程序通常称为<strong>操作系统内核</strong>，内核是在计算机硬件上扩充的第一层软件，操作系统要对这部分软件进行保护。内核是用原语来实现的。<strong>原语</strong>由若干条指令构成，是用于完成一定功能的过程。它与一般工程的区别在于，原语是用原子操作构成的，所谓原子操作，是指过程中所有操作要么全做，要么全不做。因此原语在被执行时是不可以被中断的。</p></li><li><p>内核的功能：</p><p>（1）时钟管理</p><p>（2）中断处理</p><p>（3）原语操作</p></li><li><p>进程的挂起主要是将进程从内存移出。当出现挂起事件时，进程可以将自己挂起或由父进程将其某个子进程挂起。相反，当内存中有足够的空间时，将处于挂起状态的进程从外存调回内存，激活进程。</p></li><li><p>比进程更小的、能独立运行的基本单位-线程。提出线程的目的是试图提高系统并发执行的程度，从而进一步提高系统的吞吐量。</p></li><li><p>进程的两个基本属性</p><p>（1）进程是一个可以拥有资源的独立单位。</p><p>（2）进程是一个可以独立调度和分派的基本单位。</p><p>如果把进程的两个基本属性分开，由操作系统分别加以处理，即作为独立分配资源的单位，不再作为调度和分派的基本单位，在这样的指导思想下，产生了线程的概念。</p><p>线程是进程的一个实体，是被独立调度和分派的基本单位，表示进程中的一个控制点，执行一系列的指令。</p></li><li><p>线程控制块（TCB）的组成部分</p><p>（1）线程标识符，它是唯一的。</p><p>（2）描述处理机状态信息的一组寄存器，包括通用寄存器、指令寄存器、程序状态字等。</p><p>（3）栈指针，每个线程有用户栈和核心栈两个栈。</p><p>（4）一个私有存储区，存放现场保护信息和其他与该线程相关的统计信息。</p></li><li><p>线程和进程的关系：进程和线程是两个密切相关的概念，一个进程至少拥有一个线程(该线程为主线程)，进程根据需要可以创建若干个线程。当一个线程改变了内存中某个单元的数据时，其他线程在访问该数据单元时会看到变化后的结果，线程之间的通信变的更为简单、容易。</p></li><li><p>用户级线程的优点：</p><p>（1）线程切换不需要系统状态的转换。因为所有用户级线程的管理都在一个进程的用户的地址空间中进行。</p><p>（2）每个进程可以使用专用的线程调度算法来调度线程。</p><p>（3）用户级线程可以在任何操作系统中运行，不需要对底层的操作系统内核进行修改。线程库是一组供所有应用程序共享的应用级实用程序。</p></li><li><p>内核级线程中处理机的切换是以线程为单位进行的。内核级线程克服了用户级线程的两个不足，首先在多处理机环境中，内核可以同时把一个进程的多个线程分配到多个处理机上；再者，如果进程中的一个线程被阻塞，内核可以调度一个进程的另一个线程执行。除此之外，内核级线程的另一个优点是内核本身也可以设计成多线程。</p></li><li><p>线程池的主要思想是在进程开始时创建一定数量的线程，并放入池中等待。当服务器收到请求时，它会唤醒池中的一个线程，并将要处理的请求传递给他。一旦线程完成了服务，它会返回池中再等待工作；如果池中没有可用的线程，那么服务器会一直等到有空线程为止。</p><p>线程池的优点：</p><p>（1）用现有线程处理请求比创建新线程快。</p><p>（2）线程池限制了可用线程的数量，这对那些不能支持大量并发线程的系统影响较明显。</p><p>线程池中的线程数量由系统的CPU数量、物理内存大小和允许并发用户请求的期望值等因素决定。高级的线程池还可以动态调整线程的数量，当系统负荷低时可减低内存消耗。</p></li><li><p>进程之间的协作关系包括互斥、同步和通信。<strong>互斥</strong>是指多个进程不能同时使用同一个资源，当某个进程使用某种资源的时，其他进程必须等待。<strong>同步</strong>是指多个进程中发生的事件存在某种时序关系，某些进程的执行必须先于另一些进程。<strong>进程通信</strong>是指多个进程之间要传递一定量的信息。</p></li><li><p>在某些时间内只允许一个进程使用的资源称为临界资源，每个进程中访问临界资源的那段程序称为临界区。</p></li><li><p>进程访问临界区的一般结构为进入区、临界区、退出区、剩余区。</p></li><li><p>所有同步机制都必须遵循的四个准则：（1）空闲让进（2）忙则等待（3）有限等待（4）让权等待</p></li><li><p>管道通信机制提供的协调能力：</p><p>（1）互斥。当一个进程正在对管道进行读或者写操作时，另一个进程必须等待。</p><p>（2）同步。管道的大小是有限的。所以当管道满时，写进程必须等待，直到读进程把它唤醒为止。同理，当管道没有数据时，读进程也必须等待，直到写进程将数据写入管道后，读进程才被唤醒。</p><p>（3）对方是否存在。只有确认对方是否存在时，方能进行通信。</p></li><li><p>客户端-服务器系统通信</p><p>（1）命名管道</p><p>（2）套接字</p><p>（3）远程过程调用（RPC）</p><p>（4）远程方法调用（RMI）</p></li><li><p>多道程序的关键是调度，处理机的调度有3种类型：高级调度、中级调度和低级调度。</p><p>高级调度：高级调度也称作业调度。它决定哪个程序可以进入系统中处理，因此它控制多道程序的道数。</p><p>中级调度：中级调度也称为对换程序。引入中级调度的目的是为了提高内存的利用率和系统的吞吐量。为了使暂时不能运行的进程不再占用宝贵的内存空间，系统将它们调到外存等待。</p><p>低级调度：低级调度又称为进程调度。它决定就绪队列中的哪个进程获得处理机，然后由分派程序执行把处理机分配给该进程的操作。进程调度是最基本的调度，在操作系统中必须配置这级调度。</p></li><li><p>进程调度方式</p><p>（1）不可剥夺方式：也称为非抢占方式。采用这种调度方式时，一旦把处理机分配给某个进程，该进程将一直执行下去，直到运行完毕或因某种原因不能运行，绝不允许其他进程抢占正在运行进程占有的处理机。</p><p>（2）可剥夺方式：也称为抢占方式。在这种方式下，允许一个进程按照某种原则抢占其他进程占有的处理机。抢占采用优先级原则的比较多，也就是说，如果一个进程比正在运行进程的优先级高，则它可以抢占处理机而运行。</p></li><li><p>调度的性能准则</p><p>1.响应时间</p><p>2.周转时间</p><p>3.优先权</p><p>4.截至时间</p><p>5.系统吞吐量</p><p>6.处理机的利用率</p><p>7.各类资源的平衡利用</p><p>8.公平</p></li><li><p>调度算法</p><p>（1）<strong>先来先服务调度算法（FCFS）</strong>：是一种最简单的调度算法，可以用在进程调度和作业调度中。它的基本思想是按进程或作业到达的前后顺序进行调度。并且它的处理机调度方式是非剥夺方式，因此操作系统不会强行暂停当前正在运行的进程。有利于长作业，不利于短作业。有利于处理机繁忙的作业，不利于I&#x2F;O繁忙的作业。</p><p>（2）<strong>短作业优先调度算法（SJF或SPN）</strong>:是指对短作业或短进程优先调度的算法。该算法可分别用于作业调度和进程调度，设计目的是改进FCFS算法，减少作业或进程的平均周转时间。</p><p>（3）<strong>时间片轮转调度算法（RR）</strong> ：主要用于进程调度。通常系统将所有就绪进程按FCFS原则排成一个队列，每次系统调度时，把处理机分配给队首的进程，并令其执行一个时间片，时间片的大小一般是几个毫秒到几百个毫秒。当一个进程被分配的时间片用完时，由系统时钟发出一个中断，调度程序暂停当前进程的执行，并将其送到就绪队列的末尾，同时从就绪队列队首选择另一个进程运行。但是时间片的选择是影响算法的一个主要指标，如果时间片很短，系统切换的频率很高，频繁的系统切换会导致用户程序响应时间的增长。因此时间片的长度选择要适当，一般要保证一个基本的交互进程在一个时间片内完成。</p><p>影响时间片的因素有以下几个方面：</p><p>（1）系统的处理能力（2）系统的负载情况（3）系统对响应时间的要求</p><p>时间片轮转法在分时操作系统和事务处理系统中特别有效，它的不足是对于I&#x2F;O频繁的进程不利，因为这些进程常常运行不完一个时间片就阻塞了，等它完成了I&#x2F;O后，又要和其他进程一样排队。</p><p>**（4）优先权调度算法：**为了照顾到进程的紧急程度，使紧急的进程能够及时得到处理，很多操作系统使用了优先权调度算法。优先权调度算法适用于作业调度和进程调度。当该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业调入内存。当用于进程调度时，把处理机分配给就绪队列中优先权最高的进程。进程调度中使用优先权调度算法时又可把算法分为两种方式，即可剥夺方式和不可剥夺方式。</p><p>如何确定进程的优先权？</p><p>静态优先权</p><p>静态优先权是在进程创建时确定该进程的优先权，且该进程的优先权在其整个运行期间保持不变。确定优先权的因素有进程的类型、进程对资源的要求和用户的要求。</p><p>动态优先权</p><p>动态优先权是指进程的优先权可以根据进程的不断推进而改变，以期得到更好的性能。动态优先权的变化取决于进程的等待时间和占有处理机的时间，具体地说，随着进程等待时间的增加，该进程的优先权将以某种速率增加，这样做的目的是使优先权较低的进程在等待足够的时间后，其优先权提高，进而被调度执行；当一个进程在占有处理机的时间不断增长时，其优先权会以某种速率降低，这样做的目的是使持续执行的进程在运行了一段时间后将处理机让给其他进程，以防止一个长进程长期垄断处理机。</p><p><strong>（5）多级反馈队列调度算法</strong>：该算法设置了多个就绪队列，每个队列的优先权不同，第一个队列的优先权最高，第二个队列次之，以此类推，队列的优先权逐个降低。各个队列中进程执行的时间片的大小也不同，优先权越高的队列的进程，其执行时间片越短。新创建的进程进入内存后，首先放入第一个队列的队尾，按FCFS原则进行调度，当调度到某个进程时，该进程若能在一个时间片内完成，便可退出；若它在一个时间片内未能完成，则该进程被调到第二个队列的队尾等待；依次类推……</p></li><li><p>死锁是发生在一组相互合作或竞争的线程或进程中的一个问题，死锁可以定义为一组竞争系统资源或相互通信的进程相互的“永久”阻塞。若无外力作用，这组进程将永远不能继续执行。</p></li><li><p>死锁产生的原因：（1）资源不足（2）进程的推进次序非法</p></li><li><p>系统中的资源有两类，可重复使用资源和可消耗资源。可重复使用资源在使用时往往要求一次只能供一个进程安全使用，并且不会因使用而耗尽。这类资源包括处理机、I&#x2F;O通道、设备及文件、数据库等；既有软件资源，也有硬件资源。解决这类死锁的策略是在系统设计时施加关于资源请求顺序的约束。可消耗资源是指可以创建和撤销的资源。当一个进程使用这种资源后，这种资源就不再存在，比如中断、信号量、消息和缓冲区。</p></li><li><p>死锁产生的必要条件</p><p>（1）互斥条件：进程对所分配的资源进行排他性使用，即在一段时间内某资源只能由一个进程占有。</p><p>（2）请求和保持：进程已经占有了至少一个资源，但又提出了新的资源要求，而该资源已经被其他进程占有，此时进程阻塞，但对已经获得的资源保持不放。</p><p>（3）不可剥夺条件：进程已经获得了资源，在它使用完毕前不能被剥夺，只能使用完毕后，自己释放。</p><p>（4）环路条件：存在一个进程与资源的环行链，在该链中，每个进程都在等待一个被占用的资源。</p><p>前三个条件是进程发生死锁的必要条件，第四个条件实际上是前三个条件的潜在结果，四个条件连在一起就构成了死锁的充分必要条件。</p></li><li><p>死锁的避免：避免死锁就是动态的决定是否允许进程当前资源分配请求。避免死锁采用的是资源分配拒绝策略。在该方法中，允许进程动态的申请资源，但系统在分配资源之前，先计算资源分配的安全性，若此次分配不会导致系统进入不安全状态，便将资源分配给进程，否则不予以分配，进程等待。</p></li><li><p>安全状态是指至少存在一个安全序列&lt;p1,p2,p3…pn&gt;,按照这个序列为进程分配所需的资源，直到满足最大需求，使得每个进程都可以顺序完成。若系统不存在这样一个安全序列，则称系统处于不安全的状态。</p></li><li><p>避免死锁的几个方面的限制</p><p>（1）必须事先声明每个进程的资源最大需求量。</p><p>（2）进程之间必须是无关的，也就是说，进程之间的执行顺序没有任何同步要求。</p><p>（3）系统中可供分配的资源数目必须是固定的。</p><p>（4）进程在占有资源时，不能退出。</p></li><li><p>死锁的检测与解除：检查死锁的基本思路是系统保存资源请求和分配信息，利用某种算法对这些信息加以检查，以判断系统是否出现了死锁。</p><p>（1）资源分配图：死锁检测算法主要是检查系统中的进程是否有循环等待。把系统中进程和资源的申请和分配情况描述成一个有向图，通过检查有向图中是否有循环来判断死锁的存在。</p><p>死锁定理：系统中的状态S是死锁状态的充分必要条件是，当且仅当状态S的资源分配图是不可以完全简化的。</p></li><li><p>解除死锁的方法：</p><p>（1）撤销所有死锁进程。这是操作系统中最常用的方法，也是最容易实现的方法。</p><p>（2）把每个死锁的进程恢复到前面定义的某个检查点，并重新运行这些进程。要实现这个方法需要系统有构造重新运行和重新启动机制。</p><p>（3）有选择的撤销死锁进程，直到不存在死锁。选择撤销进程的顺序基于最小代价原则。每次撤销一个进程后，要调用死锁检测算法检测是否仍然存在死锁。</p><p>（4）剥夺资源，直到不存在死锁。和（3）一样，同样也需要在每次剥夺一个资源后调用死锁检测算法，检测系统是否仍然存在死锁。</p></li><li><p>最小代价原则</p><p>（1）到目前为止消耗的处理机时间最少</p><p>（2）到目前为止产生的输出最少</p><p>（3）预计剩下的执行时间最长</p><p>（4）到目前为止分配的资源总量最少</p><p>（5）进程的优先级最低</p><p>（6）撤销某进程对其他进程的影响最少</p></li><li><p>存储管理的对象是内存，在多道程序环境下，程序要运行首先必须装入内存。一个用户源程序变为一个可以在内存中运行的程序，通常要经过编译、链接和装入三个步骤。</p><p>（1）编译。用户源程序经过编译生成目标模块，目标模块以“0”作为开始地址。目标模板中的地址称为相对地址或逻辑地址。</p><p>（2）链接。将编译后形成的多个目标模块以及它们所需要的库函数链接在一起形成装入模块。装入模块虽然具有统一的地址空间，但它仍是以“0”作为参考地址。</p><p>（3）装入。将装入模块装入内存实际物理地址空间，并修改程序中与地址有关的代码，这一过程叫做地址重定位。</p></li><li><p>地址重定位完成的是相对地址转换（逻辑地址）成内存的绝对地址（物理地址）的工作。地址重定位又称为地址映射。按照重定位的时机，可分为静态重定位和动态重定位。</p><p>静态重定位就是在程序执行之前进行重定位。他根据装入模块将要装入的内存起始地址修改装入模块中有关使用地址的代码。程序中涉及地址的每条指令都要进行这样的修改。若这种修改是在程序运行之前，程序装入时一次完成，以后不再改变。这种重定位就称为静态重定位。静态重定位具有无须硬件支持的优点，但存在以下两个缺点：</p><p>（1）程序重定位之后不能在内存中移动</p><p>（2）要求程序的存储空间是连续的，不能把程序放在若干个不连续的存储区域内</p><p>动态重定位是指程序在执行过程中进行地址重定位。更确切地说是在每次访问每个地址单元前再进行地址变换。动态重定位需要硬件-重定位寄存器的支持。</p><p>动态重定位的好处：</p><p>（1）目标模块装入内存时无须任何修改，因而装入后可以再搬迁</p><p>（2）一个程序是由若干个相对独立的目标模块组成的。每个目标模块装入内存时可以各放在一个存储区域，这些存储区域可以不是顺序相邻，只要各个模块有自己对应的重定位寄存器即可。</p></li><li><p>若页号为P，页大小为L，页内位移为d，而逻辑地址为A，则它们之间的关系为</p><p>P &#x3D; int(A&#x2F;L)</p><p>d &#x3D; A MOD L</p></li><li><p>分段和分页的区别：</p><p>（1）页是信息的物理单位，分页是为了实现进程在内存的有效离散存放，以减少碎片，提高内存的利用率。而段是信息的逻辑单位，段是一组有意义的相对完整的信息。分页是系统管理的需要，而分段的目的是为了满足用户的需要。</p><p>（2）页的大小是固定的，把逻辑地址分成页号和页内位移两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页；段的长度是可变的，由用户所编写的程序决定。</p><p>（3）页的逻辑地址空间是一维的，给出页的逻辑地址时只给出一个地址；而段的逻辑地址空间是二维的，在给出段的逻辑地址时既要给出段号，又要给出段内地址。</p></li><li><p>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。实际上，用户所感觉到的大容量是虚的，进程换进换出的工作是由操作系统自动完成的，用户是不知道的。虚拟存储器逻辑内存的容量由内存和外存对换区之和决定。</p></li><li><p>虚拟存储器的特征</p><p>（1）离散型。指进程不连续的装入内存多个不同的区域中。离散性是实现虚拟存储器的基础。如果采用连续分配方式，需将进程装入一个连续的内存区域，必须事先为进程一次性的分配内存空间，此时进程分多次调入内存没有什么意义。</p><p>（2）多次性。指一个进程分多次调入内存。即一个进程在运行时，只将当前要运行的那部分程序和数据调入内存，以后在进程运行过程中调入需要的其他部分。</p><p>（3）对换性。指进程在运行过程中，允许将部分程序和数据换进、换出。</p><p>（4）虚拟性。指能从逻辑上扩充内存容量，使用户感觉到的内存容量远远大于实际的内存容量。</p></li><li><p>当发生缺页时，对于从何处将缺页调入内存，有以下的3种实现方法：</p><p>（1）从对换区调入。进程装入时，将其所有页面复制到对换区，以后在执行过程中总是从对换区调入。这种方法速度比较快，但要求系统对换区的空间比较大。</p><p>（2）只将修改过的页放在对换区。对于修改过的页，在将它们换出时换到对换区，以后需要时再从对换区调入。这种方法适用于对换区空间较小的情况。</p><p>（3）首次从文件区调入，以后再次调入时从对换区调入。UNIX系统采用这种方法，凡是未运行过的页都应从文件区调入，运行后所有换出的页都换到对换区，下次调入时从对换区调入。</p></li><li><p>抖动和加载控制采取的措施：</p><p>（1）驻留集理论隐含了加载控制，只有驻留集足够大的进程才允许执行。在确定每个进程驻留集的大小时，就确定了进程的数目。</p><p>（2）调整多道程序的道数，使产生缺页的平均时间L等于系统处理缺页的平均时间S。性能研究表明，此时CPU的利用率最大。</p><p>（3）系统在采取可变分配策略时，尽可能的采取局部置换。到某进程发生缺页时，仅在进程自己的页面内进行置换，不影响其他进程分配的存储块数。这样即使出现了抖动，也局限在较小的范围内。</p><p>（4）当多道程序的道数出现偏高时，简单而有效的方法是挂起一些进程，以便腾出内存分配给出现抖动的进程。选择被挂起进程时应优先考虑优先级较低的进程、进程较大、缺页进程及剩余执行时间较大的进程。</p></li><li><p>与请求页式存储管理系统一样，请求段式存储管理系统也可以实现虚拟存储器。不同的是，请求页内存储管理系统以页为单位换进&#x2F;换出，而请求段式存储管理系统以段为单位进行置换。</p></li><li><p>缺段中断机构：缺段中断与缺页中断机构类似，同样需要在指令执行期间产生和处理中断。但由于段是信息的逻辑单位，不可能出现一条指令被分割在两个段中，也不会有被传送的数据被分割在两个段中的情况。</p></li><li><p>动态链接机制：间接字由链接中断位L和间接地址组成。链接中断用于表示要动态链接的段是否已链接上，用一个二进制位表示。</p><p>L&#x3D;1：表示其后的地址是间接地址，指令所涉及的段需要动态链接</p><p>L&#x3D;0：表示其后的是直接地址，不需要进行动态链接</p><p>间接地址就是指令中表示地址的部分不是所要存取数据的直接地址，而是间接地址，即存放直接地址的地址。</p></li><li><p>动态链接所需要的间接地址使得每次外部引用时都需要一次额外的内存访问，这是动态链接需要付出的代价。</p></li><li><p>I&#x2F;O管理的目标</p><p>（1）选择、分配及控制I&#x2F;O设备，以便能进行数据传输工作。</p><p>（2）为用户提供一个统一友好的接口，把用户与设备的硬件特性分开，用户与实际使用的具体物理设备无关，操作系统统一管理各种各样的物理设备。</p><p>（3）I&#x2F;O管理软件的层次结构。组成I&#x2F;O软件的各个程序按照其功能划分成若干层次，与用户程序相关的部分在最高层，而直接与I&#x2F;O硬件相关的部分，如中断处理程序在最底层。</p><p>（4）高效率。为了提高I&#x2F;O设备的使用效率，除了合理分配各种I&#x2F;O设备外，还要尽量提高设备与CPU、设备与设备之间的并行程度。</p></li><li><p>I&#x2F;O管理的主要功能：</p><p>（1）监视设备的状态。I&#x2F;O管理的功能之一就是记住所有的设备、控制器和通道的状态，以便有效的管理、调度和使用它们。</p><p>（2）进行设备分配。按照设备的类型和系统所采用的分配算法，实施设备分配，并把未分配到所请求设备、控制器和通道的进程投入等待队列。</p><p>（3）完成I&#x2F;O操作。尽量实现设备与CPU、设备与设备之间的并行。实现这一点需要相应硬件的支持，包括控制器、DMA或通道。</p><p>（4）缓冲管理。CPU的执行速度和访问内存的速度都比较高，而I&#x2F;O设备的数据传输速度则低的多。为了解决这种设备与CPU速度不匹配的问题，系统中一般都设有缓冲区来暂存数据。设备管理程序还要负责缓冲区的分配、释放及有关的管理工作。</p></li><li><p>I&#x2F;O设备种类繁多、特性各异，如终端、打印机、鼠标、硬盘驱动器、软盘驱动器、CD-ROM等。按设备进行信息交换的单位，I&#x2F;O设备可以分成块设备和字符设备。</p><p>块设备：也称为存储设备，是计算机用来存储信息的主要设备。例如磁盘，磁盘的特征之一是可寻址。磁盘按块编址，无论磁头当前处于什么位置，它都可以寻址到磁盘块所在的位置。</p><p>字符设备：字符设备也称为I&#x2F;O设备，用于数据的输入和输出。基本特征是不可寻址、传输速度低。字符设备在输入输出时常采用中断方式。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h1><ol><li>MTU&#x3D;MSS+ TCP Header + IP Header，MTU是网络传输最大报文包，MSS是网络传输数据最大值。</li><li><strong>MTU</strong>：maximum transmission unit,最大传输单元，由硬件规定，如以太网的MTU为1500字节。</li><li><strong>MSS</strong>:maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</li><li><strong>分片</strong>:若一IP数据报大小超过相应链路的MTU的时候，IPV4和IPV6都执行分片(fragmentation)，各片段到达目的地前通常不会被重组(re-assembling)。IPV4主机对其产生的数据报执行分片，IPV4路由器对其转发的数据也执行分片。然而IPV6只在数据产生的主机执行分片；IPV6路由器对其转发的数据不执行分片。</li><li>数据传输的三种交换方式：电路交换、报文交换、分组交换。</li></ol><p><a href="https://img-blog.csdn.net/20170104192709069?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempxXzEzMTQ1MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><img src="https://img-blog.csdn.net/20170104192709069?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempxXzEzMTQ1MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="三种交换"></a></p><p> 三种交换方式在数据传输阶段的主要特点：</p><p> <strong>电路交换</strong>：整个报文的比特流连续的从源点直达终点，好像在一个管道中传送。</p><p> <strong>报文交换</strong>：整个报文先传输到相邻的结点，全部存储下来后查找转发表，转发到下一个结点。</p><p> <strong>分组交换</strong>：单个分组（报文的一部分）传送到相邻结点，传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</p><ol><li><p>**速率:**单位时间内传送的比特数，其单位是b&#x2F;s(比特每秒)比特是计算机中的最小单位。</p><p>一个字节（Byte）&#x3D;8个bit</p><p>1Kb &#x3D; 1024bit</p><p>1KB &#x3D; 1024Byte</p><p>1Mb &#x3D; 1024Kb</p><p>1MB &#x3D; 1024KB</p><p>所以有1Mb &#x3D; 0.125MB（1&#x2F;8MB）</p></li><li><p><strong>带宽</strong>：在计算机网络中，带宽用来表示通信线路的数据传输能力，因此网络带宽指的是在单位时间内从网络的某一点到另一点所能通过的最高速率。</p></li><li><p><strong>时延</strong>：时延指的是数据从网络的一端传送到另一端所需的时间。网络中的时延有以下几个不同的部分组成：（1）发送时延（2）传播时延（3）处理时延（4）排队时延</p></li><li><p><strong>CSMA&#x2F;CD</strong>：Carrier Sense Multiple Access with Collision Detection，载波监听多点接入&#x2F;碰撞检测。</p><p>载波监听：检测信道，在发送数据前，发送数据中，每个站都要不断的检测信道。</p><p>多点接入：因为是总线型的网络，许多计算机以多点接入的方式连接在一根总线上。</p><p>碰撞检测：边发送边监听。</p><p>特别的是：该协议在物理上是通过电压的变化来检测碰撞是否发生。</p><p>在发送数据前已经监听了空闲信道，为什么还要在发送数据中监听呢？</p><p>因为电磁波在总线上的传播有时延，有速率的限制。所以如果A向B发送消息，必须要在时延之内的时间传送到，否则如果此时B发消息，则必然发生碰撞。发送站在发送数据后的一段时间内，数据存在碰撞的可能，以太网将这一现象称为<strong>发送的不确定性</strong>。</p></li><li><p><strong>截断二进制指数退避</strong>：如果发送数据没有碰撞，则顺利的传送了数据。那么如果发生了碰撞，我们如何重传数据呢？以太网采用的就是截断二进制指数退避，退避一词就是推迟的意思。</p><p>基本的算法思想就是：</p><p>（1）协议规定基本的退避时间为一个争用期的时间长度。（2t &#x3D; 51.2us）</p><p>（2）根据公式计算下列的k值：k &#x3D; min[重传次数，10]，当重传次数小于10，k就取重传次数，否则取10</p><p>（3）将k值代入下列整数集合中：[0，1，…（2^k-1）]，取得的整数记为r,r即为r倍的争用期。</p><p>（4）当重传次数达到16仍不能成功则丢弃该帧，向上层汇报。</p><p>由此可见，推迟的平均时间随着重传次数而增大。</p></li><li><p>OSI指的是开放系统互连模型。</p></li><li><p>同轴电缆分为两种基本类型，基带同轴电缆和宽带同轴电缆。目前基带常用的是电缆，其屏蔽线是用铜做成的网状的，特征阻抗是50欧（如RG-8、RG-58等）；宽带同轴电缆常用的电缆的屏蔽层通常是用铝冲压成的，特征阻抗是75欧（如RG-59等）。</p></li><li><p>调制解调器是调制器和解调器的缩写，一种计算机硬件，它能把计算机的数字信号翻译成可沿着普通电话线传送的模拟信号，而这些模拟信号又可被线路另一端的另一个调制解调器接收，并译成计算机可懂得语言。这一简单过程完成了两台计算机间的通信。它的主要功能是：信号转换、同步传输、多路复用、直接连接。</p></li><li><p>ATM是一种高速分组交换技术，它的基本数据传输单元是信元。信元有一个5字节的信元头和一个48字节的用户数据，它的长度是53字节。信元头包含信元控制信息，净荷用于承载用户的数据。ATM中信元的定义对ATM基本网络的总体性能，特别是对时间透明性和语义透明性都有着特殊的影响。</p></li><li><p>光导纤维作用：利用光导纤维可以进行光纤通信。激光的方向性强，频率高，是进行光纤通信的理想光源。光纤通信与电波通信相比，光纤通信能提供更多的通信通路，可满足大容量通信系统的需要。在实际使用中，常把千百根光导纤维组合在一起并加以增强处理，制成像电缆一样的光缆，这样既提高了光导纤维的强度，又大大增加了通信容量。</p></li><li><p>光纤分为两种，单模光纤和多模光纤。单模光纤（SMF）是一种在横向模式直接传输光信号的光纤。单模光纤运行在100M&#x2F;s或1G&#x2F;s的数据速率，传输距离都可以达到至少5公里。通常情况下，单模光纤用于远程信号传输。多模光纤（MMF）主要用于短距离的光纤通信，如在建筑物或校园内。典型的传输速度是100M&#x2F;s，传输距离可达2km，1G&#x2F;s可达1000m,10G&#x2F;s可达550m。有两种类型的折射率：渐变折射率和阶跃折射率。</p></li><li><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p></li><li><p><strong>波特率：</strong> 在电子通信领域，波特（Baud）即调制速率，指的是有效数据讯号调制载波的速率，即单位时间内载波调制状态变化的次数。表示每秒钟传送的码元符合的个数，它是对符号传输速率的一种度量，它用单位时间内载波调制状态改变的次数来表示，1波特即指每秒传输1个符号。</p></li><li><p><strong>比特率：</strong> 在通信和计算机领域，比特率（Bit rate）是单位时间内传输或处理的比特的位数，或者指信号（用数字二进制位表示）通过系统（设备、无线电波或导线）处理或传送的速率，即单位时间内处理或传输的数据量。</p></li><li><p>**波特率和比特率的关系：*<em>1波特即指每秒传输1个码元符号（通过不同的调制方式，可以在码元符号上负载多个bit位信息），1比特每秒是指每秒传输1比特（bit）。因此信息传输速率即比特率在数值上和波特率有这样的关系：I&#x3D;S</em>log2N。其中I为传信率，S为波特率，N为每个符号承载的信息量，而以比特为单位。波特率与比特率的关系也可以换算成：比特率 &#x3D; 波特率 * 单个调制状态对应的二进制位数。</p></li><li><p>FDDI（光纤分布式数据接口）是由美国国家标准化组织（ANSI）制定的在光缆上发送数字信号的一组协议。FDDI使用双环令牌，传输速率可以达到100Mb&#x2F;s。由于支持高宽带和远距离通信网络,FDDI通常用作骨干网。它可以用来互连单个计算机与局域网。使用802.2LLC协议，与IEEE802LAN兼容，使用基于IEEE802.5令牌标准的令牌传递MAC协议。</p></li><li><p>虚电路服务是一种面向连接的，使所有分组顺序到达目的端的可靠性数据传输服务。数据报服务是一种无连接的，使分组按照独立路由到达目的端的数据传输服务。</p><p>虚电路方式的主要特点如下：</p><p>（1）一次通信具有呼叫建立、数据传输和呼叫清除三个阶段，适用于两端之间长时间的数据交换。</p><p>（2）分组按照固定路由由顺序传输，分组在每个结点上存储、排队等待传输。</p><p>（3）分组传输时延小，可靠，分组不易丢失。</p><p>（4）线路或设备故障可能使虚电路中断时，需要重新呼叫建立新的连接。</p><p>数据报服务方式特点：</p><p>（1）每个分组所走过的路径可能是不同的。</p><p>（2）由于传输路径不同，各节点交换处理的时间不等，到达目的地的时间也不相同，于是就会出现到达目的地后各分组的顺序与发送时的顺序不同的情况，必须重新排序，再装配成报文。</p></li><li><p>停止等待协议是最简单但也是最基础的数据链路层协议。停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p></li><li><p>**滑动窗口协议：**发送端和接收端分别设定发送窗口和接受窗口。三次握手的时候，客户端把自己的缓冲区大小也就是窗口大小发送给服务器，服务器回应时也将窗口大小发送给客户端，服务器客户端都知道了彼此的窗口大小。</p></li><li><p>**停止等待ARQ协议：**当发送窗口和接收窗口都等于1时，就是停止等待协议。发送端给接收端发送数据，等待接收端确认回复ACK，并停止发送新的数据包，开启计时器。数据包在计时器超时之前得到确认，那么计时器就会关闭，并发送下一个数据包。如果计时器超时，发送端就认为数据包丢失或被破坏，需要重新发送之前的数据包，说明数据包在得到确认之前，发送端需要存储数据包的副本。停止等待协议是发出一个帧后得到确认才发下一个，降低了信道的利用率。</p></li><li><p>**退后N帧协议：**在发送完一个帧后，不用停下来等待确认，而是可以连续发送多个数据帧。收到确认帧时，任可发送数据，这样就减少了等待时间，整个通信的吞吐量提高。如果前一个帧在超时时间内未得到确认，就认为丢失或被破坏，需要重发出错帧及其后面的所有数据帧，这样有可能有把正确的数据帧重传一遍，降低了传送效率。</p></li><li><p>**选择重传协议:**NAK:非确认帧，当在一定时间内没有收到某个数据帧的ACK时，回复一个NACK。在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或被破坏，接收端只把出错的帧丢弃，其后面的数据帧保存在缓存中，并向发送端回复NAK。发送端接收到NAK时，只发送出错的帧。如果落在窗口的帧从未接收过，那么存储起来，等比它序列号小的所有帧都按次序交给网络层，那么此帧才提交给网络层。接收端收到的数据包的顺序可能和发送的数据包的顺序不一样。因此在数据包里必须含有顺序字符来帮助接收端来排序。选择重传协议可以避免重复传送那些正确到达接收端的数据帧。但是接收端要设置具有相当容量的缓存空间，这在许多情况下是不够经济的。</p></li><li><p><strong>滑动窗口协议</strong>属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。</p></li><li><p><strong>TCP&#x2F;IP</strong>（传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输的协议簇。<strong>SNMP</strong>（简单网络管理协议）是专门设计用于在IP网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。<strong>SMTP</strong>是一种提供可靠且有效的电子邮件传输的协议。<strong>TCP</strong>传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。</p></li><li><p><strong>透明网桥</strong>是一种即插即用设备，只要把网桥接入局域网，不需要改动硬件和软件，无需设置地址开关，无需装入路由器或参数，网桥就能工作。</p></li><li><p><strong>源路由网桥</strong>和透明桥接技术相竞争以期成为局域网联接的数据链路层的标准，运用了支撑树算法。</p></li><li><p>**多接口网桥-以太网交换机：**以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。</p></li><li><p>**以太网交换机的结构：**是每个端口都直接与主机相连，并且一般都工作在全双工方式。网桥的接口数很少，一般只有2~4，而以太网交换机通常都有十几个接口。以太网交换机的每个接口都直接与一个单个主机或另一个集线器相连，并且一般都工作在全双工方式。当主机需要通信时，以太网交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突的传输数据。以太网交换机实质上就是一个多接口的网桥，和工作在物理层的转发器和集线器有很大的差别。</p></li><li><p>**网络分类：**按照拓扑结构分类：总线型、环形、星型、网状。</p><p>按信息交换方式分类：电路交换、报文交换、报文分组交换。</p><p>按照覆盖范围分类：局域网LAN（作用范围一般为几米到几十公里）、城域网MAN（界于WAN与LAN之间）、广域网WAN（作用范围一般为几十到几千公里）</p></li><li><p>局域网LAN，局域网是结构复杂程度最低的计算机网络。局域网仅是在同一地点上经网络连在一起的一组计算机。局域网通常挨得很近，它是如今应用最广泛的一类网络。</p></li><li><p>广域网WAN是影响广泛的复杂网络系统。</p></li><li><p>网络传输介质：有线网、光纤网、无线网、局域网通常采用单一的传输介质。而城域网和广域网采用多种传输介质。按照通信方式分类：点对点传输网络、广播式传输网络。按照网络使用的目的分类：共享资源网、数据处理网、数据传输网、网络使用目的等。按照服务方式分类：客户机&#x2F;服务器网络、对等网。</p></li><li><p>时延是指一个报文或分组从一个网络的一端传送到另一端所需要的时间，包括了发送时延、传播时延、处理时延、排队时延。发送时延与传播时延是我们主要考虑的，对于报文长度较大的情况，发送时延与传播时延是主要考虑的。对于报文长度较大的情况，发送时延是主要矛盾；报文长度较小的情况，传播时延是主要矛盾。</p></li><li><p><strong>二元调制方法</strong>，最基本的二元制调制方法有以下几种：调幅（AM）：载波的振幅随基带数字信号而变化。调频（FM）：载波的频率随基带数字信号而变化。调相（PM）：载波的初始相位随基带信号而变化。</p></li><li><p>ARP（地址解析协议）：Address Resolution Protocol，是根据ip地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p></li><li><p>RARP（逆地址解析协议）：功能和ARP协议相对，其将局域网中某个主机的物理地址转换成IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p></li><li><p>MAC（Media Access Control或者Medium AccessControl）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。数据链路层负责MAC地址。一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。如果一台计算机有两张网卡，就会有两个物理地址。MAC地址就是计算机设备网卡上的地址，也叫物理地址。</p></li><li><p>面向连接通信中，连接的建立和释放是必不可少的过程。TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接的应用进程叫做服务器。</p></li><li><p>三网融合是一种广义的、社会化的说法，在现阶段它并不意味着电信网、计算机网和有线电视网三大网络的物理合一，而主要是指高层业务应用的融合，其表现为技术上趋向一致，网络层上可以实现互联互通，形成无缝覆盖，业务层上互相渗透和交叉，应用层上趋向一致使用统一的IP协议，为提供多样化、多媒体化、个性化服务的同一目标逐渐交汇到一起，通过不同的安全协议，最终形成一套网络中兼容多种业务的运维模式。</p></li><li><p>往返时延（RTT Round-Trip Time）：在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p></li><li><p>虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。</p></li><li><p>IP地址和物理地址的区别和联系：</p><p>区别：（1）唯一性 。MAC地址具有唯一性，每个硬件出厂时候的MAC地址是固定的；IP地址不具备唯一性，因此很多应用软件是围绕MAC地址开发的。（MAC地址是烧录在网卡或者接口上的物理地址，具有二层意义和全球唯一性，一般不能被改变。IP地址是网络中的主机或者三层接口在网络中的逻辑地址，在同一个网络内具有唯一性）。</p><p>（2）长度不同。物理地址是长度为48位，MAC地址的长度为48位（6个字节），通常表示12个16进制数，每2个16进制数之间用冒号隔开。IP地址目前主流是32位长(IPV4)即指使用TCP&#x2F;IP协议指定给主机的32位地址。IP地址由用点分隔开的4个8位组构成。</p><p>（3）实现原理不同。MAC地址属于由硬件实现，工作在数据链路层。IP地址工作在网络层和以上各层，是一种逻辑地址。</p><p>联系：</p><p>（1）IP地址和MAC地址通过ARP协议（地址解析协议）联系到一起</p><p>（2）IP地址和MAC地址结合起来传送数据包。</p><p>（3）IP地址可以和MAC地址进行绑定以此来确定网络上的唯一的一台电脑。</p></li><li><p>简答TCP的三次握手技术：第一次握手：客户端给服务器发送一个SYN段（在TCP标头中SYN位字段为1的TCP&#x2F;IP数据包），该段中也包含了客户端的初始序列号（Sequence number &#x3D; J）。第二次握手：服务器返回客户端SYN+ACK段（在TCP标头中SYN和ACK位字段都为1的TCP&#x2F;IP数据包），该段中包含服务器的初始序列号（Sequence number &#x3D; k），同时使Acknowledgement number &#x3D; J+1来表示确认已收到客户端的SYN段（Sequence number &#x3D; J）。第三次握手：客户端给服务器响应一个ACK段（在TCP标头中ACK位字段为1的TCP&#x2F;IP数据包），该段中使Acknowledgment number &#x3D; K + 1来表示确认已收到服务器的SYN段（Sequence number &#x3D; K）。</p></li><li><p>中继器（Repeater）工作在物理层，中继器是最简单的网络互联设备，连接同一个网络的两个或多个网段，主要完成物理层的功能，负责在两个网络节点的物理层上按位传递信息，完成信号的复制、调整和放大功能，以此从而增加信号传输的距离，延长网络的长度和覆盖区域。</p></li><li><p>集线器（Hub），工作在物理层，属于共享型设备，接收数据广播发出，在局域网内一般是星型连接拓扑结构，所有的工作站都连接到集线器上。集线器的主要功能是对接收到的信号进行同步整形放大，以扩大网络的传输距离，是中继器的一种形式。</p></li><li><p>交换机，交换机顾名思义以交换为主要功能，工作在数据链路层，根据MAC地址进行数据转发。交换机的每一个端口都属于一个冲突域，而集线器所有端口属于一个冲突域。</p></li><li><p>网桥，工作在OSI模型的数据链路层，可以看成是一个二层路由器。网桥可有效的将两个局域网（LAN）连起来，根据MAC地址（物理地址）来转发帧，使本地通信限制在本网段内，并转发相应的信号至另一网段，网桥通常用于联结数量不多的、同一类型的网段。</p></li><li><p>路由器，工作在OSI的网络层，根据IP进行寻址转发数据包。路由器是一种可以连接多个网络或网段的网络设备，能将不同网络或网段之间（比如局域网-大网）的数据信息进行转换，并为信包传输分配最合适的路径，使它们之间能够进行数据传输，从而构成一个更大的网络。</p></li><li><p>网关（Gateway）又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间。</p></li><li><p><strong>计算机网络采用层次化结构的优点</strong>包括：（1）分层结构将应用系统正交的划分成若干层，每一层只解决问题的一部分，通过各层的协作提供整体解决方案，有效的降低了单个问题的规模和复杂度。（2）分层结构具有良好的可扩展性。（3）分层架构易于维护。</p></li><li><p>什么是数据交换？是指在多个数据终端设备之间，为任意两个终端设备建立数据通信临时互连通路的过程。可分为电路交换、报文交换、分组交换。</p></li><li><p>**电路交换：**由于电路交换在通信之前要在通信双方之间建立一条被双方独占的物理通路（由通信双方之间的交换设备和链路逐段连接而成）。</p><p><strong>优点：</strong></p><p>（1）由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。</p><p>（2）通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。</p><p>（3）双方通信时按发送顺序传送数据，不存在失序问题。</p><p>（4）电路交换既适用于传输模拟信号，也适用于传输数字信号。</p><p>（5）电路交换的交换的交换设备（交换机等）及控制均较简单。</p><p><strong>缺点：</strong></p><p>（1）电路交换的平均连接建立时间对计算机通信来说较长。</p><p>（2）电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。</p><p>（3）电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</p></li><li><p>**报文交换：**报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式。</p><p><strong>优点：</strong></p><p>（1）报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。</p><p>（2）由于采用存储转发的传输方式，使之具有下列优点：</p><p> a. 在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性。</p><p> b.在存储转发中容易实现代码转换和速率匹配，甚至收发双发可以不同时处于可用状态，这样就便于类型、规格和速度不同的计算机之间进行通信。</p><p> c.提供多目标服务，即一个报文可以同时发送到多个目的地，这在电路交换中是很难实现的。</p><p> d.允许建立数据传输的优先级，使优先级高的报文优先转换。</p><p>（3）通信双方不是固定的占有一条通信线路，而是在不同的时间一段一段的部分占有这条物理通路，因而大大提高了通信线路的利用率。</p><p><strong>缺点：</strong></p><p>（1）由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。</p><p>（2）报文交换只适用于数字信号。</p><p>（3）由于报文长度没有限制，而每个中间结点都要完整的接收传来的报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p></li><li><p>**分组交换：**分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组（携带源、目的地址和编号信息）逐个的发送出去，因此分组交换除了具有报文的优点外，与报文交换相比还有以下优缺点：</p><p><strong>优点：</strong></p><p>（1）加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式的传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。</p><p>（2）简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。</p><p>（3）减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。</p><p>（4）由于分组短小，更适用于优先级策略，便于及时传送一些紧急数据，因此对于计算机之间的突发式的数据通信，分组交换显然更为合适。</p><p><strong>缺点：</strong></p><p>（1）尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。</p><p>（2）分组交换与报文交换一样，每个分组都要加上源、目的地址和分组编号等信息，使传送的信息量大约增大5%~10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。</p><p>（3）当分组交换采用数据报服务的时候，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p></li><li><p>总之，如果要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合计算机之间的突发式的数据通信。</p></li><li><p><strong>通信过程中的差错</strong>大致可以分成两类：一类是由热噪声引起的随机错误；另一类是由冲突噪声引起的突发错误。突发性错误影响局部，而随机性错误影响全局。</p></li><li><p><strong>差错产生的原因</strong>主要是由线路本身电气特性所产生的随机噪声（热噪声），信号振幅、频率和相位的衰减或畸变，电信号在传输介质上的反射回音效应，相邻线路的串扰，外界的电磁干扰和设备故障等因素造成的。</p></li><li><p><strong>差错控制方式：</strong>（1）前向纠错。实时性好，单工通信采用（2）自动重发请求（ARQ）。强调检错能力，不要求有纠错能力，双向通道采用。（3）混合纠错。上述两种方式的综合，但传输设备相对复杂。</p></li><li><p>**介质访问控制（Medium Access Control）**简称MAC，是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。它定义了数据帧怎样在介质上进行传输。在共享同一个带宽的链路中，对连接介质的访问是“先来先服务”的。物理寻址在此处被定义，逻辑拓扑（信号通过物理拓扑的路径）也在此处被定义。线路控制、出错通知（不纠正）、帧的传递顺序和可选择的流量控制也在这一子层中实现。</p></li><li><p><strong>交换机和集线器的区别：</strong></p><p>（1）工作层次。集线器工作在物理层，每发送一个数据，所有的端口均可以收到，采用了广播的方式，因此网络性能受到很大的限制。交换机工作在数据链路层，每个端口形成一张MAC地址转发表，根据数据包的MAC地址转发数据，而不是广播形式。</p><p>（2）转发方式。集线器的工作原理是广播形式，无论哪个端口收到数据之后，都要广播到所有的端口，当接入设备比较多时，网络性能会受到很大的影响。交换机根据MAC地址转发数据，收到数据包之后，检查报文的目的MAC地址，找到对应的端口进行转发，而不是广播到所有的端口。</p><p>（3）传输模式。集线器内部采用了总线型拓扑，各个结点共用一条总线进行通信，数据包的发送和接收采用了CSMA&#x2F;CD协议，在同一时间内必须是单向的，只能维持在半双工模式下，两个端口不能同时收发数据，并且当两个端口通信时，其他端口不能工作。当交换机上的两个端口通信时，它们之间的通道是相互独立的，可以实现全双工通信。两个端口同时收发数据。</p><p>（4）带宽影响。集线器无论有多少个端口，所有的端口共享一条宽带，同一时刻只能有两个端口传输数据，并且只能工作在半双工模式下。交换机的网络性能要远远优于集线器。随着技术的进步，交换机的成本已经降低，集线器逐步退出市场。</p></li><li><p>IEEE802.2协议中10BASE—T标准规定使用5类UTP时网卡到集线器的最大距离是100米。</p></li><li><p>PPP协议是数据链路层的协议。</p></li><li><p>无线信道是对无线通信中发送端和接收端之间通路的一种形象的比喻，对于无线电波而言，它从发送端传送到接收端，其间并没有一个有形的连接，它的传播路径也有可能不只一条。无线信道也就是常说的无线的“频段”。</p></li><li><p>信道带宽是限定允许通过该信道的信号下限频率和上限频率，可以理解为一个频率通带。比如一个信道允许的通带为1.5kHz至15kHz，则其带宽为13.5kHz。</p></li><li><p>奈奎斯特定理 C&#x3D;2HlogN(以2为底)。</p><p>某信道带宽为10kHz，编码采用32种不同的物理状态来表示数据，则无噪声环境下，该信道的最大传输速率是:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">c</span>=<span class="hljs-number">2</span>*<span class="hljs-number">10</span>*log2（<span class="hljs-number">32</span>）=<span class="hljs-number">2</span>*<span class="hljs-number">10</span>*<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>H &#x3D; 10kHz 带宽 N&#x3D;32 不同的物理状态</p></li><li><p>一个VLAN可以看成一个广播域。</p></li><li><p>在以太网中，如果某个CSMA&#x2F;CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA&#x2F;CD网络就是一个<strong>冲突域</strong>。广播是一种信息的传播方式，指网络中的某一设备同时向网络中所有的其他设备发送数据，这个数据所能广播到的范围即为<strong>广播域</strong>。简单点说，<strong>广播域</strong>就是指网络中所有能接收到同样广播消息的设备的集合。<strong>管理域</strong>是一些资源的集合，域内的行为服从于一个系统管理的政策。由行政部门或组织管理的一组逻辑单元为一个管理域（MD），它分为公用管理域（ADMD）和专门管理域（PRMD）。</p></li><li><p>双绞线分屏蔽和非屏蔽两种。</p></li><li><p>利用集线器可将总线型网络转换成星型拓扑。</p></li><li><p>多路复用的方法中，从性质上来说，频分多路复用较适用于模拟信号传输，而时分多路复用较适用于数字信号传输。</p></li><li><p>普通家庭使用的电视机通过机顶盒设备可以实现上网冲浪漫游。</p></li><li><p>**文件传输协议（FTP）**是用于在网络上进行文件传输的一套标准协议，它工作在应用层，使用TCP传输而不是UDP，客户在和服务器建立连接前要经过一个“三次握手”的过程，保证客户和服务器之间的连接是可靠的，而且是面向连接，为数据传输提供可靠保证。FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。<strong>用户数据包协议（UDP）<strong>支持一个无连接的传输协议,工作在</strong>传输层。</strong> <strong>传输控制协议（TCP）<strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作，工作在</strong>传输层。</strong> <strong>网际互连协议（IP）<strong>是TCP&#x2F;IP体系中的</strong>网络层</strong>协议。</p></li><li><p><strong>工作组</strong>是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p></li><li><p><strong>虚电路</strong>是分组交换的两种传输方式中的一种。在通信和网络中，虚电路是由分组交换通信所提供的面向连接的通信服务。虚电路协议向高层协议隐藏了将数据分割成段，包或帧的过程。</p></li><li><p>采用虚电路分组交换方式时，可以省去的阶段是<strong>建立物理连接</strong>。</p></li><li><p><strong>介质访问控制方法简称MAC</strong>，是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。它定义了数据帧怎样在介质上进行传输。在共享同一个带宽的链路中，对连接介质的访问是“先来先服务”的。</p></li><li><p><strong>协议组</strong>是协议的层次集合，每层为下一个最高层提供服务。</p></li><li><p>OSI&#x2F;RM模型中，<strong>传输层</strong>用来在设备的进程间传递报文。</p></li><li><p><strong>协议组</strong>是协议的层次集合，每层为下一个最高层提供服务。</p></li><li><p>数据链路层处理设备到设备的通信，传输层处理端结点间的通信。</p></li><li><p>虚电路也有连接建立、数据传输、连接释放三阶段、虚电路的各个结点不需要为每个分组作路径选择判定。</p></li><li><p><strong>SMTP</strong>是一种提供可靠且有效的电子邮件传输的协议，SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。</p></li><li><p><strong>POP</strong>的全称为Post Office Protocol，即邮局协议，用于电子邮件的接收。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。</p></li><li><p>TCP&#x2F;IP协议簇包含一个提供对电子邮箱进行远程获取的协议，称为POP。</p></li><li><p>OSPF协议是域内路由协议。</p></li><li><p>在虚电路服务中分组的顺序总是按发送顺序到达目的站。</p></li><li><p>内部网关协议RIP是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议。内部网关协议OSPF开放最短路径优先，OSPF最主要的特征是使用了分布式的链路状态协议。</p></li><li><p>协议是不同结点对等实体之间进行通信的规则或约定。</p></li><li><p>**非对称数字用户线路（ADSL）**是数字用户线路服务中最流行的一种，采用了上、下行不对称的高速数据调制技术。</p></li><li><p><strong>IP、ICMP协议</strong>工作在网络层，<strong>SMTP、SNMP协议</strong>工作在应用层，<strong>TCP、UDP协议</strong>工作在运输层。</p></li><li><p><strong>私有地址范围：</strong></p><p>A类地址：10.0.0.0~10.255.255.255</p><p>B类地址：172.16.0.0~172.31.255.255</p><p>C类地址：192.168.0.0~192.168.255.255</p></li><li><p>Internet控制报文协议（ICMP），它是TCP&#x2F;IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p></li><li><p>通常的路由器可以支持多种网络层协议，并提供不同协议之间的分组转换。</p></li><li><p>公共交换电话网（PSTN）和综合业务数字网（ISDN）都是采用电路交换技术的通信网络。X.25、帧中继及ATM等都是采用交换技术的广域网。</p></li><li><p>127开头的IP地址是保留回环地址，不可能出现在网络上，主要用于测试。</p></li><li><p>一个计算机网络的3个主要组成部分是一个通信子网、一系列通信协议、若干主机。</p></li><li><p>交换机带宽计算:端口数x相应的端口速率x2（全双工模式）。</p></li><li><p>MAC地址是一个6字节的二进制串，地址的前3个字节代表厂商代码，后3个字节由厂商自行分配。</p></li><li><p>共享式以太网需要进行冲突检测，仅能实现半双工流量控制，利用CSMA&#x2F;CD介质访问机制。</p></li><li><p>VLAN的主要作用有保证网络安全、抑制广播风暴、简化网络管理、提高网络设计的灵活性。</p></li><li><p>计算机网络从逻辑功能上分为通信子网和资源子网。</p></li><li><p>物理层的技术特性有机械特性、电气特性、功能特性、规程特性。</p></li><li><p>调制解调器一般由基带处理、调制解调、信号放大和滤波、均衡等几部分组成。调制是将数字信号与音频载波组合，产生适合于电话线上传输的音频信号（模拟信号），解频是从音频信号中恢复出数字信号。调制解调器一般分为外置式、内置式和pc卡式三种。</p></li><li><p>令牌环总线的管理包括逻辑环的初始化、站点的入环、站点撤出环路、多令牌处理。</p></li><li><p>决定局域特性的主要技术要素是网络拓扑、传输介质、介质访问控制方法。</p></li><li><p>网络<strong>按照通信方式分类</strong>，可分为点对点传输网络和广播式传输网络。</p></li><li><p><strong>集线器的工作过程</strong>：首先是结点发信号到线路，集线器接收该信号，因信号在电缆传输中有衰减，集线器接收信号后将衰减的信号整形放大，最后集线器将放大的信号广播转发到其他所有端口。</p></li><li><p><strong>集线器</strong>连接的网络物理上（外观）是星型网络，逻辑上还是总线型网络。</p></li><li><p>星型拓扑结构是由通过点到点链路连接到中央结点的各站点组成的，星型网络中有一个唯一的转发结点（中央结点），每一个计算机都通过单独的通信线路连接到中央结点，星型拓扑的优点是：利用中央结点可以方便的提供服务和重新配置网络。</p></li><li><p><strong>电话交换机的结构</strong>是星型网状拓扑结构，它在一个单位内为综合语音和数据工作站交换信息提供信道，还可以提供语音信箱和电话会议等业务，是局域网的一个分支。</p></li><li><p>交换机的物理结构是星型拓扑结构，逻辑上也是星型拓扑结构。</p></li><li><p><strong>IP</strong>只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。</p></li><li><p><strong>网桥</strong>只能隔离冲突域，<strong>路由器</strong>能隔离广播域。</p></li><li><p><strong>FDM的前提</strong>是传输介质的可用带宽要大于多路给定信号所需带宽的总和。<strong>TDM</strong>可分为同步TDM和异步TDM，异步TDM又称为统计时分多路复用技术，对于模拟信号，可以将TDM和FDM组合起来使用。</p></li><li><p>虚电路交换包括三个阶段：建立连接、传输数据、拆除连接，建立连接之后就类似于专线，所以不存在路由选择。</p></li><li><p>逻辑链路控制（<strong>LLC</strong>） 介质访问控制（<strong>MAC</strong>）</p></li><li><p>路由选择算法包括两种：静态路由选择算法和动态路由选择算法。</p><p>静态路由选择算法包括</p><p>（1）洪泛法</p><p>（2）随机走动法</p><p>（3）最短路径法</p><p>（4）基于流量的路由算法</p><p>动态路由算法包括</p><p>（1）距离矢量路由算法</p><p>（2）链路状态路由算法</p></li><li><p>**串行线路网际协议（SLIP）**是一个在串行线路上对IP分组进行封装的简单的面向字符的协议，用以使用户通过电话线和调制解调器接入Internet。</p></li><li><p><strong>数据传输单元</strong>：物理层-比特流 数据链路层-帧 网络层-数据包 运输层-数据段 应用层-数据</p></li><li><p>IP数据报分为首部和数据两部分。</p></li><li><p>信道复用技术包括<strong>频分多路复用</strong>、<strong>时分多路复用</strong>、<strong>波分多路复用</strong>和<strong>码分多路复用</strong>。</p></li><li><p>目前广域网主要采用网状拓扑结构，它的优点是不受瓶颈问题和失效问题的影响。由于结点之间有许多条路径相连，可以为数据流的传输选择适当的路由，从而绕过失效的部件或过忙的节点。这种结构虽然比较复杂，成本也比较高，提供上述功能的网络协议也比较复杂，但由于它的可靠性高，仍然受到欢迎。</p></li><li><p>决定局域网的主要技术要素为：网络拓扑、传输介质、介质访问控制方法。</p></li><li><p>在局域网中常用的拓扑结构是:星型、环型、总线型拓扑。</p></li><li><p><strong>ARP协议</strong>用于将计算机的网络地址转换成物理地址。</p></li><li><p>域名解析是为了解决数字化的IP地址不便记忆的问题而引入的一种层次型命名机制，完成名字-地址的映射。</p></li><li><p><strong>电路交换</strong>是一种直接的交换方式，它为一对需要进行通信的装置（站）之间提供一条临时的专用通道，即提供一条专用的传输通道，即可是物理通道又可是逻辑通道。（使用时分或频分复用技术）<strong>存储转发交换方式</strong>又可以分为<strong>报文存储转发与报文分组存储转发</strong>，报文分组存储转发交换方式又可以分为数据报与虚电路方式。</p></li><li><p><strong>TCP的功能</strong>是将数据流从一台主机可靠的传输到另一台主机。</p></li><li><p><strong>MAC帧最小的数据长度</strong>为64字节，MAC帧头占18个字节，故数据长度必须大于46个字节，如不够则进行补充。</p></li><li><p><strong>DNS服务器</strong>为客户提供存储、查询和搜索其它主机域名和IP地址的服务。主要实现域名与IP地址之间的转换，以解决IP地址难以记忆的问题。</p></li><li><p>访问网站的过程中，TCP&#x2F;IP参考模型各层的协议用到了哪些？作用是什么？并简述流程。</p><p>应用层：HTTP：WWW访问协议、DNS:域名解析。</p><p>传输层： TCP：在客户和服务器之间建立连接，提供可靠的数据传输。</p><p>网络层：IP：进行路由选择 ICMP：提供网络传输中的差错检测 ARP：将目的IP地址映射成物理MAC地址。</p><p>网络接口层：LLC和MAC：提供数据链路层的功能，实现可靠的数据链路。</p><p>过程：</p><p>利用DNS，查询到<a href="http://www.google.com对应的ip地址./">www.google.com对应的IP地址。</a></p><p>浏览器与google的服务器利用TCP协议建立连接。</p><p>浏览器利用HTTP的GET方法向google服务器发送资源请求。</p><p>google发送回应消息。</p><p>浏览器解释回应消息，并以图形化的方式显示。</p></li><li><p>IP地址为202.112.14.137，子网掩码为255.255.255.224</p><p>网络地址：202.112.14.128</p><p>网络号：202.112.14</p><p>主机地址：202.112.14.137</p><p>主机号：9</p><p>子网号：128</p><p>子网地址：202.112.14.128</p><p>ip地址与子网掩码进行与运算，结果是网络地址。</p><p>子网地址也可以说是网络地址，也是ip地址和子网掩码进行与运算。</p></li><li><p>127开头的IP地址是保留回环地址，不可能出现在网络上的。</p></li><li><p>IP地址和网络ID不同。</p></li><li><p>调制解调器的组成包括：基带处理、调制解耦、信号放大、均衡。</p></li><li><p>以太网是应用最普遍的局域网技术，取代了其他局域网技术如令牌环、FDDI和ARCNET。</p></li><li><p>在ISO&#x2F;OSI参考模型中，同层对等实体间进行信息交换时必须遵守的规则称为协议，相邻层间进行信息交换时必须遵守的规则称为接口，相邻层间进行信息交换是使用的一组操作原语称为服务，运输层的主要功能是提供端到端的信息传送，它利用网络层提供的服务来完成此功能。</p></li><li><p>没有服务器控制的通信区域，则为对等网。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象语言的多分派、单分派、双重分派机制</title>
    <link href="/2021/11/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%9A%E5%88%86%E6%B4%BE%E3%80%81%E5%8D%95%E5%88%86%E6%B4%BE%E3%80%81%E5%8F%8C%E9%87%8D%E5%88%86%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/11/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%9A%E5%88%86%E6%B4%BE%E3%80%81%E5%8D%95%E5%88%86%E6%B4%BE%E3%80%81%E5%8F%8C%E9%87%8D%E5%88%86%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、分派的概念"><a href="#一、分派的概念" class="headerlink" title="一、分派的概念"></a>一、分派的概念</h1><p>变量被声明时的类型叫做变量的静态类型（Static Type），又叫做明显类型（Apparent Type）。变量所引用的对象的真实类型又叫做变量的实际类型（Actual Type）。根据对象的类型而对方法进行的选择，就是分派（Dispatch）。根据分派发生的时期，可以将分派分为两种，即静态分派和动态分派。</p><p><strong>静态分派</strong>发生在编译时期，分派根据静态类型信息发生。方法重载（Overload）就是静态分派。</p><p><strong>动态分派</strong>发生在运行时期，动态分派动态的置换掉某个方法，面向对象的语言利用动态分派来实现方法置换产生的多态性。</p><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><p>Java通过方法重载来支持静态分派。重载方法的分派是根据静态类型进行的。这个分派过程在编译时期就完成了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span> </span>&#123;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlackHorse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Horse</span></span>&#123;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhiteHorse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Horse</span></span>&#123;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mozi</span></span><br>&#123;<br>    public void ride(<span class="hljs-type">Horse</span> h)<br>    &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Riding a horse&quot;</span>);<br>    &#125;<br><br>    public void ride(<span class="hljs-type">WhiteHorse</span> wh)<br>    &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Riding a white horse&quot;</span>);<br>    &#125;<br><br>    public void ride(<span class="hljs-type">BlackHorse</span> bh)<br>    &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Riding a black horse&quot;</span>);<br>    &#125;<br><br>    public static void main(<span class="hljs-type">String</span>[] args)<br>    &#123;<br>        <span class="hljs-type">Horse</span> wh = <span class="hljs-keyword">new</span> <span class="hljs-type">WhiteHorse</span>();<br><br>        <span class="hljs-type">Horse</span> bh = <span class="hljs-keyword">new</span> <span class="hljs-type">BlackHorse</span>();<br><br>        <span class="hljs-type">Mozi</span> mozi = <span class="hljs-keyword">new</span> <span class="hljs-type">Mozi</span>();<br><br>        mozi.ride(wh);<br>        mozi.ride(bh);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @directed </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Horse</span> lnkHorse;<br>&#125;<br><span class="hljs-comment">/**结果：</span><br><span class="hljs-comment">    Riding a horse</span><br><span class="hljs-comment">    Riding a horse</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-type">String</span> s1 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">Object</span> o = s1 +<span class="hljs-string">&quot;c&quot;</span>;<br><span class="hljs-type">String</span> s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">boolean</span> b = o.<span class="hljs-keyword">equals</span>(s);<br></code></pre></td></tr></table></figure><p>上述代码返回了true（基础多态就不多说了）。</p><p>上面的例子中，变量s1和s的静态类型和真实类型都是String,而o的静态类型是Object，真实类型则是Object类型的一个子类型。分析： 如果上面最后一行的equals方法调用的是String类的equals方法，那么上面代码检查的就是o的值是否博字符串”abc” ，相反，如果上面的equals方法调用的是Object类的equals方法，那么检查的就是o所指的对象和s1所指的对象是不 是同一个对象. 所以问题的核心是Java编译器在编译时期并不总是知道哪一些代码会被执行，因为编译器仅仅知道对象的静态类型， 而不知道对象的真实类型，而方法的调用则是根据真实类型(o的真实类型为String)，而不是静态类型。变量o指向一 个类型为String的对象，这个String对象的值是”abc”，这样一来，一面最后一行的equals方法调用的是String类的 equals方法，而不是Object类的equals方法.</p><h1 id="二、分派的类型"><a href="#二、分派的类型" class="headerlink" title="二、分派的类型"></a>二、分派的类型</h1><p>一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参量统称做方法的宗量。</p><p>根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言和多分派语言。单元分派语言根据一个宗量的类型（真实类型）进行对方法的选择,多分派语言根据多于一个的宗量的类型对方法进行选择。</p><p>C++和Java以及Smaltalk都是单分派语言；多分派语言的例子包括CLOS和Cecil。按照这样的区分，C++和Java就是动态的单分派语言，因为这两种语言的动态分派仅仅会考虑到方法的接收者的类型，同时又是静态的多分派语言，因为这两种语言对重载方法的分派会考虑到方法的接收者的类型和方法所有参量的类型。</p><p> 在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者**。在JAVA语言里面，如果一个操作是作用于某个类型不明的对象上面的。那么这个对象的真实类型测试仅会发生一次。这个就是动态的单分派的特征。**</p><p>一言以蔽之，JAVA语言支持静态的多分派和动态的单分派。</p><h1 id="三、双重分派"><a href="#三、双重分派" class="headerlink" title="三、双重分派"></a>三、双重分派</h1><p>一个方法根据两个宗量的类型来决定执行不同的代码，这就是“双分派”或者“多重分派”。java不支持动态的多分派。但可以通过使用设计模式，在java语言里面实现动态的双重分派。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>log4j配置详情</title>
    <link href="/2021/10/23/log4j%E9%85%8D%E7%BD%AE%E8%AF%A6%E6%83%85/"/>
    <url>/2021/10/23/log4j%E9%85%8D%E7%BD%AE%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<h1 id="一、构成"><a href="#一、构成" class="headerlink" title="一、构成"></a>一、构成</h1><p>Log4j的配置文件（Configuration File）就是用来记录设置记录器的级别，存放器和布局的。</p><p>Log4j由三个重要的组件构成：日志信息的优先级、日志信息的输出目的地、日志信息的输出格式。</p><p>日志信息的优先级从高到低有ERROR WARN INFO DEBUG,分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p><h1 id="二、配置文件定义"><a href="#二、配置文件定义" class="headerlink" title="二、配置文件定义"></a>二、配置文件定义</h1><p>1.配置文件基本格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#配置根Logger<br>log4j<span class="hljs-selector-class">.rootLogger</span>  =   <span class="hljs-selector-attr">[ level ]</span>   ,  appenderName1 ,  appenderName2 ,  …<br><br>#配置日志信息输出目的地Appender<br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span>  =  fully<span class="hljs-selector-class">.qualified</span><span class="hljs-selector-class">.name</span><span class="hljs-selector-class">.of</span><span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.class</span> <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.option1</span>  =  value1 <br>… <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.optionN</span>  =  valueN <br><br>#配置日志信息的格式（布局）<br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.layout</span>  =  fully<span class="hljs-selector-class">.qualified</span><span class="hljs-selector-class">.name</span><span class="hljs-selector-class">.of</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.class</span> <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.option1</span>  =  value1 <br>… <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.optionN</span>  =  valueN <br></code></pre></td></tr></table></figure><p>2.配置根Logger，语法为:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log4j.rootLogger</span> = [ level ] , appenderName, appenderName, …<br></code></pre></td></tr></table></figure><p>其中，level是日志记录的优先级，分为OFF FATAL ERROR WARN INFO DEBUG ALL或者我们个人定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是ERROR WARN INFO DEBUG。通过在这里定义级别，您可以控制到应用程序中相应的级别的日志信息的开关。</p><p>level级别</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">FATAL      0  <br><span class="hljs-keyword">ERROR      </span>3  <br>WARN       4  <br>INFO       6  <br>DEBUG      7<br></code></pre></td></tr></table></figure><p>2.配置日志信息输出目的地Appender，语法为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span> = fully<span class="hljs-selector-class">.qualified</span><span class="hljs-selector-class">.name</span><span class="hljs-selector-class">.of</span><span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.class</span>  <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.option1</span> = value1  <br>…  <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.option</span> = valueN<br></code></pre></td></tr></table></figure><p>Appender为日志输出目的地，Log4j提供的Appender有以下几种：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.ConsoleAppender（控制台），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.FileAppender（文件），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.DailyRollingFileAppender（每天产生一个日志文件），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.WriterAppender（将日志信息以流格式发送到任意指定的地方）<br></code></pre></td></tr></table></figure><p>3.配置日志信息的格式（布局），其语法为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.layout</span> = fully<span class="hljs-selector-class">.qualified</span><span class="hljs-selector-class">.name</span><span class="hljs-selector-class">.of</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.class</span>  <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.option1</span> = value1  <br>…  <br>log4j<span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.appenderName</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.option</span> = valueN<br></code></pre></td></tr></table></figure><p>Layout是日志输出格式，Log4j提供的layout有以下几种：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.HTMLLayout（以HTML表格形式布局），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.PatternLayout（可以灵活地指定布局模式），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.SimpleLayout（包含日志信息的级别和信息字符串），<br>org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.log4j</span>.TTCCLayout（包含日志产生的时间、线程、类别等等信息）<br></code></pre></td></tr></table></figure><p>打印参数：Log4j采用类似C语言中的printf函数的打印格式格式化日志信息，如下：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">m</span></span>   输出代码中指定的消息<br><span class="hljs-tag">%<span class="hljs-selector-tag">p</span></span>   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL <br><span class="hljs-tag">%<span class="hljs-selector-tag">r</span></span>   输出自应用启动到输出该log信息耗费的毫秒数 <br><span class="hljs-tag">%<span class="hljs-selector-tag">c</span></span>   输出所属的类目，通常就是所在类的全名 <br><span class="hljs-tag">%<span class="hljs-selector-tag">t</span></span>   输出产生该日志事件的线程名 <br><span class="hljs-tag">%<span class="hljs-selector-tag">n</span></span>   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” <br><span class="hljs-tag">%<span class="hljs-selector-tag">d</span></span>   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss , SSS&#125;，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921  <br><span class="hljs-tag">%<span class="hljs-selector-tag">l</span></span>   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2021/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h1><h2 id="1-解释"><a href="#1-解释" class="headerlink" title="1.解释"></a>1.解释</h2><p>简单工厂模式（Simple Factory Pattern）属于类的创新型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern），是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</p><h2 id="2-包含的角色"><a href="#2-包含的角色" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）工厂角色（creator）：简单工厂模式的核心，由它负责创建所有类的内部逻辑。而且工厂必须能够被外界调用，创建所需要的产品对象。</p><p>（2）抽象产品角色（product）：简单工厂模式所创建的所有对象的父类，注意，这里的父类可以是接口类也可以是抽象类，它负责描述所有实例所共有的公共接口。</p><p>（3）具体产品角色（concrete product）：简单工厂所创建的具体实例对象，这些具体的产品往往拥有共同的父类。</p><h2 id="3-使用场景分析及代码实现"><a href="#3-使用场景分析及代码实现" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>————–食品加工工厂实现代码——————-</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象产品角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Food</span>&#123;<br>    <span class="hljs-comment">//获得相应的食物</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体产品角色</span><br><span class="hljs-comment">//麦香鸡</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">McChicken</span> <span class="hljs-title">implements</span> <span class="hljs-title">Food</span>&#123;<br>    <span class="hljs-comment">//获得一份麦香鸡</span><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;一份麦香鸡&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//薯条</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Chips</span> <span class="hljs-title">implements</span> <span class="hljs-title">Food</span>&#123;<br>    <span class="hljs-comment">//获得一份薯条</span><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;一份薯条&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//工厂角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FoodFactory</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Food <span class="hljs-title">getFood</span>(<span class="hljs-params">String type</span>) throws InstantiationException,IllegalAccessException,ClassNotFoundException</span>&#123;<br>        <span class="hljs-keyword">if</span>(type.equalsIgnoreCase(<span class="hljs-string">&#x27;mcchicken&#x27;</span>))&#123;<br>            <span class="hljs-keyword">return</span> McChicken.<span class="hljs-keyword">class</span>.newInstance();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equalsIgnoreCase(<span class="hljs-string">&quot;chips&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> Chips.<span class="hljs-keyword">class</span>.newInstance();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;找不到相应的实例化类了！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactoryTest</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)throws InstantiationException,IllegalAccessException,ClassNotFoundException</span>&#123;<br>        <span class="hljs-comment">//实例化各种食物</span><br>        Food mcChicken = FoodFactory.getFood(<span class="hljs-string">&quot;McChicken&quot;</span>);<br>        Food chips = FoodFactory.getFood(<span class="hljs-string">&quot;Chips&quot;</span>);<br>        Food eggs = FoodFactory.getFood(<span class="hljs-string">&quot;Eggs&quot;</span>);<br>        <span class="hljs-comment">//获取食物</span><br>        <span class="hljs-keyword">if</span>(mcChicken != <span class="hljs-literal">null</span>)&#123;<br>            mcChicken.<span class="hljs-keyword">get</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(chips != <span class="hljs-literal">null</span>)&#123;<br>            chips.<span class="hljs-keyword">get</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(eggs != <span class="hljs-literal">null</span>)&#123;<br>            eggs.<span class="hljs-keyword">get</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*结果</span><br><span class="hljs-comment">找不到相应的实例化类了</span><br><span class="hljs-comment">一份麦香鸡</span><br><span class="hljs-comment">一份薯条*/</span><br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析"><a href="#4-优缺点分析" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：用户可以直接根据工厂类去创建所需的实例。</p><p>缺点：违背了单一原则、开放封闭原则。工厂类集中了所有实例的创建逻辑，如果一旦这个工厂出了问题，所有的客户端都会受到牵连；简单工厂模式的产品都基于一个共同的抽象类或者接口，即有不同的产品接口或者抽象类的时候，工厂类就需要判断何时创建何种产品，这就和创建何种种类产品的产品相互混淆；开放封闭原则中，每当我新增加一个产品的时候必须修改工厂类，相应的工厂类就需要重新编译一遍。</p><h1 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h1><h2 id="1-解释-1"><a href="#1-解释-1" class="headerlink" title="1.解释"></a>1.解释</h2><p>工厂方法模式属于类的创建型模式，又称为多态工厂模式。工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，仅负责声明具体工厂类必须实现的接口。</p><h2 id="2-包含的角色-1"><a href="#2-包含的角色-1" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象产品角色：具体产品的父类。</p><p>（2）具体产品角色：抽象产品的子类。</p><p>（3）抽象工厂角色：具体工厂的父类。</p><p>（4）具体工厂角色：抽象工厂的子类。</p><p>工厂和产品之间的关系是具体工厂中调用具体产品类，生成具体的产品。</p><h2 id="3-使用场景分析及代码实现-1"><a href="#3-使用场景分析及代码实现-1" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>————-工厂实例————-</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//抽象工厂角色</span><br>public interface <span class="hljs-type">Factory</span>&#123;<br>    <span class="hljs-comment">//生产产品</span><br>    public <span class="hljs-type">Product</span> manufacture();<br>&#125;<br><span class="hljs-comment">//抽象产品角色</span><br>public interface <span class="hljs-type">Product</span>&#123;<br>    <span class="hljs-comment">//产品的属性</span><br>    public void show();<br>&#125;<br><span class="hljs-comment">//具体产品角色</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span></span>&#123;<br><span class="hljs-meta">@Override</span><br>    public void show()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;生产出了产品A&quot;</span>);<br>    &#125;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void show()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;生产出了产品B&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体工厂角色</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">Product</span> manufacture()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ProductA</span>();<br>    &#125;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">Product</span> manufacture()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ProductB</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    public static void main(<span class="hljs-type">String</span>[] args)&#123;<br>        <span class="hljs-comment">//生产产品A</span><br>        <span class="hljs-type">FactoryA</span> mFactoryA = <span class="hljs-keyword">new</span> <span class="hljs-type">FactoryA</span>();<br>        mFactoryA.manufacture().show();<br>        <span class="hljs-comment">//生产产品B</span><br>        <span class="hljs-type">FactoryB</span> mFactoryB = <span class="hljs-keyword">new</span> <span class="hljs-type">FactoryB</span>();<br>        mFactoryB.manufacture().show();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*结果</span><br><span class="hljs-comment">生产出了产品A</span><br><span class="hljs-comment">生产出了产品B*/</span><br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-1"><a href="#4-优缺点分析-1" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>（1）符合开闭原则，新增一种产品的时候，只需要增加相应的具体产品类和相应的工厂子类即可。</p><p>（2）符合单一职责原则，每个具体工厂类只负责创建对应的产品。</p><p>（3）不使用静态工厂方法，可以形成基于继承的等级结构。</p><p>缺点：</p><p>（1）添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加。</p><p>（2）虽然保证了工厂方法内对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类。</p><p>（3）一个具体工厂只能创建一种具体产品。</p><h1 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h1><h2 id="1-解释-2"><a href="#1-解释-2" class="headerlink" title="1.解释"></a>1.解释</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式，是工厂方法模式的升级版，在有<strong>多个业务品种、业务分类</strong>时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p><h2 id="2-包含的角色-2"><a href="#2-包含的角色-2" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象工厂：声明生成抽象产品的工厂。</p><p>（2）具体工厂：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体的产品。</p><p>（3）抽象产品：在抽象产品中定义了产品的抽象业务方法。</p><p>（4）具体产品：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p><h2 id="3-使用场景分析及代码实现-2"><a href="#3-使用场景分析及代码实现-2" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>———————-游戏产品—————–</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-comment">//游戏界面</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">GameInterface</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interface</span>()</span>;<br>&#125;<br><span class="hljs-comment">//游戏操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">GameOperation</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-comment">//游戏界面具体工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AndroidInterface</span> <span class="hljs-title">implement</span> <span class="hljs-title">GameInterface</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interface</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Android游戏界面控制&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IOSInterface</span> <span class="hljs-title">implement</span> <span class="hljs-title">GameInterface</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interface</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;IOS游戏界面控制&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WindowInterface</span> <span class="hljs-title">implement</span> <span class="hljs-title">GameInterface</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interface</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Window游戏界面控制&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//游戏操作具体工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AndroidOperation</span> <span class="hljs-title">implement</span> <span class="hljs-title">GameOperation</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span>()</span>&#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Andriod游戏控制&quot;</span>);  <br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IOSOperation</span> <span class="hljs-title">implement</span> <span class="hljs-title">GameOperation</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;IOS游戏控制&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WindowOperation</span> <span class="hljs-title">implement</span> <span class="hljs-title">GameOperation</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Window游戏控制&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象工厂-游戏工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">GameFactory</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameInterface <span class="hljs-title">interfaceController</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameOperation <span class="hljs-title">operationController</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> AndroidController implement <span class="hljs-title">GameFactory</span>()</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameInterface <span class="hljs-title">interfaceController</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AndroidInterface();<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameOperation <span class="hljs-title">operationController</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AndroidOperation();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> IOSController implement <span class="hljs-title">GameFactory</span>()</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameInterface <span class="hljs-title">interfaceController</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IOSInterface();<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameOperation <span class="hljs-title">operationController</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IOSOperation();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> WindowController implement <span class="hljs-title">GameFactory</span>()</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameInterface <span class="hljs-title">interfaceController</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowInterface();<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GameOperation <span class="hljs-title">operationController</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WindowOperation();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        GameFactory andriodGame = <span class="hljs-keyword">new</span> AndriodController();<br>        GameInterface andriodInterface = andriodGame.interfaceController();<br>        GameOperation andriodOperation = andriodGame.operationController();<br>        andriodInterface.<span class="hljs-keyword">interface</span>();<br>        andriodOperation.operation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-2"><a href="#4-优缺点分析-2" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>(1)隔离了具体类的生成，使得客户并不需要知道什么被创建，具有良好的封装性。</p><p>(2)横向扩展简单。同个产品族如果需要增加多个产品，只需要增加新的工厂类和产品类即可。</p><p>缺点：</p><p>纵向扩展困难，如果增加了新的产品族，抽象工厂类也要添加创建该产品族的对应方法，这样一来所有的具体工厂类都要做修改了，严重违背了开闭原则。</p><h1 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h1><h2 id="1-解释-3"><a href="#1-解释-3" class="headerlink" title="1.解释"></a>1.解释</h2><p>建造者模式是指 指挥者 指挥 建造者 建造产品。不同的具体建造者定义了不同的创建过程，且具体的建造者相互独立，增加新的建造者非常方便，无须修改已有的代码，系统具有较好的扩展性。</p><h2 id="2-包含的角色-3"><a href="#2-包含的角色-3" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象建造者（Builder）：接口中包含一个要建造的产品，建造这个产品各个部分的方法。</p><p>（2）具体建造者（Concrete Builder）：它实现了抽象建造者接口，实现各个部件的具体构造和装备方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p><p>（3）产品角色（Product）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p><p>（4）指挥者（Director）：它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制）。</p><h2 id="3-使用场景分析及代码实现-3"><a href="#3-使用场景分析及代码实现-3" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>———–汽车建造过程————–</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//产品-小汽车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>   <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">showProduct</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;名称：&quot;</span>+name);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;型号：&quot;</span>+<span class="hljs-keyword">type</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setType</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象建造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Builder</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setPart</span>(<span class="hljs-title class_">String</span> arg1,<span class="hljs-title class_">String</span> arg2);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Product</span> <span class="hljs-title function_">getProduct</span>();<br>&#125;<br><span class="hljs-comment">//具体建造者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Builder</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Product</span> product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Product</span> <span class="hljs-title function_">getProduct</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setPart</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> arg1,<span class="hljs-title class_">String</span> arg2</span>)&#123;<br>        product.<span class="hljs-title function_">setName</span>(arg1);<br>        product.<span class="hljs-title function_">setType</span>(arg2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//指挥者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Builder</span> builder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Product</span> <span class="hljs-title function_">getAProduct</span>(<span class="hljs-params"></span>)&#123;<br>        builder.<span class="hljs-title function_">setPart</span>(<span class="hljs-string">&quot;宝马汽车&quot;</span>，<span class="hljs-string">&quot;X7&quot;</span>);<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-title function_">getProduct</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Product</span> <span class="hljs-title function_">getBProduct</span>(<span class="hljs-params"></span>)&#123;<br>        builder.<span class="hljs-title function_">setPart</span>(<span class="hljs-string">&quot;奥迪汽车&quot;</span>,<span class="hljs-string">&quot;Q5&quot;</span>);<br>        <span class="hljs-keyword">return</span> builder.<span class="hljs-title function_">getProduct</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span>&#123;<br>    <span class="hljs-title class_">Director</span> director = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>();<br>    <span class="hljs-title class_">Product</span> product1 = director.<span class="hljs-title function_">getAProduct</span>();<br>    product1.<span class="hljs-title function_">showProduct</span>();<br>    <span class="hljs-title class_">Product</span> product2 = director.<span class="hljs-title function_">getBProduct</span>();<br>    product2.<span class="hljs-title function_">showProduct</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-3"><a href="#4-优缺点分析-3" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>建造者的封装性很好，使用建造者模式可以有效的封装变化，所以，一般产品类和建造者类是比较稳定的。将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p><p>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码。</p><p>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p><p>缺点：</p><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造类来实现这种变化，导致系统变得很庞大，可维护性变差。</p><h1 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h1><h2 id="1-解释-4"><a href="#1-解释-4" class="headerlink" title="1.解释"></a>1.解释</h2><p>原型模式是一种对象创建型模式，建造者模式是一种对象创建型模式，用原型模式可以用原型实例指定创建原型的种类，它允许通过一个原型对象创建多个同类型的其他对象，而无需知道该对象的创建细节，在java中可以直接使用Object提供的clone方法来实现对象的克隆（浅克隆）。</p><h2 id="2-包含的角色-4"><a href="#2-包含的角色-4" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象原型类（Prototype）：给出所有的具体原型类所需的接口。</p><p>（2）具体原型类（Concrete Prototype）：被复制的对象，此角色需要实现抽象的原型角色所要求的接口。</p><h2 id="3-使用场景分析及代码实现-4"><a href="#3-使用场景分析及代码实现-4" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>——————汽车型号的批量生产———————</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//浅克隆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Brand</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">install</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;安装汽车品牌&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> Brand brand;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>()</span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = <span class="hljs-keyword">new</span> Brand();<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() throws CloneNotSupportedException</span>&#123;<br>        <span class="hljs-keyword">return</span> (Car)super.clone();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Brand <span class="hljs-title">getBrand</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.brand;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;小汽车能跑了&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//深克隆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Brand</span> <span class="hljs-title">implement</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">install</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;安装汽车品牌&quot;</span>);<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() throws CloneNotSupportedException</span>&#123;<br>    super.clone();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> Brand brand;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>()</span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = <span class="hljs-keyword">new</span> Brand();<br>    &#125;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() throws CloneNotSupportedException</span>&#123;<br>       Car car = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            car = (Car)super.clone();<br>            car.brand = (Brand)brand.clone();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            System.<span class="hljs-keyword">out</span>.println(e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> car;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Brand <span class="hljs-title">getBrand</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.brand;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;小汽车能跑了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-4"><a href="#4-优缺点分析-4" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：原型模式简化了创建对象的过程，通过一个已有的实例进行复制提高了创建实例的效率，具有较好的可扩展性。</p><p>缺点：部分时候实现克隆可能较为麻烦。</p><h1 id="六、单例模式"><a href="#六、单例模式" class="headerlink" title="六、单例模式"></a>六、单例模式</h1><h2 id="1-解释-5"><a href="#1-解释-5" class="headerlink" title="1.解释"></a>1.解释</h2><p>单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。</p><p>该模式有三个基本要点：一是这个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p><h2 id="2-分类及基本代码展示分析"><a href="#2-分类及基本代码展示分析" class="headerlink" title="2.分类及基本代码展示分析"></a>2.分类及基本代码展示分析</h2><p>1.饿汉式单例模式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span>&#123;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-keyword">static</span> HungrySingleton HUNGRY_SINGLETON = <span class="hljs-keyword">new</span> HungrySingleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungrySingleton</span>()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> HUNGRY_SINGLETON;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>饿汉式在类创建的同时就已经创建好了一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p><p>饿汉式模式适用于单例模式较少的场景；如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例模式简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，可以避免提前被加载到内存中，占用系统资源。</p><p>2.懒汉式单例模式（双重检查锁）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LazyDoubleCheckSingleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton =<span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//volatile关键字可以保证线程间变量的可见性，还有一个作用就是阻止局部重排序的发生。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyDoubleCheckSingleton</span>()</span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyDoubleCheckSingleton <span class="hljs-title">getInstance</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span>==lazyDoubleCheckSingleton)&#123;<br>            synchronized(LazyDoubleCheckSingleton.<span class="hljs-keyword">class</span>)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span>==lazyDoubleCheckSingleton)&#123;<br>                    lazyDoubleCheckSingleton = <span class="hljs-keyword">new</span> LazyDoubleCheckSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyDoubleCheckSingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于单锁而言，双重检查性能上虽然有提升，但是依旧用到了synchronized关键字总归要上锁，对程序性能还是存在一定的性能影响。注意里面volatile的使用。</p><h2 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h2><p>（1）饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</p><p>（2）懒汉式本身是非线程安全的，但是上述写法实现了线程安全；饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题。</p><p>（3）饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p><h1 id="七、适配器模式"><a href="#七、适配器模式" class="headerlink" title="七、适配器模式"></a>七、适配器模式</h1><h2 id="1-解释-6"><a href="#1-解释-6" class="headerlink" title="1.解释"></a>1.解释</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><h2 id="2-包含的角色-5"><a href="#2-包含的角色-5" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）目标接口（Target）：当前系统业务所期待的接口，他可以是抽象类或接口。</p><p>（2）适配者类（Adaptee）：它是被访问和适配的现存组件库中的组件接口。</p><p>（3）适配器类（Adapter）：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p><h2 id="3-使用场景分析及代码实现-5"><a href="#3-使用场景分析及代码实现-5" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//目标接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span>()</span>;<br>&#125;<br><span class="hljs-comment">//适配者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;适配者中的业务代码被调用！&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//类适配器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-title">implements</span> <span class="hljs-title">Target</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span>()</span>&#123;<br>        specificRequest();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdapterTest</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;类适配器模式测试：&quot;</span>);<br>        Target target = <span class="hljs-keyword">new</span> ClassAdapter();<br>        target.request();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*结果</span><br><span class="hljs-comment">类适配器模式测试：</span><br><span class="hljs-comment">适配器中的业务代码被调用！*/</span><br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-5"><a href="#4-优缺点分析-5" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>（1）客户端通过适配器可以透明的调用目标接口。</p><p>（2）复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</p><p>（3）将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</p><p>（4）在很多业务场景中符合开闭原则。</p><p>缺点：</p><p>（1）适配器编写过程中需要结合业务场景全面考虑，可能会增加系统的复杂性。</p><p>（2）增加代码阅读难度，降低代码可读性，过多的使用适配器会使系统代码变得凌乱。</p><h1 id="八、桥接模式"><a href="#八、桥接模式" class="headerlink" title="八、桥接模式"></a>八、桥接模式</h1><h2 id="1-解释-7"><a href="#1-解释-7" class="headerlink" title="1.解释"></a>1.解释</h2><p>桥接模式（Bridge Pattern）：<strong>将抽象部分和他的实现部分分离，使它们都可以独立的变化</strong>。它是一种<strong>对象结构型模式</strong>，又称为柄体（Handle and Boy）模式或者接口（Interface）模式。如果某个类存在两个独立变化的维度，可以运用桥接模式将这两个维度分离出来，让系统更加符合”单一职责原则”。<strong>桥接模式中是在抽象类里面建立一个抽象关联</strong>，该关联关系就像是一条桥一样，将两个独立继承结构的类联结起来。</p><h2 id="2-包含的角色-6"><a href="#2-包含的角色-6" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象类（Abstraction）：用于定义抽象类的接口，它一般是抽象类而不是接口。它既可以包含抽象业务方法，也可以包含具体业务方法。</p><p>（2）扩充抽象类（Refined Abstraction）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法。</p><p>（3）实现类接口（Implementor）：Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。</p><p>（4）具体实现类（Concrete Implementor）：具体实现Implementor接口，在不同的Concrete Implementor中提供基本操作的不同实现。</p><h2 id="3-使用场景分析及代码实现-6"><a href="#3-使用场景分析及代码实现-6" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>———————–不同交通工具在不同的道路行驶—————-</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//交通工具(Implementor)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//具体的交通工具(ConcreteImplementor)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span><br>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.print(<span class="hljs-string">&quot;小轿车&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span><br>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.print(<span class="hljs-string">&quot;大巴&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象的路（Abstraction）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Road</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Vehicle vehicle;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Road</span><span class="hljs-params">(Vehicle vehicle)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.vehicle = vehicle;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">driveOnRoad</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//具体的路（Concrete Implementor）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnpavedRoad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Road</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnpavedRoad</span><span class="hljs-params">(Vehicle vehicle)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(vehicle);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">driveOnRoad</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>.vehicle.drive();<br>        System.out.println(<span class="hljs-string">&quot;行驶在石子路&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CementRoad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Road</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CementRoad</span><span class="hljs-params">(Vehicle vehicle)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(vehicle);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">driveOnRoad</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>.vehicle.drive();<br>        System.out.println(<span class="hljs-string">&quot;行驶在水泥路&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br>        <span class="hljs-type">Road</span> <span class="hljs-variable">road</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CementRoad</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>());<br>        road.driveOnRoad();<br><span class="hljs-comment">/*结果</span><br><span class="hljs-comment">小轿车行驶在水泥路*/</span><br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-6"><a href="#4-优缺点分析-6" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>（1）分离抽象接口及其实现部分。桥接模式使用”对象间的关联关系”解耦了抽象和实现类之间固有的绑定关系，使得抽象和实现不再同一个继承层次结构中，使他们都具有自己的子类。</p><p>（2）在很多情况下，桥接模式可以取代多层继承方案，它极大减少了子类的个数。</p><p>（3）桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合”开闭原则”。</p><p>缺点：</p><p>（1）桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要去开发者一开始就针对抽象层进行设计与编程。</p><p>（2）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</p><h1 id="九、组合模式"><a href="#九、组合模式" class="headerlink" title="九、组合模式"></a>九、组合模式</h1><h2 id="1-解释-8"><a href="#1-解释-8" class="headerlink" title="1.解释"></a>1.解释</h2><p>组合模式对单个对象（叶子对象）和组合对象（组合对象）具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。组合对象最关键的一点就是叶子对象和组合对象实现相同的接口。</p><h2 id="2-包含的角色-7"><a href="#2-包含的角色-7" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）对象声明接口（Component）：声明一个接口用于访问和管理Component子部件。</p><p>（2）叶子对象（Leaf）：叶子对象，叶子结点没有子结点。</p><p>（3）容器对象（Composite）：容器对象，定义有枝节点行为，用来存储子部件。</p><h2 id="3-使用场景分析及代码实现-7"><a href="#3-使用场景分析及代码实现-7" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//对象声明接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">File</span> &#123;<br>    String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">File</span>(<span class="hljs-params">String name</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(<span class="hljs-params">String name</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span>;<br>&#125;<br><span class="hljs-comment">//容器对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Folder</span> <span class="hljs-title">extends</span> <span class="hljs-title">File</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;File&gt; files;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Folder</span>(<span class="hljs-params">String name</span>)</span>&#123;<br>        super(name);<br>        files = <span class="hljs-keyword">new</span> ArrayList&lt;File&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 浏览文件夹中的文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>        <span class="hljs-keyword">for</span>(File <span class="hljs-keyword">file</span> : files)&#123;<br>            <span class="hljs-keyword">file</span>.display();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @desc 向文件夹中添加文件</span><br><span class="hljs-comment">     * @param file</span><br><span class="hljs-comment">     * @return void</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">File <span class="hljs-keyword">file</span></span>)</span>&#123;<br>        files.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">file</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @desc 从文件夹中删除文件</span><br><span class="hljs-comment">     * @param file</span><br><span class="hljs-comment">     * @return void</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>(<span class="hljs-params">File <span class="hljs-keyword">file</span></span>)</span>&#123;<br>        files.<span class="hljs-keyword">remove</span>(<span class="hljs-keyword">file</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//叶子对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextFile</span> <span class="hljs-title">extends</span> <span class="hljs-title">File</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextFile</span>(<span class="hljs-params">String name</span>)</span> &#123;<br>        super(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;这是文本文件，文件名：&quot;</span> + super.getName());<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ImagerFile</span> <span class="hljs-title">extends</span> <span class="hljs-title">File</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImagerFile</span>(<span class="hljs-params">String name</span>)</span> &#123;<br>        super(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;这是图像文件，文件名：&quot;</span> + super.getName());<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VideoFile</span> <span class="hljs-title">extends</span> <span class="hljs-title">File</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VideoFile</span>(<span class="hljs-params">String name</span>)</span> &#123;<br>        super(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;这是影像文件，文件名：&quot;</span> + super.getName());<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//客户端测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 我们先建立一个这样的文件系统</span><br><span class="hljs-comment">         *                  总文件</span><br><span class="hljs-comment">         *                  </span><br><span class="hljs-comment">         *   a.txt    b.jpg                   c文件夹              </span><br><span class="hljs-comment">         *                      c_1.text  c_1.rmvb    c_1.jpg   </span><br><span class="hljs-comment">         *                                                       </span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-comment">//总文件夹</span><br>        Folder zwjj = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;总文件夹&quot;</span>);<br>        <span class="hljs-comment">//向总文件夹中放入三个文件：1.txt、2.jpg、1文件夹</span><br>        TextFile aText= <span class="hljs-keyword">new</span> TextFile(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        ImagerFile bImager = <span class="hljs-keyword">new</span> ImagerFile(<span class="hljs-string">&quot;b.jpg&quot;</span>);<br>        Folder cFolder = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;C文件夹&quot;</span>);<br>        <br>        zwjj.<span class="hljs-keyword">add</span>(aText);<br>        zwjj.<span class="hljs-keyword">add</span>(bImager);<br>        zwjj.<span class="hljs-keyword">add</span>(cFolder);<br>        <br>        <span class="hljs-comment">//向C文件夹中添加文件：c_1.txt、c_1.rmvb、c_1.jpg </span><br>        TextFile cText = <span class="hljs-keyword">new</span> TextFile(<span class="hljs-string">&quot;c_1.txt&quot;</span>);<br>        ImagerFile cImage = <span class="hljs-keyword">new</span> ImagerFile(<span class="hljs-string">&quot;c_1.jpg&quot;</span>);<br>        VideoFile cVideo = <span class="hljs-keyword">new</span> VideoFile(<span class="hljs-string">&quot;c_1.rmvb&quot;</span>);<br>        <br>        cFolder.<span class="hljs-keyword">add</span>(cText);<br>        cFolder.<span class="hljs-keyword">add</span>(cImage);<br>        cFolder.<span class="hljs-keyword">add</span>(cVideo);<br>        <br>        <span class="hljs-comment">//遍历C文件夹</span><br>        cFolder.display();<br>        <span class="hljs-comment">//将c_1.txt删除</span><br>        cFolder.<span class="hljs-keyword">remove</span>(cText);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br>        cFolder.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-7"><a href="#4-优缺点分析-7" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>（1）可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</p><p>（2）客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</p><p>（3）定义了包含叶子对象和容器对象的类层次结构，叶子对象不断递归下去，可以形成复杂的树形结构。</p><p>（4）更容易在组合体中加入对象构件，客户端不必因为加入了新的对象构件而改变原有的代码。</p><p>缺点：</p><p>（1）使设计变的更抽象，对象的业务规则如果很复杂，则实现组合模式具有很大的挑战性，而且不是所有办法都与叶子对象子类都有关联。</p><h1 id="十、装饰者模式"><a href="#十、装饰者模式" class="headerlink" title="十、装饰者模式"></a>十、装饰者模式</h1><h2 id="1-解释-9"><a href="#1-解释-9" class="headerlink" title="1.解释"></a>1.解释</h2><p>装饰者模式又名包装（Wrapper）模式。装饰者以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p><p>大多数的装饰者模式实际上是半透明的装饰模式，这样的装饰模式也称作半装饰、半适配器模式。</p><h2 id="2-包含的角色-8"><a href="#2-包含的角色-8" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象构件角色（Component）：给出一个抽象接口，以规范准备接受附加责任的对象。</p><p>（2）具体构件角色（ConcreteComponent）：定义一个将要接收附加责任的类。</p><p>（3）装饰角色（Decorator）：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。</p><p>（4）具体装饰角色（ConcreteDecorator）：负责给构件对象”贴上”附加的责任。</p><h2 id="3-使用场景分析及代码实现-8"><a href="#3-使用场景分析及代码实现-8" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//抽象界面构件类：抽象构件类，为了突出与模式相关的核心代码，对原有控件代码进行了大量的简化</span><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span><br><br>&#123;<br><br>       public  <span class="hljs-keyword">abstract</span> void display();<br><br>&#125;<br><br> <br><br><span class="hljs-comment">//窗体类：具体构件类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span><br><br>&#123;<br><br>       public  void display()<br><br>       &#123;<br><br>              <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;显示窗体！&quot;</span>);<br><br>       &#125;<br><br>&#125;<br><br> <br><br><span class="hljs-comment">//文本框类：具体构件类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span><br><br>&#123;<br><br>       public  void display()<br><br>       &#123;<br><br>              <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;显示文本框！&quot;</span>);<br><br>       &#125;<br><br>&#125;<br><br> <br><br><span class="hljs-comment">//列表框类：具体构件类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span><br><br>&#123;<br><br>       public  void display()<br><br>       &#123;<br><br>              <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;显示列表框！&quot;</span>);<br><br>       &#125;<br><br>&#125;<br><br> <br><br><span class="hljs-comment">//构件装饰类：抽象装饰类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span><br><br>&#123;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-type">Component</span> component;  <span class="hljs-comment">//维持对抽象构件类型对象的引用</span><br><br> <br><br>       public <span class="hljs-type">ComponentDecorator</span>(<span class="hljs-type">Component</span>  component)  <span class="hljs-comment">//注入抽象构件类型的对象</span><br><br>       &#123;<br><br>              <span class="hljs-keyword">this</span>.component = component;<br><br>       &#125;<br><br> <br><br>       public void display()<br><br>       &#123;<br><br>              component.display();<br><br>       &#125;<br><br>&#125;<br><br> <br><br><span class="hljs-comment">//滚动条装饰类：具体装饰类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollBarDecorator</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">ComponentDecorator</span></span><br><br>&#123;<br><br>       public <span class="hljs-type">ScrollBarDecorator</span>(<span class="hljs-type">Component</span>  component)<br><br>       &#123;<br><br>              <span class="hljs-keyword">super</span>(component);<br><br>       &#125;<br><br> <br><br>       public void display()<br><br>       &#123;<br><br>              <span class="hljs-keyword">this</span>.setScrollBar();<br><br>              <span class="hljs-keyword">super</span>.display();<br><br>       &#125;<br><br> <br><br>       public  void setScrollBar()<br><br>       &#123;<br><br>              <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;为构件增加滚动条！&quot;</span>);<br><br>       &#125;<br><br>&#125;<br><br> <br><br><span class="hljs-comment">//黑色边框装饰类：具体装饰类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlackBorderDecorator</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">ComponentDecorator</span></span><br><br>&#123;<br><br>       public <span class="hljs-type">BlackBorderDecorator</span>(<span class="hljs-type">Component</span>  component)<br><br>       &#123;<br><br>              <span class="hljs-keyword">super</span>(component);<br><br>       &#125;<br><br> <br><br>       public void display()<br><br>       &#123;<br><br>              <span class="hljs-keyword">this</span>.setBlackBorder();<br><br>              <span class="hljs-keyword">super</span>.display();<br><br>       &#125;<br><br> <br><br>       public  void setBlackBorder()<br><br>       &#123;<br><br>              <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;为构件增加黑色边框！&quot;</span>);<br><br>       &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span><br><br>&#123;<br><br>       public  static void main(<span class="hljs-type">String</span> args[])<br><br>       &#123;<br><br>              <span class="hljs-type">Component</span> component,componentSB;  <span class="hljs-comment">//使用抽象构件定义</span><br><br>              component = <span class="hljs-keyword">new</span> <span class="hljs-type">Window</span>(); <span class="hljs-comment">//定义具体构件</span><br><br>              componentSB = <span class="hljs-keyword">new</span>  <span class="hljs-type">ScrollBarDecorator</span>(component); <span class="hljs-comment">//定义装饰后的构件</span><br><br>              componentSB.display();<br><br>       &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-8"><a href="#4-优缺点分析-8" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除 掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>缺点：</p><p>使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p><h1 id="十一、外观模式"><a href="#十一、外观模式" class="headerlink" title="十一、外观模式"></a>十一、外观模式</h1><h2 id="1-解释-10"><a href="#1-解释-10" class="headerlink" title="1.解释"></a>1.解释</h2><p>外观模式（Facade Pattern）也称为过程模式，是结构性模式。外观模式为子系统的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式可以理解为 为转换一群接口，客户只要调用这一个接口而不用调用多个接口才能达到目的，也不需要关心这个子系统的内部细节。就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。</p><h2 id="2-包含的角色-9"><a href="#2-包含的角色-9" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>Facade外观类：提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给相应的子系统对象。</p><p>System子系统：处理Facade对象指派的任务，是功能的实际提供者。</p><p>Client客户端：外观接口调用测试者。</p><h2 id="3-使用场景分析及代码实现-9"><a href="#3-使用场景分析及代码实现-9" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//各子系统</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> &#123; <span class="hljs-comment">//播放器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Player instance = <span class="hljs-keyword">new</span> Player();<span class="hljs-comment">//使用单例模式(饿汉式)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Player <span class="hljs-title">getInstanc</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 播放器打开了 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 播放器关闭了 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 播放器播放中 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 播放暂停 &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123; <span class="hljs-comment">//屏幕</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Screen instance = <span class="hljs-keyword">new</span> Screen();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Screen <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">up</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 屏幕上升 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 屏幕下降 &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stereo</span> &#123; <span class="hljs-comment">//音响</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Stereo instance = <span class="hljs-keyword">new</span> Stereo();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stereo <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 音响打开了 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 音响关闭了 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVolume</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 音响音量调节 &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Projector</span> &#123; <span class="hljs-comment">//投影仪</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Projector instance = <span class="hljs-keyword">new</span> Projector();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Projector <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 投影仪打开了 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 投影仪关闭了 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">focus</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 投影仪聚焦 &quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zoom</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; 投影仪放大 &quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//外观类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HomeTheaterFacade</span> &#123; <span class="hljs-comment">//外观类</span><br>    <span class="hljs-comment">//定义各个子系统对象</span><br>    <span class="hljs-keyword">private</span> Player player;<br>    <span class="hljs-keyword">private</span> Screen screen;<br>    <span class="hljs-keyword">private</span> Stereo stereo;<br>    <span class="hljs-keyword">private</span> Projector projector;<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HomeTheaterFacade</span>()</span> &#123;<br>        <span class="hljs-keyword">this</span>.player = Player.getInstance();<br>        <span class="hljs-keyword">this</span>.screen = Screen.getInstance();<br>        <span class="hljs-keyword">this</span>.stereo = Stereo.getInstance();<br>        <span class="hljs-keyword">this</span>.projector = Projector.getInstance();<br><br>    &#125;<br><br>    <span class="hljs-comment">//一致界面</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ready</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;===ready===&quot;</span>);<br>        screen.down();<br>        player.<span class="hljs-keyword">on</span>();<br>        stereo.<span class="hljs-keyword">on</span>();<br>        stereo.setVolume();<br>        projector.<span class="hljs-keyword">on</span>();<br>        projector.zoom();<br>        projector.focus();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;===play===&quot;</span>);<br>        player.play();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;===pause===&quot;</span>);<br>        player.pause();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">end</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;===end===&quot;</span>);<br>        screen.up();<br>        projector.off();<br>        stereo.off();<br>        player.off();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        HomeTheaterFacade homeTheaterFacade = <span class="hljs-keyword">new</span> HomeTheaterFacade();<br>        homeTheaterFacade.ready();<br>        homeTheaterFacade.play();<br>        homeTheaterFacade.pause();<br>        homeTheaterFacade.end();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-9"><a href="#4-优缺点分析-9" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展。</p><p>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性。</p><p>当系统需要进行分层设计的时候，可以考虑外观模式帮助我们更好的划分访问的层次。</p><p>不需要过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要让系统有层次，利于维护为目的。</p><p>在维护一个遗留的大型系统的时候，可能这个系统已经变的非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性。</p><p>优点：</p><p>1）松耦合，用户和子系统解耦，屏蔽子系统；可以提高子系统的独立性。</p><p>2）使用简单，简化了用户与子系统的依赖关系，用户只与门面对接，有统一的入口；不需要知道所有子系统及内部构造。</p><p>缺点：</p><p>1）不规范的编程方式，没有面向抽象编程，而是通过增加中介层，转换服务提供方的服务接口。</p><p>最核心的目的：简化子系统，简化客户使用，屏蔽多个子系统。</p><h1 id="十二、轻量级模式"><a href="#十二、轻量级模式" class="headerlink" title="十二、轻量级模式"></a>十二、轻量级模式</h1><h2 id="1-解释-11"><a href="#1-解释-11" class="headerlink" title="1.解释"></a>1.解释</h2><p>轻量级模式又叫做享元模式，是对象池的一种标签。类似线程池，线程池可以避免不停地创建和销毁对象，消耗性能。享元模式可以减少对象的数量，其宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，属于结构型设计模式。</p><h2 id="2-包含的角色-10"><a href="#2-包含的角色-10" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>抽象享元角色（IFlyweight）：享元对象抽象基类或接口，同时定义出对象的外部状态和内部状态的接口实现。</p><p>具体享元模式（ConcreteFlyWeight）：实现了抽象角色定义的业务。该角色的内部状态处理应该与环境无关，不会出现一个操作改变内部状态，同时修改了外部状态的情况。</p><p>享元工厂（FlyweightFactory）：负责管理享元对象池和创建享元对象。</p><h2 id="3-使用场景分析及代码实现-10"><a href="#3-使用场景分析及代码实现-10" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象享元角色</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFlyweight</span> &#123;<br><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">operation</span>(<span class="hljs-title class_">String</span> extrinsicState);<br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 具体享元角色</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFlyweight</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> intrinsicState;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ConcreteFlyweight</span>(<span class="hljs-title class_">String</span> intrinsicState) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">intrinsicState</span> = intrinsicState;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">operation</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> extrinsicState</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;object address: &quot;</span> + <span class="hljs-title class_">System</span>.<span class="hljs-title function_">identityHashCode</span>(<span class="hljs-variable language_">this</span>));<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;extrinsicState: &quot;</span> + extrinsicState);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;intrinsicState: &quot;</span> + intrinsicState);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 享元工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">IFlyweight</span>&gt; pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">IFlyweight</span> <span class="hljs-title function_">getFlyweight</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> intrinsicState</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!pool.<span class="hljs-title function_">containsKey</span>(intrinsicState)) &#123;<br>            <span class="hljs-title class_">IFlyweight</span> flyweight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>(intrinsicState);<br>            pool.<span class="hljs-title function_">put</span>(intrinsicState, flyweight);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool.<span class="hljs-title function_">get</span>(intrinsicState);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">IFlyweight</span> flyweight1 = <span class="hljs-title class_">FlyweightFactory</span>.<span class="hljs-title function_">getFlyweight</span>(<span class="hljs-string">&quot;aa&quot;</span>);<br>        <span class="hljs-title class_">IFlyweight</span> flyweight2 = <span class="hljs-title class_">FlyweightFactory</span>.<span class="hljs-title function_">getFlyweight</span>(<span class="hljs-string">&quot;aa&quot;</span>);<br>        <span class="hljs-title class_">IFlyweight</span> flyweight3 = <span class="hljs-title class_">FlyweightFactory</span>.<span class="hljs-title function_">getFlyweight</span>(<span class="hljs-string">&quot;cc&quot;</span>);<br>        flyweight1.<span class="hljs-title function_">operation</span>(<span class="hljs-string">&quot;wwwww&quot;</span>);<br>        flyweight2.<span class="hljs-title function_">operation</span>(<span class="hljs-string">&quot;ttttt&quot;</span>);<br>        flyweight3.<span class="hljs-title function_">operation</span>(<span class="hljs-string">&quot;wwwww&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-10"><a href="#4-优缺点分析-10" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：减少对象的创建，降低内存中对象的数量，降低系统内存，提高系统性能。</p><p>缺点：</p><p>1）需要关注内、外部状态，关注线程安全问题（同时访问相同的缓存）</p><p>2）系统程序负责化了</p><h1 id="十三、代理模式"><a href="#十三、代理模式" class="headerlink" title="十三、代理模式"></a>十三、代理模式</h1><h2 id="1-解释-12"><a href="#1-解释-12" class="headerlink" title="1.解释"></a>1.解释</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><h2 id="2-包含的角色-11"><a href="#2-包含的角色-11" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1）抽象主题角色（Subject）：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。</p><p>2）具体主题对象（RealSubject）：也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。</p><p>3）代理主题角色（Proxy）：也叫委托类、代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。</p><h2 id="3-使用场景分析及代码实现-11"><a href="#3-使用场景分析及代码实现-11" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//抽象主题角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">operate</span>();<br>&#125;<br><span class="hljs-comment">//具体主题角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;RealSubject&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Subject</span> subject = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(subject == <span class="hljs-literal">null</span>)<br>            subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;I&#x27;m Proxy, I&#x27;m invoking...&quot;</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subject</span>.<span class="hljs-title function_">operate</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//测试代码</span><br>        <span class="hljs-title class_">Subject</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>();<br>        subject.<span class="hljs-title function_">operate</span>();<br><span class="hljs-comment">//动态代理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate1</span>();<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate2</span>();<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate3</span>();<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate4</span>();<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate5</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate1</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject-operate1()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate2</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject-operate2()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate3</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject-operate3()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate4</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject-operate4()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate5</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject-operate5()&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate1</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject2-operate1()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate2</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject2-operate2()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate3</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject2-operate3()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate4</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject2-operate4()&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operate5</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RealSubject2-operate5()&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span><br>&#123;<br>    <span class="hljs-title class_">Object</span> obj = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">newProxyInstance</span>(<span class="hljs-params"><span class="hljs-title class_">Object</span> realObj</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = realObj;<br>        <span class="hljs-title class_">Class</span>&lt;?&gt; classType = <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>.<span class="hljs-title function_">getClass</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">newProxyInstance</span>(classType.<span class="hljs-title function_">getClassLoader</span>(), classType.<span class="hljs-title function_">getInterfaces</span>(), <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">Object</span> proxy, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args) throws <span class="hljs-title class_">Throwable</span><br>    &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;I&#x27;m Proxy, I&#x27;m invoking...&quot;</span>);<br>        <span class="hljs-title class_">Object</span> <span class="hljs-built_in">object</span> = method.<span class="hljs-title function_">invoke</span>(obj, args);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-built_in">object</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>;<br>    &#125;<br>&#125;<br>        <span class="hljs-title class_">Subject</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        <span class="hljs-title class_">Subject</span> subject = (<span class="hljs-title class_">Subject</span>) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyHandler</span>().<span class="hljs-title function_">newProxyInstance</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>());<br>        <span class="hljs-title class_">Subject</span> subject2 = (<span class="hljs-title class_">Subject</span>) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyHandler</span>().<span class="hljs-title function_">newProxyInstance</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject2</span>());<br>        subject.<span class="hljs-title function_">operate2</span>();<br>        subject2.<span class="hljs-title function_">operate4</span>();<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-11"><a href="#4-优缺点分析-11" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1）代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</p><p>2）代理对象可以扩展目标对象的功能</p><p>3）代理模式能将客户端与目标对象进行分离，在一定程度上降低了系统的耦合度。</p><p>缺点：<br>在客户端和目标对象之间增加了一个代理对象，会造成请求处理速度变慢</p><p>增加了系统的复杂度</p><h1 id="十四、责任链模式（职责链模式）"><a href="#十四、责任链模式（职责链模式）" class="headerlink" title="十四、责任链模式（职责链模式）"></a>十四、责任链模式（职责链模式）</h1><h2 id="1-解释-13"><a href="#1-解释-13" class="headerlink" title="1.解释"></a>1.解释</h2><p>在现实生活中，一个事件需要经过多个处理对象处理是常见的场景，例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部分负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。</p><p>在计算机软硬件中也有相关的例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否能处理该异常；还有Struts2的拦截器、JSP和Servlet的Filter等，所有这些，都可以考虑使用责任链模式来实现。</p><p>定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有的请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><h2 id="2-包含的角色-12"><a href="#2-包含的角色-12" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p><p>2.具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p><p>3.客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p><p>责任链模式的本质是<strong>解耦请求与处理</strong>，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p><h2 id="3-使用场景及代码实现"><a href="#3-使用场景及代码实现" class="headerlink" title="3.使用场景及代码实现"></a>3.使用场景及代码实现</h2><p>责任链模式的实现代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象处理者角色</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span>&#123;<br>    <span class="hljs-keyword">private</span> Handler next;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span>(<span class="hljs-params">Handler next</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>    <span class="hljs-comment">//处理请求的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">String request</span>)</span>;<br>&#125;<br><span class="hljs-comment">//具体处理者角色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler1</span> <span class="hljs-title">extends</span> <span class="hljs-title">Handler</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">String request</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(request.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;one&quot;</span>))&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体处理者1负责处理该请求！&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(getNext() != <span class="hljs-literal">null</span>)&#123;<br>                    getNext().handleRequest(request);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;没有人处理该请求！&quot;</span>)<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler2</span> <span class="hljs-title">extends</span> <span class="hljs-title">Handler</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">String request</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(request.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;two&quot;</span>))&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体处理者2负责处理该请求！&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(getNext() != <span class="hljs-literal">null</span>)&#123;<br>                    getNext().handleRequest(request);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;没有人处理该请求！&quot;</span>)<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibilityPattern</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        <span class="hljs-comment">//组装责任链</span><br>        Handler handler1 = <span class="hljs-keyword">new</span> ConcreteHandler1();<br>        Handler handler2 = <span class="hljs-keyword">new</span> ConcreteHandler2();<br>        handler1.setNext(handler2);<br>        <span class="hljs-comment">//提交请求</span><br>        handler1.handleRequest(<span class="hljs-string">&quot;two&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果如下</span><br>具体处理者<span class="hljs-number">2</span>负责处理该请求<br></code></pre></td></tr></table></figure><p>在上面代码中，我们把消息硬编码为String类型，而在真实业务中，消息是具备多样性的，可以是int、String或者自定义类型。因此，在上面代码的基础上，可以对消息类型进行抽象request，增强了消息的兼容性。</p><p>应用实例：</p><p>假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//学生请假条审批</span><br><span class="hljs-comment">//抽象处理者：领导类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leader</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Leader</span> next;<br>    public void setNext(<span class="hljs-type">Leader</span> next)&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br>    public <span class="hljs-type">Leader</span> getNext()&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>    <span class="hljs-comment">//处理请求的方法</span><br>    public <span class="hljs-keyword">abstract</span> void handleRequest(int <span class="hljs-type">LeaveDays</span>);<br>&#125;<br><span class="hljs-comment">//具体处理者1：班主任类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdviser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Leader</span></span>&#123;<br>    public void handleRequest(int <span class="hljs-type">LeaveDays</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">LeaveDays</span> &lt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;班主任批准你请假&quot;</span>+<span class="hljs-type">LeaveDays</span>+<span class="hljs-string">&quot;天。&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(getNext() != <span class="hljs-literal">null</span>)&#123;<br>                getNext().handleRequest(<span class="hljs-type">LeaveDays</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;请假天数太多，没有人批准该假条！&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体处理类2：系主任类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentHead</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Leader</span></span>&#123;<br>    public void handleRequest(int <span class="hljs-type">LeaveDays</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">LeaveDays</span> &lt;= <span class="hljs-number">7</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;系主任批准你请假&quot;</span>+<span class="hljs-type">LeaveDays</span>+<span class="hljs-string">&quot;天。&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(getNext()!=<span class="hljs-literal">null</span>)&#123;<br>                getNext().handleRequest(<span class="hljs-type">LeaveDays</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;请假天数太多，没有人批准该假条！&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体处理者类3：院长类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Leader</span></span>&#123;<br>    public void handleRequest(int <span class="hljs-type">LeaveDays</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">LeaveDays</span> &lt;= <span class="hljs-number">10</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;院长批准你请假&quot;</span>+<span class="hljs-type">LeaveDays</span>+<span class="hljs-string">&quot;天。&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(getNext() != <span class="hljs-literal">null</span>)&#123;<br>                getNext().handleRequest(<span class="hljs-type">LeaveDays</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体处理类4：教务处长类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeanOfStudies</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Leader</span></span>&#123;<br>    public void handleRequest(int <span class="hljs-type">LeaveDays</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">LeaveDays</span> &lt;= <span class="hljs-number">20</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;教务处长批注你请假&quot;</span>+<span class="hljs-type">LeaveDays</span>+<span class="hljs-string">&quot;天。&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(getNext() != <span class="hljs-literal">null</span>)&#123;<br>                getNext().handleRequest(<span class="hljs-type">LeaveDays</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;请假天数太多，没有人批准该假条！&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-12"><a href="#4-优缺点分析-12" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p><p>应用场景：</p><p>1、多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。</p><p>2、可动态指定一组对象处理请求，或添加新的处理者。</p><p>3、需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</p><p>优点：</p><p>1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</p><p>2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</p><p>3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态的改变链内的成员或者调用它们的次序，也可动态的新增或者删除责任。</p><p>4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if或者if…else语句。</p><p>5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p><p>缺点：<br>1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</p><p>2.对于较长的责任链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</p><p>3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p><h1 id="十五、命令模式"><a href="#十五、命令模式" class="headerlink" title="十五、命令模式"></a>十五、命令模式</h1><h2 id="1-解释-14"><a href="#1-解释-14" class="headerlink" title="1.解释"></a>1.解释</h2><p>在软件开发系统中，”方法的请求者”和”方法的实现者”之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行”撤销、重做、记录”等处理都很不方便，因此，如何将方法的请求者与实现者解耦？</p><p>在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。</p><p>定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p><h2 id="2-包含的角色-13"><a href="#2-包含的角色-13" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法execute()。</p><p>2.具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</p><p>3.实现者&#x2F;接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</p><p>4.调用者&#x2F;请求者（Invoker）角色：是请求的发送者，他通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</p><h2 id="3-使用场景及代码实现-1"><a href="#3-使用场景及代码实现-1" class="headerlink" title="3.使用场景及代码实现"></a>3.使用场景及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//调用者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span>&#123;<br>    <span class="hljs-keyword">private</span> Command command;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span>(<span class="hljs-params">Command command</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span>(<span class="hljs-params">Command command</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;调用者执行命令command...&quot;</span>);<br>        command.execute();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象命令</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体命令</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> <span class="hljs-title">implement</span> <span class="hljs-title">Command</span>&#123;<br>    <span class="hljs-keyword">private</span> Receiver receiver;<br>    ConcreteCommand()&#123;<br>        receiver = <span class="hljs-keyword">new</span> Receiver();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>()</span>&#123;<br>        receiver.action();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//接收者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;接收者的action()方法被调用...&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommandPattern</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        Command cmd = <span class="hljs-keyword">new</span> ConcreteCommand();<br>        Invoker ir = <span class="hljs-keyword">new</span> Invoker(cmd);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;客户访问调用者的call()方法...&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果</span><br>客户访问调用者的call()方法...<br>调用者执行命令command...<br>接收者的action()方法被调用...<br></code></pre></td></tr></table></figure><p>应用实例：</p><p>命令模式实现客户去餐馆吃早餐</p><p>分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//调用者：服务员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Waiter</span>&#123;<br>    <span class="hljs-keyword">private</span> Breakfast changFen,hunTun,heFen;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChangFen</span>(<span class="hljs-params">Breakfast f</span>)</span>&#123;<br>        changFen = f;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHunTun</span>(<span class="hljs-params">Breakfast f</span>)</span>&#123;<br>        hunTun = f;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeFen</span>(<span class="hljs-params">Breakfast f</span>)</span>&#123;<br>        heFen = f;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chooseHunTun</span>()</span>&#123;<br>        hunTun.cooking();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chooseChangFen</span>()</span>&#123;<br>        changFen.cooking();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chooseHeFen</span>()</span>&#123;<br>        heFen.cooking();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象命令：早餐</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Breakfast</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体命令：肠粉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ChangFen</span> <span class="hljs-title">implements</span> <span class="hljs-title">Breakfast</span>&#123;<br>    <span class="hljs-keyword">private</span> ChangFenChef receiver;<br>    ChangFen()&#123;<br>        receiver = <span class="hljs-keyword">new</span> ChangFenChef();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>&#123;<br>        receiver.cooking();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体命令：馄饨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">HunTun</span> <span class="hljs-title">implements</span> <span class="hljs-title">Breakfast</span>&#123;<br>    <span class="hljs-keyword">private</span> HunTunChef receiver;<br>    HunTun()&#123;<br>        receiver = <span class="hljs-keyword">new</span> HunTunChef();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>&#123;<br>        receiver.cooking();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体命令：河粉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">HeFen</span> <span class="hljs-title">implements</span> <span class="hljs-title">Breakfast</span>&#123;<br>    <span class="hljs-keyword">private</span> HeFenChef receiver;<br>    HeFen()&#123;<br>        receiver = <span class="hljs-keyword">new</span> HeFenChef();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>&#123;<br>        receiver.cooking();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//接收者：肠粉厨师</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ChangFenChef</span>&#123;<br>    ChangFenChef()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;肠粉厨师&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>&#123;<br>         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;在做肠粉...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//接收者：馄饨厨师</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">HunTunChef</span>&#123;<br>    HunTunChef()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;馄饨厨师&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>&#123;<br>         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;在做馄饨...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//接收者：河粉厨师</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">HeFenChef</span>&#123;<br>    HeFenChef()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;河粉厨师&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cooking</span>()</span>&#123;<br>         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;在做河粉...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CookingCommand</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        Breakfast food1 = <span class="hljs-keyword">new</span> ChangFen();<br>        Breakfast food2 = <span class="hljs-keyword">new</span> HunTun();<br>        Breakfast food3 = <span class="hljs-keyword">new</span> HeFen();<br>        Waiter waiter = <span class="hljs-keyword">new</span> Waiter();<br>        waiter.setChangFen(food1);<span class="hljs-comment">//设置肠粉菜单</span><br>        waiter.setHunTun(food2);<span class="hljs-comment">//设置馄饨菜单</span><br>        waiter.setHeFen(food3);<span class="hljs-comment">//设置河粉菜单</span><br>        waiter.chooseChangFen();<span class="hljs-comment">//选择肠粉</span><br>        waiter.chooseHunTun();<span class="hljs-comment">//选择馄饨</span><br>        waiter.chooseHeFen();<span class="hljs-comment">//选择河粉</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>当系统的某项操作具备命令语义，且命令实现不稳定（变化）时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。接收方与抽象命令呈现弱耦合（内部方法无需一致），具备良好的扩展性。</p><p>通常适用于以下场景：</p><p>1.请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。</p><p>2.系统随机请求命令或经常增加、删除命令时，命令模式可以方便的实现这些功能。</p><p>3.当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</p><p>4.当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</p><h2 id="4-优缺点分析-13"><a href="#4-优缺点分析-13" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1.通过引入中间件（抽象接口）降低系统的耦合度。</p><p>2.扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。</p><p>3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</p><p>4.方便实现Undo和Redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</p><p>5.可以在现有命令的基础上，增加额外功能。比如日志记录，结合装配器模式会更加灵活。</p><p>缺点：</p><p>1.可能产生大量具体的命令类。因为每一个操作都需要设计一个具体命令类，这会增加系统的复杂性。</p><p>2.命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外的类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</p><h1 id="十六、解释器模式"><a href="#十六、解释器模式" class="headerlink" title="十六、解释器模式"></a>十六、解释器模式</h1><h2 id="1-解释-15"><a href="#1-解释-15" class="headerlink" title="1.解释"></a>1.解释</h2><p>定义：给分析对象定义一种语言，并定义该语言的文法表示，再设计一个解释器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><h2 id="2-包含的角色-14"><a href="#2-包含的角色-14" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret()。</p><p>2.终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个操作符都有一个具体终结表达式与之相对应。</p><p>3.非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p><p>4.环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p><p>5.客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p><h2 id="3-使用场景分析及代码实现-12"><a href="#3-使用场景分析及代码实现-12" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><p>应用实例：</p><p>用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//抽象表达式类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expression</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">interpret</span>(<span class="hljs-title class_">String</span> info);<br>&#125;<br><span class="hljs-comment">//终结符表达式类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;<span class="hljs-title class_">String</span>&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TerminalExpression</span>(<span class="hljs-title class_">String</span>[] data)&#123;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++)<br>             set.<span class="hljs-title function_">add</span>(data[i]);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">interpret</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> info</span>)&#123;<br>        <span class="hljs-keyword">if</span>(set.<span class="hljs-title function_">contains</span>(info))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//非终结符表达式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Expression</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Expression</span> city = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Expression</span> person = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">AndExpression</span>(<span class="hljs-title class_">Expression</span> city,<span class="hljs-title class_">Expression</span> person)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">city</span> = city;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span> = person;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">interpret</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> info</span>)&#123;<br>        <span class="hljs-title class_">String</span> s[] = info.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;的&quot;</span>);<br>        <span class="hljs-keyword">return</span> city.<span class="hljs-title function_">interpret</span>(s[<span class="hljs-number">0</span>]) &amp;&amp; person.<span class="hljs-title function_">interpret</span>(s[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span>[] citys = &#123;<span class="hljs-string">&quot;韶关&quot;</span>，<span class="hljs-string">&quot;广州&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span>[] persons = &#123;<span class="hljs-string">&quot;老人&quot;</span>，<span class="hljs-string">&quot;妇女&quot;</span>，<span class="hljs-string">&quot;儿童&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Expression</span> cityPerson;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Context</span>()&#123;<br>        <span class="hljs-title class_">Expression</span> city = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(citys);<br>        <span class="hljs-title class_">Expression</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>(persons);<br>        cityPerson = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndExpression</span>(city,person);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">freeRide</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> info</span>)&#123;<br>        <span class="hljs-built_in">boolean</span> ok = cityPerson.<span class="hljs-title function_">interpret</span>(info);<br>        <span class="hljs-keyword">if</span>(ok)<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;您是&quot;</span> + info + <span class="hljs-string">&quot;，您本次乘车免费！&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(info + <span class="hljs-string">&quot;，您不是免费人员，本次乘车扣费2元！&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterpreterPatternDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>)&#123;<br>        <span class="hljs-title class_">Context</span> bus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        bus.<span class="hljs-title function_">freeRide</span>(<span class="hljs-string">&quot;韶关的老人&quot;</span>);<br>bus.<span class="hljs-title function_">freeRide</span>(<span class="hljs-string">&quot;韶关的年轻人&quot;</span>);<br>        bus.<span class="hljs-title function_">freeRide</span>(<span class="hljs-string">&quot;广州的妇女&quot;</span>);<br>        bus.<span class="hljs-title function_">freeRide</span>(<span class="hljs-string">&quot;广州的儿童&quot;</span>);<br>        bus.<span class="hljs-title function_">freeRide</span>(<span class="hljs-string">&quot;山东的儿童&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果</span><br>您是韶关的老人，您本次乘车免费！<br>韶关的年轻人，您不是免费人员，本次乘车扣费<span class="hljs-number">2</span>元！<br>您是广州的妇女，您本次乘车免费！<br>您是广州的儿童，您本次乘车免费！<br>山东的儿童，您不是免费人员，本次乘车扣费<span class="hljs-number">2</span>元！<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-14"><a href="#4-优缺点分析-14" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>应用场景：</p><p>1.当语言的文法较为简单，且执行效率不是关键问题时。</p><p>2.当问题重复出现，且可以用一种简单的语言来进行表达时。</p><p>3.当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如XML文档解释。</p><p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。</p><p>优点：</p><p>1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</p><p>2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</p><p>缺点：</p><p>1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</p><p>2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理和维护。</p><p>3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</p><h1 id="十七、迭代器模式"><a href="#十七、迭代器模式" class="headerlink" title="十七、迭代器模式"></a>十七、迭代器模式</h1><h2 id="1-解释-16"><a href="#1-解释-16" class="headerlink" title="1.解释"></a>1.解释</h2><p>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了“开闭原则”。</p><p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><p>1.暴露了聚合类的内部表示，使其数据不安全。</p><p>2.增加了客户的负担。</p><p>“迭代器模式”能较好的克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，比如java中的Collection、List、Set、Map等都包含了迭代器。</p><p>迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送什么的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。</p><h2 id="2-包含的角色-15"><a href="#2-包含的角色-15" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</p><p>2.具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p><p>3.抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含hasNext()、first()、next()等方法。</p><p>4.具体迭代器（ConcreteIterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p><h2 id="3-使用场景分析及代码实现-13"><a href="#3-使用场景分析及代码实现-13" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象聚合</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Aggregate</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">Object obj</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>(<span class="hljs-params">Object obj</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">getIterator</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体聚合</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> <span class="hljs-title">implements</span> <span class="hljs-title">Aggregate</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">Object obj</span>)</span>&#123;<br>        list.<span class="hljs-keyword">add</span>(obj);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>(<span class="hljs-params">Object obj</span>)</span>&#123;<br>        list.<span class="hljs-keyword">remove</span>(obj);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">getIterator</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> ConcreteIterator(list));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象迭代器</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&#123;<br>    <span class="hljs-function">Object <span class="hljs-title">first</span>()</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">next</span>()</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">hasNext</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体迭代器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span> <span class="hljs-title">implements</span> <span class="hljs-title">Iterator</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; list = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> index = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span>(<span class="hljs-params">List&lt;Object&gt; list</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.list = list;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">hasNext</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; list.size() <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">first</span>()</span>&#123;<br>        index = <span class="hljs-number">0</span>;<br>        Object obj = list.<span class="hljs-keyword">get</span>(index);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span>()</span>&#123;<br>        Object obj = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.hasNext())&#123;<br>            obj = list.<span class="hljs-keyword">get</span>(++index);<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IteratorPattern</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        Aggregate ag = <span class="hljs-keyword">new</span> ConcreteAggregate();<br>        ag.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;中山大学&quot;</span>);<br>ag.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;华南理工&quot;</span>);<br>        ag.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;韶关学院&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;聚合的内容有：&quot;</span>);<br>        Iterator it = ag.getIterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object obj = it.next();<br>            System.<span class="hljs-keyword">out</span>.print(ob.toString()+<span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        Object ob = it.first();<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\nFirst：&quot;</span>+ob.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用实现：用迭代器模式编写一个浏览旅游风景图的程序。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//代码实现</span><br><span class="hljs-comment">//实体类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Spot</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String introduce;<br>    Spot(String name,String introduce)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.introduce = introduce;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIntroduce</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.introduce;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象聚合类:景点集接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">ViewSpotSet</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">Spot obj</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>(<span class="hljs-params">Spot obj</span>)</span>;<br>    <span class="hljs-function">ViewSpotIterator <span class="hljs-title">getIterator</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体聚合类：景点集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewSpotSet</span> <span class="hljs-title">implements</span> <span class="hljs-title">ViewSpotSet</span>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Spot&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Spot&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">Spot obj</span>)</span>&#123;<br>        list.<span class="hljs-keyword">add</span>(obj);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>(<span class="hljs-params">Spot obj</span>)</span>&#123;<br>        list.<span class="hljs-keyword">remove</span>(obj);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewSpotIterator <span class="hljs-title">getIterator</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> MyViewSpotIterator(list));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象迭代器：景点迭代器接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">ViewSpotIterator</span>&#123;<br>    <span class="hljs-function">boolean <span class="hljs-title">hasNext</span>()</span>;<br>    <span class="hljs-function">Spot <span class="hljs-title">first</span>()</span>;<br>    <span class="hljs-function">Spot <span class="hljs-title">next</span>()</span>;<br>    <span class="hljs-function">Spot <span class="hljs-title">previous</span>()</span>;<br>    <span class="hljs-function">Spot <span class="hljs-title">last</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体迭代器：景点迭代器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewSpotIterator</span> <span class="hljs-title">implements</span> <span class="hljs-title">ViewSpotIterator</span>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Spot&gt; list = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> index = <span class="hljs-number">-1</span>;<br>    Spot obj = <span class="hljs-literal">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyViewSpotIterator</span>(<span class="hljs-params">ArrayList&lt;Spot&gt; list</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.list = list;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> boolean <span class="hljs-title">hasNext</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; list.size() - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spot <span class="hljs-title">first</span>()</span>&#123;<br>        index = <span class="hljs-number">0</span>;<br>        obj = list.<span class="hljs-keyword">get</span>(index);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spot <span class="hljs-title">next</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.hasNext())&#123;<br>            obj = list.<span class="hljs-keyword">get</span>(index);<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spot <span class="hljs-title">previous</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-number">0</span>)&#123;<br>            obj = list.<span class="hljs-keyword">get</span>(--index);<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spot <span class="hljs-title">last</span>()</span>&#123;<br>        index = list.size()<span class="hljs-number">-1</span>;<br>        obj = list.<span class="hljs-keyword">get</span>(index);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>1.当需要为聚合对象提供多种遍历方式时。</p><p>2.当需要为遍历不同的聚合结构提供一个统一的接口时。</p><p>3.当访问一个聚合对象的内容而无须暴露其内部实现细节的表示时。</p><h2 id="4-优缺点分析-15"><a href="#4-优缺点分析-15" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>迭代器模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下：</p><p>1.访问一个聚合对象的内容而无须暴露它的内部表示。</p><p>2.遍历任务交由迭代器完成，这简化了聚合类。</p><p>3.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</p><p>4.增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p><p>5.封装性良好，为遍历不同的聚合结构提供一个统一的接口。</p><p>缺点：</p><p>主要缺点是增加了类的个数，这在一定程度上增加了系统的复杂性。</p><p>在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的API完全够用。</p><h1 id="十八、中介者模式"><a href="#十八、中介者模式" class="headerlink" title="十八、中介者模式"></a>十八、中介者模式</h1><h2 id="1-解释-17"><a href="#1-解释-17" class="headerlink" title="1.解释"></a>1.解释</h2><p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是”网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他所有朋友的电话；而且，朋友中如果有的人电话修改了，他必须让其他所有的朋友一起修改，这叫作”牵一发而动全身”，非常复杂。</p><p>如果把这种”网状结构”改为”星型结构”的话，将大大降低它们之间的”耦合性”,这时只要找一个”中介者”就可以了。如前面所说的”每个人必须记住所有朋友电话”的问题，只要在网上建立一个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</p><p>使用中介者模式，它将大大降低对象之间的耦合性，提高系统的灵活性。</p><p>中介者模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立的改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><h2 id="2-包含的角色-16"><a href="#2-包含的角色-16" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p><p>2.具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个list来管理同事对象，协调各个同事对象之间的交互关系，因此它依赖于同事角色。</p><p>3.抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p><p>4.具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p><h2 id="3-使用场景分析及代码分析"><a href="#3-使用场景分析及代码分析" class="headerlink" title="3.使用场景分析及代码分析"></a>3.使用场景分析及代码分析</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象中介者</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span>(<span class="hljs-params">Colleague colleague</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relay</span>(<span class="hljs-params">Colleague cl</span>)</span>;<span class="hljs-comment">//转发</span><br>&#125;<br><span class="hljs-comment">//具体中介者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-title">extends</span> <span class="hljs-title">Mediator</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="hljs-keyword">new</span> ArrayList&lt;Colleage&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span>(<span class="hljs-params">Colleague colleague</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!colleagues.contains(colleague))&#123;<br>            colleagues.<span class="hljs-keyword">add</span>(colleague);<br>            colleague.setMedium(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relay</span>(<span class="hljs-params">Colleague cl</span>)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Colleague ob:colleagues)&#123;<br>            <span class="hljs-keyword">if</span>(!ob.<span class="hljs-keyword">equals</span>(cl))&#123;<br>                ((Colleague)ob).receive()<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象同事类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span>&#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMedium</span>(<span class="hljs-params">Mediator mediator</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.mediator = mediator;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体同事类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague1</span> <span class="hljs-title">extends</span> <span class="hljs-title">Colleague</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体同事1收到请求&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span>()</span>&#123;<br>     System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体同事类1发出请求&quot;</span>);<br>        mediator.relay(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//请中介者转发</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体同事类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague2</span> <span class="hljs-title">extends</span> <span class="hljs-title">Colleague</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体类同事类2收到请求。&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体同事类2发出请求&quot;</span>);<br>        mediator.relay(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//请中介者转发</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MediatorPattern</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        Mediator md = <span class="hljs-keyword">new</span> ConcreteMediator();<br>        Colleague c1,c2;<br>        c1 = <span class="hljs-keyword">new</span> ConcreteColleague1();<br>        c2 = <span class="hljs-keyword">new</span> ConcreteColleague2();<br>        md.register(c1);<br>        md.register(c2);<br>        c1.send();<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br>        c2.send();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果如下：</span><br>具体同事类<span class="hljs-number">1</span>发出请求。<br>具体同事类<span class="hljs-number">2</span>收到请求。<br>-------------<br>具体同事类<span class="hljs-number">2</span>发出请求。<br>具体同事类<span class="hljs-number">1</span>收到请求。<br></code></pre></td></tr></table></figure><p>应用场景分析：</p><p>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用的时。</p><p>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</p><h2 id="4-优缺点分析-16"><a href="#4-优缺点分析-16" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1.类之间各司其职，符合迪米特法则。</p><p>2.降低了对象之间的耦合性，使得对象易于独立的被复用。</p><p>3.将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</p><p>缺点：</p><p>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变的复杂且难以维护。</p><h1 id="十九、备忘录模式"><a href="#十九、备忘录模式" class="headerlink" title="十九、备忘录模式"></a>十九、备忘录模式</h1><h2 id="1-解释-18"><a href="#1-解释-18" class="headerlink" title="1.解释"></a>1.解释</h2><p>每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实很残酷。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然可以！而且是有必要的。这个功能是“备忘录模式”。</p><p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前的操作，使数据恢复到它原先的状态。</p><p>备忘录模式的定义：在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要将该对象恢复到原先保存的状态，该模式又叫快照模式。</p><h2 id="2-包含的角色-17"><a href="#2-包含的角色-17" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其它业务功能，它可以访问备忘录里的所有信息。</p><p>2.备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p><p>3.管理人（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问和修改。</p><h2 id="3-使用场景分析及代码实现-14"><a href="#3-使用场景分析及代码实现-14" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//备忘录</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-title class_">String</span> state)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> state</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//发起人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> state</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Memento</span> <span class="hljs-title function_">createMemento</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(state);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">restoreMemento</span>(<span class="hljs-params"><span class="hljs-title class_">Memento</span> m</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(m.<span class="hljs-title function_">getState</span>());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//管理者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Memento</span> memento;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMemento</span>(<span class="hljs-params"><span class="hljs-title class_">Memento</span> m</span>)&#123;<br>        memento = m;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Memento</span> <span class="hljs-title function_">getMemento</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MementoPattern</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>)&#123;<br>        <span class="hljs-title class_">Originator</span> or = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>();<br>        <span class="hljs-title class_">Caretaker</span> cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caretaker</span>();<br>        or.<span class="hljs-title function_">setState</span>(<span class="hljs-string">&quot;S0&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;初始状态：&quot;</span>+or.<span class="hljs-title function_">getState</span>());<br>        cr.<span class="hljs-title function_">setMemento</span>(or.<span class="hljs-title function_">createMemento</span>());<span class="hljs-comment">//保存状态</span><br>        or.<span class="hljs-title function_">setState</span>(<span class="hljs-string">&quot;S1&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;新的状态：&quot;</span>+or.<span class="hljs-title function_">getState</span>());<br>        or.<span class="hljs-title function_">restoreMemento</span>(cr.<span class="hljs-title function_">getMemento</span>());<span class="hljs-comment">//恢复状态</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;恢复状态:&quot;</span>+or.<span class="hljs-title function_">getState</span>())；<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果打印</span><br>初始状态:<span class="hljs-variable constant_">S0</span><br>新的状态:<span class="hljs-variable constant_">S1</span><br>恢复状态:<span class="hljs-variable constant_">S0</span><br></code></pre></td></tr></table></figure><p>应用场景：<br>1.需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p><p>2.需要提供一个可回滚操作的场景，如word、记事本、photoshop，Eclipse等软件在编辑时按ctrl+z组合键，还有数据库中事务操作。</p><h2 id="4-优缺点分析-17"><a href="#4-优缺点分析-17" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>提供了一种可以恢复状态的机制。当用户需要时能够比较方便的将数据恢复到某个历史的状态。</p><p>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能访问这些状态信息。</p><p>简化了发起人类。发起人不需要管理和保护其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，符合单一职责原则。</p><p>缺点：</p><p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p><h1 id="二十、访问者模式"><a href="#二十、访问者模式" class="headerlink" title="二十、访问者模式"></a>二十、访问者模式</h1><h2 id="1-解释-19"><a href="#1-解释-19" class="headerlink" title="1.解释"></a>1.解释</h2><p>在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景色的评价可能不同；医院医生开的处方单中包含多种药元素，查看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。</p><p>这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序结构与数据结构，这提高了程序的扩展性和灵活性。</p><p>访问者模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。他将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p><h2 id="2-包含的角色-18"><a href="#2-包含的角色-18" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体类对应一个访问操作visit()，该操作中的参数类型标识了被访问的具体元素。</p><p>2.具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p><p>3.抽象元素（Element）角色：声明一个包含接受操作accept()的接口，被接受的访问者对象作为accept()方法的参数。</p><p>4.具体元素（ConcreteElement）角色：实现抽象元素本身角色提供的accept()操作，其方法体通常都是visitor.visit（this）,另外具体元素中可能还包含本身业务逻辑的相关操作。</p><p>5.对象结构（ObjectStructure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由List、Set、Map等聚合类实现。</p><h2 id="3-使用场景分析及代码实现-15"><a href="#3-使用场景分析及代码实现-15" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//抽象访问者</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span>&#123;<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">visit</span>(<span class="hljs-title class_">ConcreteElementA</span> element);<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">visit</span>(<span class="hljs-title class_">ConcreteElementB</span> element);<br>&#125;<br><span class="hljs-comment">//具体访问者A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params"><span class="hljs-title class_">ConcreteElementA</span> element</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;具体访问者A访问--&gt;&quot;</span> + element.<span class="hljs-title function_">operationA</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params"><span class="hljs-title class_">ConcreteElmentB</span> element</span>)&#123;<br>       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;具体访问者A访问--&gt;&quot;</span> + element.<span class="hljs-title function_">operationB</span>());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体访问者B类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params"><span class="hljs-title class_">ConcreteElementA</span> element</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;具体访问者B访问--&gt;&quot;</span> + element.<span class="hljs-title function_">operationA</span>());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params"><span class="hljs-title class_">ConcreteElmentB</span> element</span>)&#123;<br>       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;具体访问者B访问--&gt;&quot;</span> + element.<span class="hljs-title function_">operationB</span>());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象元素类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span>&#123;<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-title class_">Visitor</span> visitor);<br>&#125;<br><span class="hljs-comment">//具体元素A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params"><span class="hljs-title class_">Visitor</span> visitor</span>)&#123;<br>        visitor.<span class="hljs-title function_">visit</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operationA</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;具体元素A的操作&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体元素B类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params"><span class="hljs-title class_">Visitor</span> visitor</span>) &#123;<br>        visitor.<span class="hljs-title function_">visit</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">operationB</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;具体元素B的操作。&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对象结构角色</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectStructure</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Element</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Element</span>&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params"><span class="hljs-title class_">Visitor</span> visitor</span>) &#123;<br>        <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-title class_">Element</span>&gt; i = list.<span class="hljs-title function_">iterator</span>();<br>        <span class="hljs-keyword">while</span> (i.<span class="hljs-title function_">hasNext</span>()) &#123;<br>            ((<span class="hljs-title class_">Element</span>) i.<span class="hljs-title function_">next</span>()).<span class="hljs-title function_">accept</span>(visitor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-title class_">Element</span> element</span>) &#123;<br>        list.<span class="hljs-title function_">add</span>(element);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params"><span class="hljs-title class_">Element</span> element</span>) &#123;<br>        list.<span class="hljs-title function_">remove</span>(element);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VisitorPattern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ObjectStructure</span> os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectStructure</span>();<br>        os.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementA</span>());<br>        os.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementB</span>());<br>        <span class="hljs-title class_">Visitor</span> visitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitorA</span>();<br>        os.<span class="hljs-title function_">accept</span>(visitor);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>        visitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitorB</span>();<br>        os.<span class="hljs-title function_">accept</span>(visitor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-18"><a href="#4-优缺点分析-18" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1）扩展性好，能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p><p>2）复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</p><p>3）灵活性好。访问者模式将数据结构与作用与结构上的对象解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</p><p>4）符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使得每个访问者的功能都比较单一。</p><p>缺点：</p><p>1）添加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问类中增加相应的具体操作，这违背了“开闭原则”。</p><p>2）破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</p><p>3）违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</p><h1 id="二十一、模板方法模式"><a href="#二十一、模板方法模式" class="headerlink" title="二十一、模板方法模式"></a>二十一、模板方法模式</h1><h2 id="1-解释-20"><a href="#1-解释-20" class="headerlink" title="1.解释"></a>1.解释</h2><p>在面向对象程序设计过程中，程序员常常会遇到这样的情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如：一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据需求去更新它，例如，简历模板、论问模板、Word中的模板文件等。</p><p>模板方法模式定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p><h2 id="2-包含的角色-19"><a href="#2-包含的角色-19" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>1.抽象类&#x2F;抽象模板（Abstract Class）</p><p>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p><p>1）模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p><p>2）基本方法：是整个算法中的一个步骤，包含以下几种类型。</p><p>抽象方法：在抽象类中声明，由具体子类实现。</p><p>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</p><p>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>2.具体子类&#x2F;具体实现（Concrete Class）</p><p>具体实现类，实现抽象类中所定义的抽象方法和钩子方法，他们是一个顶级逻辑的一个组成步骤。</p><h2 id="3-使用场景分析及代码实现-16"><a href="#3-使用场景分析及代码实现-16" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span>&#123;<br>    <span class="hljs-comment">//模板方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span>()</span>&#123;<br>        SpecificMethod();<br>        abstractMethod1();<br>        abstractMethod2();<br>    &#125;<br>    <span class="hljs-comment">//具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpecificMethod</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;抽象类中的具体方法调用...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//抽象方法1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span>()</span>;<br>    <span class="hljs-comment">//抽象方法2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> <span class="hljs-title">extends</span> <span class="hljs-title">AbstractClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;抽象方法1的实现被调用...&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;抽象方法2的实现被调用...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethodPattern</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        AbstractClass tm = <span class="hljs-keyword">new</span> ConcreteClass();<br>        tm.TemplateMethod();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果如图</span><br>抽象类中的具体方法被调用...<br>抽象方法<span class="hljs-number">1</span>的实现被调用...<br>抽象方法<span class="hljs-number">2</span>的实现被调用...<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>1）算法的整体步骤很固定，但其中个别部分易变的时候，这时候可以使用模板方法模式，将容易变得部分抽象出来，供子类实现。</p><p>2）当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</p><p>3）当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</p><p>扩展：</p><p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//含钩子方法</span><br><span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HookAbstractClass</span>&#123;<br>    <span class="hljs-comment">//模板方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span>()</span>&#123;<br>        abstractMethod1();<br>        hookMethod1();<br>        <span class="hljs-keyword">if</span>(hookMethod2())&#123;<br>            specificMethod();<br>        &#125;<br>        abstractMethod2();<br>    &#125;<br>    <span class="hljs-comment">//具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificMethod</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;抽象类中的具体方法被调用...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//钩子方法1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookMethod1</span>()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//钩子方法2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookMethod2</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//抽象方法1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span>()</span>;<br>    <span class="hljs-comment">//抽象方法2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span>()</span>;<br>&#125;<br><span class="hljs-comment">//具体子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">HookConcreteClass</span> <span class="hljs-title">extends</span> <span class="hljs-title">HookAbstractClass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod1</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;抽象方法1的实现被调用...&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abstractMethod2</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;抽象方法2的实现被调用...&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookMethod1</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;钩子方法1被重写...&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">hookMethod2</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HookTemplateMethod</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        HookAbstractClass tm = <span class="hljs-keyword">new</span> HookAbstractClass();<br>        tm.TemplateMethod();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br>抽象方法<span class="hljs-number">1</span>的实现被调用...<br>钩子方法<span class="hljs-number">1</span>被重写...<br>抽象方法<span class="hljs-number">2</span>的实现被调用...<br></code></pre></td></tr></table></figure><h2 id="4-优缺点分析-19"><a href="#4-优缺点分析-19" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1）封装了不变的部分，扩展了可变的部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</p><p>2）它在父类中提取了公共的部分代码，便于代码复用。</p><p>3）部分方法是由子类实现的，因此子类可以通过扩展方法增加相应的功能，符合开闭原则。</p><p>缺点：<br>1）对每个不同的实现都需要定义一个子类，这会导致类的个数增大，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</p><p>2）父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p><p>3）由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有的子类都要改一遍。</p><h1 id="二十二、策略模式"><a href="#二十二、策略模式" class="headerlink" title="二十二、策略模式"></a>二十二、策略模式</h1><h2 id="1-解释-21"><a href="#1-解释-21" class="headerlink" title="1.解释"></a>1.解释</h2><p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以采用打折、送商品、送积分等方法。</p><p>在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。</p><p>如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改源代码，不易维护，违背开闭原则。如果采用策略模式就能很好的解决该问题。</p><p>策略模式定义：该模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h2 id="2-包含的角色-20"><a href="#2-包含的角色-20" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</p><p>（2）具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</p><p>（3）环境（Context）类：持有一个策略类的引用，最终给客户端调用。</p><h2 id="3-使用场景分析及代码实现-17"><a href="#3-使用场景分析及代码实现-17" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//抽象策略类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span>()</span>;<span class="hljs-comment">//策略方法</span><br>&#125;<br><span class="hljs-comment">//具体策略类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-title">implements</span> <span class="hljs-title">Strategy</span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体策略A的策略方法被访问！&quot;</span>);<br>    &#125;    <br>&#125;<br><span class="hljs-comment">//具体策略类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-title">implements</span> <span class="hljs-title">Strategy</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;具体策略B的策略方法被访问！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&#123;<br>    <span class="hljs-keyword">private</span> Strategy strategy;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Strategy <span class="hljs-title">getStrategy</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> strategy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrategy</span>(<span class="hljs-params">Strategy strategy</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.strategy = strategy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strategyMethod</span>()</span>&#123;<br>        strategy.strategyMethod();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StrategyPattern</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        Context c = <span class="hljs-keyword">new</span> Context();<br>        Strategy s = <span class="hljs-keyword">new</span> ConcreteStrategyA();<br>        c.setStrategy(s);<br>        c.strategyMethod();<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        s = <span class="hljs-keyword">new</span> ConcreteStrategyB();<br>        c.setStrategy(s);<br>        c.strategyMethod();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br>具体策略A的策略方法被访问！<br>-----------------<br>具体策略B的策略方法被访问！<br></code></pre></td></tr></table></figure><p>应用场景分析：</p><p>1.一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</p><p>2.一个类中定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</p><p>3.系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</p><p>4.系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</p><p>5.多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</p><p>扩展：</p><p>在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变的很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大的减少客户端的工作复杂度。</p><h2 id="4-优缺点分析-20"><a href="#4-优缺点分析-20" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1.多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如if…else语句、switch…case语句。</p><p>2.策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</p><p>3.策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</p><p>4.策略模式提供了对开闭原则的完美支持，可以在不修改源代码的情况下，灵活的增加算法。</p><p>5.策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</p><p>缺点：</p><p>1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</p><p>2.策略模式造成很多的策略类，增加维护难度。</p><h1 id="二十三、状态模式"><a href="#二十三、状态模式" class="headerlink" title="二十三、状态模式"></a>二十三、状态模式</h1><h2 id="1-解释-22"><a href="#1-解释-22" class="headerlink" title="1.解释"></a>1.解释</h2><p>在软件开发过程中，应用程序中的部分对象可能会根据不同情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态就会发生变化。如人都有高兴和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。</p><p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用if-else或switch-case语句来做状态判断，再进行不同的情况处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的if-else语句，这违背了”开闭原则“，不利于程序的扩展。</p><p>以上问题如果采用”状态模式“就能很好的得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关”判断逻辑“提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了if-else、switch-case等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><p>状态模式的定义：对有状态的对象，把复杂的”判断逻辑“提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h2 id="2-包含的角色-21"><a href="#2-包含的角色-21" class="headerlink" title="2.包含的角色"></a>2.包含的角色</h2><p>（1）环境类（Context）角色：也称上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</p><p>（2）抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</p><p>（3）具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</p><h2 id="3-使用场景分析及代码实现-18"><a href="#3-使用场景分析及代码实现-18" class="headerlink" title="3.使用场景分析及代码实现"></a>3.使用场景分析及代码实现</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//环境类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&#123;<br>    <span class="hljs-keyword">private</span> State state;<br>    <span class="hljs-comment">//定义环境类的初始状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span>()</span>&#123;<br>        <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> ConcreteStateA();<br>    &#125;<br>    <span class="hljs-comment">//设置新状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span>(<span class="hljs-params">State state</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-comment">//读取状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> (state);<br>    &#125;<br>    <span class="hljs-comment">//对请求做处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>()</span>&#123;<br>        state.Handle(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象状态类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">State</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span>;<br>&#125;<br><span class="hljs-comment">//具体状态A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateA</span> <span class="hljs-title">extends</span> <span class="hljs-title">State</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;当前状态是A&quot;</span>);<br>        context.setState(<span class="hljs-keyword">new</span> ConcreteStateB());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态B类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStateB</span> <span class="hljs-title">extends</span> <span class="hljs-title">State</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Context context</span>)</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;当前状态是B&quot;</span>);<br>        context.setState(<span class="hljs-keyword">new</span> ConcreteStateA());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StatePatternClient</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<span class="hljs-comment">//创建环境</span><br>        context.Handle();<span class="hljs-comment">//处理请求</span><br>        context.Handle();<br>        context.Handle();<br>        context.Handle(); <br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br>当前状态是 A.<br>当前状态是 B.<br>当前状态是 A.<br>当前状态是 B.<br></code></pre></td></tr></table></figure><p>应用场景：</p><p>1.当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</p><p>2.一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</p><p>扩展：</p><p>在有些情况下，可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享。</p><h2 id="4-优缺点分析-21"><a href="#4-优缺点分析-21" class="headerlink" title="4.优缺点分析"></a>4.优缺点分析</h2><p>优点：</p><p>1.结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足”单一职责原则“。</p><p>2.将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</p><p>3.状态类职责明确，有利于程序的扩展。通过定义新的子类很容易的增加新的状态和转换。</p><p>缺点：</p><p>1.状态模式的使用必然会增加系统的类与对象的个数。</p><p>2.状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</p><p>3.状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</p><h2 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5.拓展"></a>5.拓展</h2><p>1.状态模式与责任链模式的区别</p><p>状态模式和责任链模式都能消除if-else分支过多的问题。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。</p><p>从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链强调的是外部节点对象间的改变。</p><p>从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链不知道其下一个节点处理对象，因为链式组装由客户端负责。</p><p>2.状态模式和策略模式的区别</p><p>状态模式和策略模式的UML类图架构几乎完全一样，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，彼此之间是独立的，用户可自行更换策略算法，而状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果，并且用户无法指定状态，只能设置初始状态。</p><h1 id="二十四、面向对象设计原则"><a href="#二十四、面向对象设计原则" class="headerlink" title="二十四、面向对象设计原则"></a>二十四、面向对象设计原则</h1><h2 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h2><p>软件实体应当对扩展开放，对修改关闭，这就是开闭原则的经典定义。这里的软件实体包括以下几个部分：1.项目中划分的模块 2.类与接口 3.方法</p><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。作用如下：</p><p>1.对软件测试的影响</p><p>2.可以提高代码的可复用性</p><p>3.可以提高软件的可维护性</p><h2 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h2><p>继承必须确保超类所拥有的性质在子类中仍然成立。里氏替换原则是继承复用的基础，它反映了基类和子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><p>作用：</p><p>1.里氏替换原则是实现开闭原则的重要方式之一。</p><p>2.它克服了继承中重写父类造成的可复用性变差的缺点。</p><p>3.它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</p><p>4.加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</p><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>里氏替换原则的定义：</p><p>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p><p>2.子类中可以增加自己特有的方法。</p><p>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。</p><p>4.当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类的方法更严格或相等。</p><h2 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3.依赖倒置原则"></a>3.依赖倒置原则</h2><p>原始定义为：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是:要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则是实现开闭原则的重要途经之一，它降低了客户和实现模块之间的耦合。</p><p>这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><p>依赖倒置原则的作用：</p><p>1.依赖倒置原则可以降低类间的耦合性</p><p>2.依赖倒置原则可以提高系统的稳定性</p><p>3.依赖倒置原则可以减少并行开发引起的风险</p><p>4.依赖倒置原则可以提高代码的可读性和可维护性</p><p>实现方法：<br>1.每个类尽量提供接口或抽象类，或者两者都具备。</p><p>2.变量的声明类型尽量是接口或者抽象类</p><p>3.任何类都不应该从具体类派生</p><p>4.使用继承时尽量遵循里氏替换原则。</p><h2 id="4-单一职责原则"><a href="#4-单一职责原则" class="headerlink" title="4.单一职责原则"></a>4.单一职责原则</h2><p>又称单一功能原则，这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><p>1.一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力</p><p>2.当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</p><p>优点：</p><p>单一职责原则的核心就是控制类的粒度大小，将对象解耦、提高内聚性。如果遵循单一职责原则将有以下优点。</p><p>降低类的复杂度。一个类只负责一项职责，其逻辑肯定比要负责多项职责简单的多。</p><p>提高类的可读性，复杂性降低，自然其可读性会提高</p><p>提高系统的可维护性，可读性提高了，那自然就更容易维护了。</p><p>变更引起的风险降低。变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p><h2 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h2><p>接口隔离原则要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>定义是：客户端不应该被迫依赖于它不使用的方法。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责原则都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离</p><p>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><h2 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h2><p>迪米特法则的定义是只与你的直接朋友交谈，不跟陌生人说话。其含义是如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>优点：</p><p>迪米特法则则要求限制软件实体之间的通信的宽度和深度，正确使用迪米特法则将有以下两个优点：</p><p>降低了类之间的耦合度，提高了模块的相对独立性。</p><p>由于亲和度降低，从而提高了类的可复用率和系统的扩展性。</p><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在采用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Runnable接口</title>
    <link href="/2021/10/14/Runnable%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/10/14/Runnable%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Runnable接口"><a href="#一、Runnable接口" class="headerlink" title="一、Runnable接口"></a>一、Runnable接口</h1><p>创建线程可以通过继承Thread类，或者通过实现Runnable接口实现。其中如果程序员要继承其他类，就无法继承Thread类，只能通过实现Runnable接口。</p><h2 id="实现Runnable接口，启动新线程的步骤"><a href="#实现Runnable接口，启动新线程的步骤" class="headerlink" title="实现Runnable接口，启动新线程的步骤"></a>实现Runnable接口，启动新线程的步骤</h2><p>1.定义类实现Runnable接口</p><p>2.覆盖Runnable接口中的run方法（将线程要运行的代码存放在该run方法中）</p><p>3.通过Thread类创建线程对象</p><p>4.将Runnable接口的子类对象作为实际的参数传递给Thread类的构造函数（为什么要Runnable接口的子类对象传递给Thread的子类对象，所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象）</p><p>5.调用Thread类的start方法开启线程并且调用Runnable接口子类的run方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>)&#123;<br>        <span class="hljs-title class_">Thread</span> aThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Athread</span>());<br>        <span class="hljs-title class_">Thread</span> bThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bthread</span>());<br>        aThread.<span class="hljs-title function_">start</span>();<br>        bThread.<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Athread</span> implement <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Overrite</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;执行了A线程&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bthread</span> implement <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Overrite</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;执行了B线程&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现Runnable接口的意义"><a href="#实现Runnable接口的意义" class="headerlink" title="实现Runnable接口的意义"></a>实现Runnable接口的意义</h2><p>Runnable接口用来指定每个线程要执行的任务，包含了一个run的无参构造方法，需要由接口实现类重写该方法，并且实现接口避免了单继承的局限性。</p><h2 id="实现Runnable接口的原理"><a href="#实现Runnable接口的原理" class="headerlink" title="实现Runnable接口的原理"></a>实现Runnable接口的原理</h2><p>实现Runnable接口，可以多个继承，避免了继承Thread类的单继承局限性。将线程任务代码定义到run方法中。</p><p>创建Thread类的对象，只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而且这个run方法所属于Runnable接口的子类对象，所以<strong>将这个子类对象作为参数传递给Thread的构造函数</strong>，这样，线程对象创建时就<strong>可以明确要运行的线程的任务</strong>。</p><h2 id="实现Runnable接口的好处"><a href="#实现Runnable接口的好处" class="headerlink" title="实现Runnable接口的好处"></a>实现Runnable接口的好处</h2><p>声明实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象思想，线程分为两部分，一部分是线程对象，一部分是线程任务。继承Thread类，线程对象和线程任务会耦合在一起，一旦创建Thread类的子类对象，既是线程对象，又有线程任务。实现Runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。（解耦的意思是Thread不用跟某一个方法体绑定，只跟不同的runnable绑定。线程是线程，工作内容是工作内容。）如果继承了Thread就不能继承别的了，这样耦合度就增加了，对象组合依然会增加耦合度。</p><p><strong>线程的匿名内部类使用</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>    <span class="hljs-comment">//继承Thread类方法</span><br>    <span class="hljs-comment">//此处的new Thread()方法整体就是匿名内部类，创建线程对象，可以直接重写run()方法</span><br>    <span class="hljs-keyword">new</span> Thread()&#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>                System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;.start();<br>    <span class="hljs-comment">//实现Runnable接口方式</span><br>    <span class="hljs-comment">//此处的Runnable r = new Thread()方法整体就是匿名内部类，重写Runnable中的run()方法</span><br>    Runnable r = <span class="hljs-keyword">new</span> Runnable()&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>                System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i)<br>&#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">new</span> Thread(r).start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线程池，其实就是<strong>一个容纳多个线程的容器</strong>，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。线程池<strong>主要用来解决线程生命周期开销问题和资源不足问题</strong>。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，适当的调整线程中的线程数目可以防止出现资源不足的情况。</p><h3 id="使用线程池的方式-Runnable接口"><a href="#使用线程池的方式-Runnable接口" class="headerlink" title="使用线程池的方式-Runnable接口"></a>使用线程池的方式-Runnable接口</h3><p>通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。</p><p>Executors是线程池创建工厂类，ExecutorService是线程池类，Future接口用来记录线程任务执行完毕后产生的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-comment">//获得线程池对象</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<span class="hljs-comment">//此处表示线程池中有两个线程</span><br>    <span class="hljs-comment">//创建线程任务对象</span><br>    <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>    <span class="hljs-comment">//将线程任务交给线程池执行</span><br>    <span class="hljs-comment">//此处要有3条任务执行，而线程池只有2条，所以只能先执行前两个任务，其中一个任务执行完毕在继续第三个任务执行</span><br>    es.submit(r);<br>    es.submit(r);<br>    es.submit(r);<br>    <span class="hljs-comment">//销毁线程池</span><br>    es.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用线程池方式-Callable接口"><a href="#使用线程池方式-Callable接口" class="headerlink" title="使用线程池方式-Callable接口"></a>使用线程池方式-Callable接口</h3><p>Callable接口与Runnable接口功能相似，用来指定线程任务。其中的call()方法，用来返回线程任务执行完毕后的结果，call方法可抛出异常。</p><p>Futuresubmit(Callable task) : 获取线程池中的某一个线程对象，并执行线程中的call()方法。</p><p>Future接口：用来记录线程任务执行完毕后产生的结果。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) <span class="hljs-keyword">throws</span> InterruptedException,ExecutionException&#123;<br>    <span class="hljs-comment">//获取线程池对象</span><br>    ExecutorService es = Executors.<span class="hljs-property">newFixedThreadPool</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//创建线程任务</span><br>    MyCallable c = <span class="hljs-keyword">new </span><span class="hljs-class title_">MyCallable</span>();<br>    <span class="hljs-comment">//将线程任务交给线程池执行</span><br>    Future&lt;<span class="hljs-built_in">String</span>&gt; f = es.<span class="hljs-property">submit</span>(c);<br>    <span class="hljs-comment">//注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池</span><br>    <span class="hljs-comment">//获取返回值</span><br>    <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = f.<span class="hljs-property">get</span>();<br>    System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-built_in">str</span>);<br>    <span class="hljs-comment">//销毁线程池</span><br>    es.<span class="hljs-property">submit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Callable接口实现类，call方法可抛出异常、返回线程任务执行完毕后的结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GetSum</span> <span class="hljs-title">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> num;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GetSum</span>()</span>&#123;<br>        super();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GetSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num</span>)</span>&#123;<br>        super();<br>        <span class="hljs-keyword">this</span>.num = num;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span>() throws Exception</span>&#123;<br>        <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; num; i++)&#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)throws InterruptedException,ExecutionException</span>&#123;<br>    <span class="hljs-comment">//异步计算1-n的和</span><br>    <span class="hljs-comment">//两条线程分别计算1-100和1-200的和</span><br>    <span class="hljs-comment">//获取线程池对象</span><br>    ExecutorService es = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//创建线程任务对象，构造方法有返回值</span><br>    GetSum r1 = <span class="hljs-keyword">new</span> GetSum(<span class="hljs-number">100</span>);<br>    GetSum r2 = <span class="hljs-keyword">new</span> GetSum(<span class="hljs-number">200</span>);<br>    <span class="hljs-comment">//将线程任务提交给线程池执行</span><br>    Future&lt;Integer&gt; f1 = es.submit(t1);<br>    Future&lt;Integer&gt; f2 = es.sumbit(r2);<br>    <span class="hljs-comment">//获取返回值，任务同时进行，但结果有先后</span><br>    System.<span class="hljs-keyword">out</span>.println(f1.<span class="hljs-keyword">get</span>());<br>    System.<span class="hljs-keyword">out</span>.println(f2.<span class="hljs-keyword">get</span>());<br>    <span class="hljs-comment">//销毁线程池</span><br>    es.shutdown();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java定时器Timer详解</title>
    <link href="/2021/10/13/Java%E5%AE%9A%E6%97%B6%E5%99%A8Timer%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/10/13/Java%E5%AE%9A%E6%97%B6%E5%99%A8Timer%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、守护线程"><a href="#一、守护线程" class="headerlink" title="一、守护线程"></a>一、守护线程</h1><h2 id="1-守护线程的定义"><a href="#1-守护线程的定义" class="headerlink" title="1.守护线程的定义"></a>1.守护线程的定义</h2><p>在java中有两类线程：User Thread（用户线程）、Daemon Thread（守护线程）；**任何一个守护线程都是整个JVM中所有非守护线程的保姆。**只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。守护线程最典型的应用是GC（垃圾回收器）。用户可以在编写程序时，自己设置守护线程。</p><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><p>（1）thread.setDeamon（true）必须在thread.start（）之前进行设置，否则会报IllegalThreadStateException异常。不可以把常规线程设置为守护线程。</p><p>（2）在Deamon线程中产生的新线程也是Deamon的。</p><p>（3）读写操作或者计算逻辑不能分配给Deamon线程。</p><p>（4）JRE判断程序是否执行结束的标准是所有的前台线程执行完毕了，而不管后台线程的状态。</p><p>（5）守护线程也叫做服务线程，在没有用户线程时服务会自动离开。优先级较低，用于为系统中的其他对象和线程提供服务。</p><p>（6）守护线程不依赖于终端，但是依赖于系统，与系统”同生共死”。</p><h2 id="3-为什么要用守护线程？"><a href="#3-为什么要用守护线程？" class="headerlink" title="3.为什么要用守护线程？"></a>3.为什么要用守护线程？</h2><p>静态变量是ClassLoader级别的，如果Web应用程序停止，这些静态变量也会从JVM中清除。但是线程则是JVM级别的，如果你在Web应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。也就是说，即使停止了Web应用，这个线程依旧是活跃的。</p><p><strong>“舞台已经拆除，戏子继续表演。”</strong></p><p>如果在程序中使用Timer或Scheduler而不进行额外的处理，将会出现这一问题。</p><h1 id="二、定时器Timer"><a href="#二、定时器Timer" class="headerlink" title="二、定时器Timer"></a>二、定时器Timer</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>在JDK类库中Timer类主要负责计划任务的功能，也就是在指定时间开始执行某一个任务。此类也常用来做一下周期性同步工作，代替它的有quartz、SpringTask。Timer类的主要作用是设置计划任务，但封装任务的类是TimerTask类（实际上该类是一个抽象类，执行任务的代码要放在该类的子类中）。</p><p><strong>构造方法</strong></p><p><a href="https://img2018.cnblogs.com/blog/1196212/201812/1196212-20181227102245752-1827594921.png"><img src="https://img2018.cnblogs.com/blog/1196212/201812/1196212-20181227102245752-1827594921.png" alt="img"></a></p><p><strong>成员方法</strong></p><p><a href="https://img2018.cnblogs.com/blog/1196212/201812/1196212-20181227101856352-1648328232.png"><img src="https://img2018.cnblogs.com/blog/1196212/201812/1196212-20181227101856352-1648328232.png" alt="img"></a></p><p><strong>Timer内部维护一个TimerThread线程，而且线程名字与Thread类一样，默认用一个静态成员变量进行生成全局序列。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TaskQueue</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimerThread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TimerThread</span>(queue);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">static</span> AtomicInteger nextSerialNumber = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerThread的run方法中while循环获取TaskQueue中的task并且执行任务（mainLoop中执行task.run()方法–相当于同步调用）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerThread</span> extends Thread&#123;<br>    <span class="hljs-type">boolean</span> newTasksMayBeScheduled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> TaskQueue queue;<br>    <span class="hljs-built_in">TimerThread</span>(TaskQueue queue)&#123;<br>        <span class="hljs-keyword">this</span>.queue = queue;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-built_in">mainLoop</span>();<br>        &#125;finally&#123;<br>            <span class="hljs-built_in">synchronized</span>(queue)&#123;<br>                newTasksMayBeScheduled = <span class="hljs-literal">false</span>;<br>                queue.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            ......<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>TaskQueue用于存放TimerTask任务（内部维护一个TimerTask数组）</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskQueue</span></span>&#123;<br>    private TimerTask[] queue = new TimerTask[<span class="hljs-number">128</span>];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>TimerTask是一个继承Runnable接口的抽象类：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerTask</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Runnable</span></span></span>&#123;<br>    <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span><span class="hljs-type"></span> Object();<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerTask有一个cancel方法用于将当前任务从任务队列删除。（也就是队列中不会执行该任务，如果正在执行中调用该方法会执行完毕）</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">public boolean cancel()&#123;<br>    synchronized(lock)&#123;<br>        boolean result = (<span class="hljs-keyword">state</span>==SCHEDULED);<br>        <span class="hljs-keyword">state</span> = CANCELLED;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-相关方法的用法"><a href="#2-相关方法的用法" class="headerlink" title="2.相关方法的用法"></a>2.相关方法的用法</h2><p>（1）Schedule（task，Date）的用法：此方法用于<strong>在指定的时间执行一次task</strong>。默认的执行完毕不会结束线程，因为timer的成员属性thread默认是非守护线程，而且其run方法中通过轮询同步调用task的run()方法。</p><p>(2)Schedule(TimerTask task,Date firsttime,long period)的用法：此方法用于在指定的时间执行一次任务之后，在指定的period的时间间隔后不停的执行任务。（时间间隔是从任务开始执行计算的，也就是从当前任务执行的开始时间到下次任务开始时间的间隔是20秒）</p><p>(3)Schedule(TimerTask task,Long delay)的用法：以当前时间为参考，在延迟指定的秒数后执行一次性任务；如果延迟时间是负数会抛出IllegalArgumentException异常。</p><p>(4)Schedule(TimerTask task,long delay,long period)的用法：以当前时间为参考，在延迟指定的秒数后第一次执行任务；如果延迟时间是负数会抛出IllegalArgumentException异常。并且在period后重复执行任务，执行时间是从上次任务结束时间开始计算。凡是带period的都会在时间间隔后重复执行。</p><p>(5)scheduleAtFixedRate(TimerTask task,Date firstTime,Long period)的用法：在有延时和没有延时的情况下，周期性的任务的下次任务开始时间都是相对于上次任务的开始时间进行延迟。schedule和scheduleAtFixedRate的区别在于，如果指定开始执行的时间在当前系统运行时间之前，scheduleAtFixedRate会把已经过去的时间也作为周期执行，而schedule不会把过去的时间算上。scheduleAtFixedRate(TimerTask task,Date firstTime,Long period)有延迟，下次任务相对于上次任务的开始时间开始执行。如果指定的开始执行的时间在当前系统运行的时间之前，会把已经过去的时间也作为周期执行。</p><p>(6)TimerTask有一个cancel方法用于将当前任务从任务队列删除。（也就是队列中不会执行该任务，如果正在执行中调用该方法会执行完毕）。Timer的cancel方法用于清空所欲任务队列（如果有任务正在执行会等任务执行完清空；有时候不一定会停掉，因为cancel方法不一定能抢到queue对象的锁。）</p><h1 id="3-timer方法含义"><a href="#3-timer方法含义" class="headerlink" title="3.timer方法含义"></a>3.timer方法含义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();    <span class="hljs-comment">//其中会调用this(&quot;Timer-&quot; + serialNumber());, 即它以Timer+序列号为该定时器的名字</span><br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(String name);    <span class="hljs-comment">//以name作为该定时器的名字</span><br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-type">boolean</span> isDeamon);    <span class="hljs-comment">//是否将此定时器作为守护线程执行</span><br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(name, isDeamon);    <span class="hljs-comment">//定时器名字, 是否为守护线程</span><br></code></pre></td></tr></table></figure><p>以下所有的task都是TimerTask的子类，所有time都是Date类型的日期，所有delay和period都是long类型的延迟时间，单位为毫秒。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">timer</span>.schedule(task, <span class="hljs-built_in">time</span>);  //在<span class="hljs-built_in">time</span>时间执行task任务<span class="hljs-number">1</span>次<br><span class="hljs-built_in">timer</span>.schedule(task, <span class="hljs-built_in">delay</span>); //在延迟<span class="hljs-built_in">delay</span>毫秒后执行task任务<span class="hljs-number">1</span>次<br><span class="hljs-built_in">timer</span>.schedule(task, firstTime, period); //在firsttime时间执行task1次，之后定期period毫秒时间执行task,时间如果为过去时间,不会执行过去没有执行的任务,但是会马上执行<br><span class="hljs-built_in">timer</span>.schedule(task, <span class="hljs-built_in">delay</span>, period);//在延迟<span class="hljs-built_in">delay</span>后执行task1次，之后定期period毫秒时间执行task,时间如果为过去时间,不会执行过去没有执行的任务,但是会马上执行<br><span class="hljs-built_in">timer</span>.scheduleAtFixedRate(task, firstTime, period);//在firstTime时间执行task一次, 以后每隔period毫秒执行<span class="hljs-number">1</span>次, 时间如果为过去时间, 会执行过去没有执行的任务, 但是会马上执行<br><span class="hljs-built_in">timer</span>.scheduleAtFixedRate(task, <span class="hljs-built_in">delay</span>, period);//在<span class="hljs-built_in">delay</span>毫秒后执行task一次, 以后每隔period毫秒执行<span class="hljs-number">1</span>次, 时间如果为过去时间, 会执行过去没有执行的任务, 但是会马上执行<br></code></pre></td></tr></table></figure><p>区别：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">timer</span>.schedule(task, firstTime, period);<br><span class="hljs-built_in">timer</span>.scheduleAtFixedRate(task, firstTime, period);<br>//如果开始时间在过去，则schedule会表现出自从当前时间开始，scheduleAtFixedRate会把之前没有来得及执行的任务全都执行，感觉像之前一直有在执行一样。<br><span class="hljs-built_in">timer</span>.schedule(task, <span class="hljs-built_in">time</span>);<br><span class="hljs-built_in">timer</span>.schedule(task, <span class="hljs-built_in">delay</span>);<br>//如果<span class="hljs-built_in">time</span>时间为过去时间，则该任务会马上执行，如果为将来时间，则会等待时间到来再执行，如果传入的是<span class="hljs-built_in">delay</span>，则<span class="hljs-built_in">delay</span>不可以为负数，负数报错，正数代表未来的<span class="hljs-built_in">delay</span>毫秒以后执行。<br></code></pre></td></tr></table></figure><p>小结：</p><p>时间如果为过去时间，则所有schedule和scheduleAtFixedRate都会立即执行，并且schedule不会执行过去的任务，而scheduleAtFixedRate则会把过去的任务全都执行，即按照固定时间执行一样，isDaemon决定是否该Timer以守护线程存在。</p><p>timer.purge() 对实际的timer的任务执行不会有影响，它仅仅只会移除所有被取消的任务队列的引用以方便垃圾回收，只有任务数非常多（n + clogn）的时候，可以调用此方法以时间换取空间。</p><p>timer.cancel() 停止该timer，并且丢弃所有绑定的任务，但不干预当前正在执行的任务。一旦timer停止了，那么其执行线程将会优雅终止，并且该timer不可以再绑定task任务了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库错题积累</title>
    <link href="/2021/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    <url>/2021/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E9%A2%98%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<ol><li>数据库管理系统的主要功能有<strong>数据定义</strong>、<strong>数据库操纵功能</strong>、<strong>数据库的运行管理</strong>以及<strong>数据库的建立和维护</strong>等四个方面。</li><li>关系型数据库的数据结构是一种二维表结构。</li><li>一个数据库只有一个<strong>模式</strong>。</li><li>要保证数据库的数据独立性，需要修改的是<strong>三层模式之间的二级映像</strong>。</li><li>在关系数据库系统中，当关系的型改变时，用户程序也可以不变，这是数据的<strong>逻辑独立性</strong>。</li><li>在DBS中，最接近物理存储设备一级的结构，称为<strong>内模式</strong>。</li><li>数据库系统特点：数据结构化；数据<strong>冗余度低</strong>，实现了数据共享；数据独立性高；数据由DBMS统一管理和控制。</li><li>关系中不允许出现相同的元组。</li><li>若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值。</li><li>关系数据库中，实现实体之间的联系是通过表与表之间的公共属性。</li><li>在定义外码时，外码必须为一个表的主码。</li><li><strong>唯一值约束</strong>是属于关系完整性约束条件中的实体完整性。</li><li>在关系代数中，从两个关系的笛卡尔积中选取它们属性间满足一定条件的元组的操作，称为θ连接。</li><li>关系代数操作中有五种基本操作，它们是并、差、笛卡儿积、投影、选择。</li><li>由于关系模式设计不当所引起的异常指的是由于码值的一部分为空而不能将有用的信息作为一个元组插入到关系中。</li><li>若关系模式R中只包含两个属性，则R肯定属于BCNF，但是R不一定属于4NF。</li><li>关于BCNF的描述中：1.所有非主属性对每一个码都是完全函数依赖。2.所有的主属性对每一个不包含它的码，也是完全函数依赖。3.没有任何属性完全函数依赖于非码的任何一组属性。4.每一个决定因素都包含码。</li><li>下列关于规范化的描述，错误的是（规范化程度越高的关系模式就越好）</li><li>高一级范式真包含于低一级范式中，一个全码的关系一定属于BC范式，4范式不允许有非平凡且非函数依赖的多值依赖。</li><li>在关系模式R中，函数依赖X-&gt;Y的语义是（在R的一切可能关系中，若任意两个元组的X值相等，则Y值也相等）。</li><li>数据模型应满足（ D ）的要求。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>．真实模拟现实世界    <span class="hljs-selector-tag">B</span>．容易为人们所理解    C．便于在计算机上实现    D．以上都是<br></code></pre></td></tr></table></figure><ol><li><p>关系数据库的基本特征是不同的列应有不同的列名，与行的次序无关，与列的次序无关。</p></li><li><p>实现<strong>数据库安全性控制</strong>的常用方法和技术有（ A ）</p><p>A. 用户标识与鉴别、存取控制、视图机制、审计、数据加密</p></li><li><p>数据的（ 完整性 ）是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。数据的（ 安全性 ）是保护数据库防止恶意的破坏和非法的存取。</p></li><li><p>关系模型中，一个码是由多个属性组成，其值能够唯一标识关系中的一个元组。</p></li><li><p>下列<strong>不属于需求分析阶段工作</strong>的是：（ A ）。</p><p>A. <strong>建立E-R图</strong> B. 分析用户活动 C. 建立数据字典 D. 建立数据流图。</p></li><li><p>数据库系统的数据独立性体现在不会因为数据存储结构与数据逻辑结构的变化而影响应用程序。</p></li><li><p><strong>数据模型</strong>通常分为层次模型、（ <strong>网状模型</strong> ）、（ <strong>关系模型</strong> ）、面向对象模型和对象关系模型等。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库概念总结</title>
    <link href="/2021/05/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-数据库系统概述"><a href="#第一章-数据库系统概述" class="headerlink" title="第一章 数据库系统概述"></a>第一章 数据库系统概述</h1><ol><li><p>**数据：**数据（Data）是数据库中存储的基本对象，可以定义为：描述事物的符号记录。</p></li><li><p><strong>数据库：</strong>（DataBase，DB）是指长期存储在计算机内的、有组织的、可共享的大量数据集合。</p></li><li><p><strong>数据库管理系统：</strong>（DataBase Management System，DBMS）是位于用户与操作系统之间的一层数据管理软件。</p></li><li><p><strong>DBMS的功能：</strong>（1）数据定义功能、（2）数据操纵功能、（3）数据库的运行管理、（4）数据库的建立和维护功能。</p></li><li><p><strong>数据库系统：</strong>（DataBase System, DBS）是指在计算机系统中引入数据库后的系统，是由软件和硬件组成的完整系统。一般由数据库、数据库管理系统、计算机硬件和软件支撑环境、应用系统、数据库管理员和用户构成。</p></li><li><p>数据库中只能存储对象的数据模型。</p></li><li><p>**数据模型：**数据模型是对现实世界的抽象，将现实世界中有应用价值的数据及其关联抽象出来，并为DBMS所支持，最终在机器上实现。</p></li><li><p>现实世界、信息世界、计算机世界。<strong>现实世界</strong>设定了需求及边界条件，为整个转换提供了客观基础与初始启动环境。<strong>信息世界</strong>是现实世界在人脑中的反映，是对客观事物及其联系的一种抽象描述。信息世界由概念模型描述。<strong>计算机世界</strong>是信息世界中致力于在计算机物理结构上的描述。计算机世界将信息世界的概念模型数字化转换为数据模型，实现信息的数据化，便于计算机处理。</p></li><li><p>**概念模型：**是对现实世界的抽象表示，是现实世界到计算机世界的一个中间层次。</p></li><li><p>问题 –&gt; 概念模型 –&gt; 数据模型 现实世界 –&gt; 信息世界 –&gt; 计算机世界</p></li><li><p><strong>概念模型涉及的术语：</strong>（1）实体 （2）属性 （3）码 （4）域 （5）实体型（6）实体集（7）联系</p><p> （1） 实体：客观存在的、可以相互区别的事物或概念。例如：作者、书是具体的事物，出版社是抽象的概念。</p><p> （2） 属性：实体所具有的某一特性。</p><p> （3）码 ：能够唯一标识实体的属性集。</p><p> （4）域 ：属性的取值范围。</p><p> （5）实体型：具有相同属性的实体称为同型实体，用实体名及其属性名的集合来抽象和刻画同型实体，称为实体型。</p><p> （6）实体集：属于同一个实体型的实体集合。实体集是实体型的有限集合。</p><p> （7）联系：包括实体内部的联系和实体之间的联系。实体内部的联系指实体的各属性之间的联系，实体之间的联系指不同实体集 之间的联系。</p></li><li><p>数据模型的组成要素：数据结构、数据操作、完整性约束条件。</p><p>**数据结构：**数据结构主要描述数据类型、内容、性质的有关情况以及数据间的联系，是对系统静态特征的描述。通常按数据结构的类型来命名数据模型。</p><p>**数据操作：**数据操作主要描述在相应的数据结构上的操作类型与操作方式，是对系统动态行为的描述。数据库主要有检索和更新（包括插入、删除、修改）两大类操作。</p><p>**完整性约束条件：**完整性约束条件主要描述数据结构内数据间的语法、语义联系，它们之间的制约与依存关系，以及数据动态变化的规则，以此来保证数据的正确、有效与相容。数据模型应该反映和规定本数据模型必须遵守的、基本的通用的完整性约束条件。</p></li><li><p>数据库有类型之分，是根据数据模型划分的。层次模型、网状模型、关系模型、面向对象模型。</p></li><li><p>**关系模型：**基本元素包括关系、元组、属性、主码、域、分量以及关系模式等。</p><p> 关系：一个关系就是一张表。</p><p> 元组：表中的一行。</p><p> 属性：表中的一列。</p><p> 候选码：能够唯一确定一个元组的属性组，如商品编号。</p><p> 主码：关系中可能有多个候选码，选定其中一个作为主码。</p><p> 域：属性的取值范围。</p><p> 分量：元组中的一个属性值。</p><p> 关系模式：对关系的描述。</p><p> <strong>关系模型的特点：</strong>（1）在关系模型中，实体及实体间的联系都是用关系来表示。（2）关系模型要求关系必须是规范的，最基本的条件是，关系中的每一个分量必须是一个不可分的数据项，即不允许表中还有表。</p><p> **关系模型的完整性约束：**关系模型的完整性约束包括三大类：实体完整性、参照完整性和用户定义的完整性。</p><p> <strong>关系模型的优点：</strong>（1）具有数学基础（2）概念单一（3）存取路径透明</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**关系模型的缺点：**</span>查询效率低。<br></code></pre></td></tr></table></figure></li><li><p><strong>面向对象模型：</strong></p><p>优点：（1）适合处理各种各样的数据类型。（2）面向对象程序设计与数据库技术相结合。（3）提高开发效率。（4）改善数据访问。</p><p>缺点：（1）定义不准确。（2）维护困难。（3）不适合所有的应用。</p></li><li><p>从数据库管理系统角度看数据库系统内部的体系结构，通常采用三级模式结构。从数据库最终用户角度看数据库系统外部的体系结构，可以分为单用户结构、主从式结构、分布式结构和客户机&#x2F;服务器结构等。</p></li><li><p>数据库系统通常采用<strong>三级模式结构</strong>：外模式、模式、内模式。</p><p>外模式：又称子模式或用户模式，它是模式的子集，是数据的局部逻辑结构，也是数据库用户看到的数据视图。</p><p> 一个数据库可以有多个外模式，外模式是与某一应用有关的数据的逻辑表示，应用程序都是和外模式打交道。</p><p>模式：模式又称逻辑模式或概念模式，它是数据库中全体数据的全局逻辑结构和特征的描述，也是所有用户的公共数据视图。</p><p> 一个数据库只有一个模式。定义模式不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义与数据有关的安全性、完 整性要求。</p><p>内模式：又称存储模式，它是数据在数据库中的内部表示，即数据的物理结构和存储方式的描述。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">一个数据库只有一个内模式。<br></code></pre></td></tr></table></figure></li><li><p>三级模式之间的两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。</p><p> 外模式&#x2F;模式映像：模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式&#x2F;模式映像，它定义了该外模式与模式之间的对应关系。</p><p> 模式&#x2F;内模式映像：数据库中只有一个模式，也只有一个内模式，所以模式&#x2F;内模式映像是唯一的，它定义了数据库的全局逻辑结构与存储结构之间的对应关系。保证数据与程序之间的物理独立性。</p></li><li><p>数据库系统的外部体系结构：</p><p>1.单用户结构的数据库系统 2.主从式结构的数据库系统 3.分布式结构的数据库系统 4.客户机&#x2F;服务器结构的数据库系统 5.浏览器&#x2F;服务器结构的数据库系统</p></li><li><p>数据管理阶段：1.人工管理阶段 2.文件系统阶段3.数据库系统阶段</p></li></ol><h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><ol><li><p><strong>关系：</strong></p><p>域：域是一组具有相同数据类型的值的集合，可以理解为表格中的一个列的取值范围。</p><p>笛卡尔积中许多元组无实际意义，从中取出有实际意义的元组便构成关系。关系是笛卡儿积的子集，所以关系也是一个二维表，表的每一行对应一个元组，表的每一列对应一个域。</p><p>给域的每一列起一个名字，称为属性，n目关系必有n个属性。</p><p>关系中的每行是关系中的元组。</p><p>能唯一标识关系中一个元组的某一属性组，称为候选码。候选码不只一个，选定其中的一个作为主码。候选码的诸属性称为主属性，不属于候选码的属性称为非主属性。</p><p><strong>关系的性质：</strong></p><p> （1）关系中的每个属性值是不可分解的。</p><p> （2）表中各列取自同一个域，因此一列中的各个分量具有相同的性质。</p><p> （3）不同的列可以来自同一个域，其中的每一列为一个属性，不同的属性要给予不同的属性名。</p><p> （4）列的次序可以任意交换，不改变关系的实际意义。</p><p> （5）表中的行叫元组，代表一个实体，实体应该是可以区分的，因此表中不允许出现完全相同的两行。</p><p> （6）行的次序无关紧要，可以任意交换，不会改变关系的意义。</p></li><li><p><strong>关系模式：</strong></p><p>关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的。实际工作中，人们通常把关系模式和关系统称为关系。</p></li><li><p>关系数据库是基于关系模型的数据库。所有实体和实体之间的联系所形成的关系的集合就构成了一个关系数据库。在数据库中，关系模式是型，关系是值，两者通常统称为关系数据库。</p></li><li><p>关系模式的完整性规则是对关系的某种约束条件。关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</p><p> **实体完整性规则：**若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值。所谓空值就是指不能取“不存在”或“不知道”或“无意义”的值。</p><p> **参照完整性规则：**若属性F是基本关系R的外码，他与基本关系S的主码相对应，那么对于R中的每个元组中F的值，</p><p> **用户完整性规则：**针对某一具体的应用环境，给出关系数据库的约束条件，这些约束条件就是反映某一具体应用所涉及的数据必须满足的语义要求。</p></li><li><p>**关系代数：**关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。</p></li><li><p>传统的集合运算主要包括并、交、差、广义笛卡儿积四种运算。、</p><p> 并：**如果R和S都是关系，具有相同的目n，且相应的属性取自同一个域，**则R和S的并是由属于R或属于S的元组组成，其结果仍为n目关系。</p><p> 交：R和S的交是由既属于R又属于S的元组组成，其结果仍为n目关系。</p><p> 差：则R和S的差表示由属于R但不属于S的元组组成，其结果仍为n目关系。</p><p> 广义笛卡儿积：如果R和S都是关系，分别为m目和n目，则R和S的广义笛卡儿积是一个（n+m）列的元组的集合。</p></li><li><p>专门的关系运算包括选择、投影、连接、除等。</p><p> 选择运算：又称为限制运算。它是在关系R中选择满足条件的元组。选择运算是对单个关系R进行的运算，它将产生一个包含关系R 中部分元组的新关系。并且是从行的角度进行的运算。</p><p> 投影运算：也是对单个关系进行的运算，它将产生一个只有某些列的新关系。</p><p> 连接运算：选择和投影都是对单个关系进行的运算，在通常情况下，需要从两个关系中选择满足条件的元组数据，连接运算就是这 样的一种运算。连接运算又分为θ连接、等值连接和自然连接。</p><p> θ连接：是从行的角度进行运算。</p><p> 等值连接：θ为“&#x3D;”的连接运算称为等值运算。</p><p> 自然连接：可以说是一种特殊的等值连接，他要求两个关系进行比较的分量必须是相同的属性组，并且在结果中把重复的属 性列去掉，自然连接需要取消重复列，所以是同时从行和列的角度进行运算。</p><p> 除运算：是两个关系之前的运算。</p></li></ol><h1 id="第三章：SQL"><a href="#第三章：SQL" class="headerlink" title="第三章：SQL"></a>第三章：SQL</h1><ol><li><p>SQL（Structed Query Language，结构化查询语言）是操作关系数据库的通用语言。不只支持数据库查询操作，其功能还包括数据定义、数据操纵、数据控制等。</p></li><li><p>SQL的主要特点是：一体化、高度非过程化、语言简洁、多种使用方式。</p></li><li><p>SQL server数据库中的所有数据、对象和事务日志均以文件的形式保存，根据作用不同，这些文件可以分为数据文件与事务日志文件。</p></li><li><p>数据文件可根据数据存储需要进行组织，除了必需的一个主数据文件，还可以包括一个或多个次数据文件。</p></li><li><p>主数据文件用于存储数据库的系统表，数据库对象启动信息和数据库数据。所有数据库只能有一个主数据文件，其文件的拓展名为.mdf。次数据文件用于存储主数据文件中未存储的数据和数据对象。一个数据可以有一个或多个次数据文件，其文件扩展名为.ndf。</p></li><li><p>事务日志文件用于记录数据库的操作情况。每个数据库至少有一个事务日志文件，其文件扩展名为ldf。</p></li><li><p>一旦建立数据库文件，则在SQL Server资源管理器目录菜单中就会显示该数据库对象及其包含的数据表、视图等子项。</p></li><li><p>创建数据库时，SQLserver首先将系统数据库model的内容复制到新数据库中，然后使用空页填充新数据库的剩余部分。model数据库中的对象均被复制到新数据库中，其数据库选项也被新数据库继承。</p></li><li><p>表是关系数据库中的基本对象，关系数据库的数据均存储在表中。在关系数据库中，每个关系都对应一个表，一个数据库包含一个或多个表。其他的对象，如视图、索引等均依附于表存在。</p></li><li><p>在定义表的时候，需要指明每个列之间的数据类型。数据的类型决定了数据表中存储数据的存储空间和对这些数据能进行的运算，存储空间决定了数据的存储范围和精度。</p></li><li><p><strong>数据库的完整性是指数据的正确性与相容性</strong>。前者要求数据符合现实语义、反映实际情况，后者要求在不同的关系中的相关数据符合逻辑。</p></li><li><p>列级约束、元组约束、关系约束。列级约束是指某列的约束，例如该列的范围，元组约束是指元组中各字段之间联系的约束，关系约束是指关系之间联系的约束。</p></li><li><p>实体完整性要求表中每条记录必须唯一，也不能为空。为保证实体完整性，每个表需指定一个属性或属性组合作为他的主码。一个表只能设置一个主码。</p></li><li><p>用户自定义完整性是指用户根据业务逻辑定义约束规则，防止数据库出现不符合逻辑的数据。一个列只能有一个DEFAULT约束，该约束也只能定义在一个列上，在插入数据时，数据库系统会检查DEFAULT约束，不输入新值的情况下，系统会使用默认值填充。</p></li><li><p>参照完整性属于表间规则，若主码和外码来自同一个表，则称为自参照完整性，只要依赖于某主码的外码值存在，该表中的该主码的值就不能随意的修改和删除，除非设置了级联删除和修改。</p></li><li><p>外码约束是参照完整性的具体的执行方式，参照表–外码表；被参照表–主码表。主码表被引用的属性必须是候选码或主码。</p></li><li><p>完整性约束维护主要是修改和删除约束。修改约束可以先删除约束，再添加同名约束。</p></li><li><p>索引是提高查询速度的重要手段。数据库索引包含来自基本表属性的组成的索引关键字和对应的各行数据的存储位置。索引表本身就会占用用户的数据库空间，在对数据进行插入、更新、删除的时候，维护索引也会增加时间成本。</p></li><li><p>聚集索引、非聚集索引、唯一索引。聚集索引是指表中的数据按照索引关键字的顺序在磁盘进行重新存储。因为一个表的数据只能根据一种物理顺序存储，所以一张表只能有一个聚集索引。</p></li><li><p>非聚集索引则要求数据表的数据按照索引关键字的顺序排序，表的物理顺序与索引关键字顺序不同。<em>一个表上可以有多个非聚集索引。</em></p></li><li><p>唯一索引的索引关键字不允许重复。如果在student表的sname字段上建立了唯一索引，则sname的值不允许重复。聚集索引和非聚集索引都可以是唯一索引。</p></li><li><p><strong>主码约束</strong>其实是一种索引，UNIQUE约束默认为非聚集唯一约束。索引一经建立，就由数据库系统维护，无须用户参与。</p></li><li><p><strong>单表查询</strong>是指from子句后面的数据表只有一张的查询。</p></li><li><p>使用distinct关键字可以去掉结果集中重复的行。</p></li><li><p>查询中文在XX和XX之间的信息按字符的拼音字母先后排序。谓词IN用来查找属性值属于指定集合的元组。</p></li><li><p>使用连接符AND和OR可以连接多个查询条件。多个运算符的执行顺序是从左往右，AND的运算级别高于OR，用户可以使用小括号改变优先级。</p></li><li><p>查询结果可以按照ORDER BY子句指定升序或降序排列，默认为升序。</p></li><li><p>ORDER BY子句后也可以跟多个字段，先按第一个字段的顺序排列，如果第一个字段的排序结果相同，则按第二个字段顺序排列。</p></li><li><p>ORDER BY子句后也可以跟表达式、函数等。</p></li><li><p>SQL使用GROUP BY 子句对元组进行分组。</p></li><li><p>内连接是一种常见的查询方式。内连接包括非等值连接、等值连接。等值连接的连接字段如果一样，去掉重复的列，就是自然连接。如果连接的是两个相同的表，就是自连接。</p></li><li><p><strong>等值连接</strong> 比较运算符为等号的连接称为等值连接，不为等号时是非等值连接。</p></li><li><p>为简化代码，可以为连接表指定别名，一旦指定别名后，查询语句中相应的表都要用该别名替代。</p></li><li><p>内连接包括等值连接、自连接两种，比较运算符为等号的连接称为等值连接，不为等号时为非等值连接。自连接将同一张表进行连接。</p></li><li><p><strong>内连接</strong>将满足连接条件的元组连接起来形成结果集元组，但有时用户需要将不满足连接条件的元组也显示在结果集中，例如查看哪些商品没有人买。外连接包括全外连接，左外连接，和右外连接。</p></li><li><p><strong>全外连接</strong>是将参与连接的表中不满足连接条件的元组均显示出来，无对应连接元组值使用NULL填充。</p></li><li><p><strong>左外连接</strong>使用LEFT JOIN…ON语句连接。左边表的元组不管满不满足连接条件均显示，右边表不满足连接条件的不显示。</p></li><li><p><strong>右外连接</strong>使用RIGHT JOIN…ON语句连接，右边表的元组不管满不满足连接条件均显示，左边表不满足连接条件的不显示。</p></li><li><p><strong>子查询</strong>：子查询就是嵌套在另一个查询语句中的查询语句，因此，子查询也叫嵌套查询。包含子查询的查询通常称为外层查询。</p></li><li><p><strong>不相关子查询</strong>是指内层查询条件不依赖于外层查询。即单独执行内层语句也会得到明确结果集。</p></li><li><p><strong>相关子查询</strong>：如果子查询内层查询的查询条件依赖于外层查询，则被称为相关子查询。</p></li><li><p>**集合查询：**并操作UNION、交操作INTERSECT、和差操作EXCEPT。参加集合操作的列数需相等，对应列的数据类型需相同。</p></li><li><p><strong>基于派生表查询</strong>：当子查询出现在FROM子句中时，子查询的查询结果形成一个临时的派生表，这个表可以作为查询对象。</p></li><li><p>**数据更改：**包括插入数据、修改数据和删除表中数据。INSERT语句插入数据，通常有两种形式。一种是插入元组，另一种是插入子查询结果。</p></li><li><p>DELETE删除表中的数据，DROP删除表中结构。</p></li><li><p>视图是数据库中的常用对象之一，它的内容是数据库部分数据或以聚合等方式重构的数据。在数据库中只存放视图的定义，不存放视图的数据，这些数据仍在原数据表中。只有执行视图查询的时候，这些数据才出现在结果集中，因为不存储数据，所以视图与基本表不同，是一个虚表。</p></li><li><p>定义视图时，语句WITH CHECK OPTION表示通过视图进行更新操作时要保证更新的数据满足子查询的条件表达式。</p></li><li><p>视图可以定义在已经定义的视图上，也可以建立在表与视图的连接上。</p></li><li><p>更新视图是通过视图来插入、删除、修改数据。由于视图不存储数据，通过视图更新数据最终要转换为对基本表的更新。</p></li><li><p>视图的好处:</p><p> 1.简化数据查询。</p><p> 2.使用户多角度看待同一数据。</p><p> 3.提供一定程度的逻辑独立性。</p><p> 4.提供数据库安全性。</p></li></ol><h1 id="第六章：关系数据理论"><a href="#第六章：关系数据理论" class="headerlink" title="第六章：关系数据理论"></a>第六章：关系数据理论</h1><ol><li><strong>关系数据库</strong>是以<strong>关系模型</strong>为基础的数据库，他利用关系来<strong>描述现实世界</strong>，一个关系既可以用来<strong>描述一个实体及其属性</strong>，又可以用来<strong>描述实体间的联系</strong>。<strong>关系模式是用来定义关系</strong>的，一个关系数据库包含一组关系。定义这些关系的关系模式的全体就构成了该数据库的模式。</li><li>关系实质上是一张二维表。表的每一行叫做一个元组，每一列叫做一个属性，因此，一个元组就是该关系所涉及的属性级的笛卡尔积的一个元素。关系是元组的集合。也就是笛卡尔积的一个子集。<strong>关系模式</strong>就是这个元组集合的结构上的描述。</li><li>一个<strong>关系模式</strong>应当是一个五元组。</li><li>在本章中，当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。</li><li><strong>关系</strong>：每一个分量必须是不可分的数据项。满足这个条件的关系模式就属于第一范式（1NF）。</li><li>**数据依赖：**现实系统中数据间的语义，需要通过完整性来维护。不仅如此，数据间的语义，还会对关系模式的设计产生影响。这种数据语义在关系模式中的具体表现就是数据依赖。</li><li>**数据依赖：**就是通过一种关系中属性间值的相等与否体现出来的数据间的相互关系，它是现实世界属性间的相互关联的抽象，是数据内在的性质，是语义的体现。</li><li>数据依赖有很多种，其中最常用是<strong>函数依赖和多值依赖</strong>。</li><li><strong>函数依赖存在的问题</strong>：1.数据冗余 2.更新异常，包括插入异常、更新异常、删除异常。</li><li>为什么会出现异常现象呢？这是由于关系模式中属性间<em>存在的这些复杂的依赖关系。</em></li><li>解决数据间的依赖关系常常采用对关系的分解来消除不合理的部分，从而设计出合理的管理模式。</li><li><strong>函数依赖</strong>不是指关系模式R中的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。</li><li>在关系模式R（U）中，对于U的子集X和Y，如果X-&gt;Y,但Y不含于X，则称X-&gt;Y是<strong>非平凡函数依赖</strong>；若X-&gt;Y,但是Y含于X，则称X-&gt;Y是<strong>平凡函数依赖</strong>。</li><li>在关系模式R(U)中,如果X-&gt;Y,并且对于X的任何一个真子集X‘，都有Y不依赖于X’,则称Y<strong>完全函数依赖</strong>于X，记作X F–&gt;Y。若X–&gt;Y,但是Y不完全函数依赖于X，则称Y<strong>部分函数依赖</strong>于X，记作X–P&gt;Y。</li><li>在关系模式R(U)中,如果X-&gt;Y,Y-&gt;Z,且Y不含于X，Y-&gt;X,则称Z传递函数依赖于X，记作X–传递&gt;Z。</li><li>如果Y-&gt;X,即X&lt;—&gt;Y,则Z直接依赖于X。</li><li>设K为R（U,F）中的属性或属性组合。若K–F&gt;U,则K为R的候选码。若候选码多于一个，则选定其中的一个作为主码。</li><li><strong>候选码</strong>可以唯一的识别关系的元组。</li><li>一个关系模式可能具有多个<strong>候选码</strong>，可以指定一个候选码作为<strong>识别关系元组的主码</strong>。</li><li>包含在任何一个候选码中的属性，叫做<strong>主属性</strong>，不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。最简单的情况下，候选码<strong>只包含一个属性</strong>。最复杂的情况下，候选码包含关系模式的所有属性，称为<strong>全码</strong>。</li><li>范式可以理解为某一种级别的关系模式的集合。</li><li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程叫做<strong>规范化</strong>。</li><li>规范化的过程实质上就是将关系模式简单化的过程。以减少关系模式出现更新异常的问题。</li><li><strong>第一范式</strong>：如果一个关系模式R的所有属性都是不可分的基本数据项。则R是第一范式。满足第一范式的关系称为规范化关系。</li><li>**第二范式：**若关系模式R属于第一范式，且每一个非主属性都完全函数依赖于码，则称R为第二范式，简称2NF。由第一范式向第二范式转换的方法是，消除其中的部分函数依赖，一般是将一个关系模式分解成多个2NF的关系模式。即将部分函数依赖于码的非主属性及其决定属性移除。另外形成一个关系。</li><li>**第三范式：**如果关系R为2NF，并且R中的每一个非主属性都不传递依赖于R的候选码，则称R为第三范式。简称3NF。如果R中只包含两个属性，则R一定属于第三范式，因为它不可能存在非主属性对码的传递函数依赖。第二范式向第三范式转换就是消除非主属性对码的传递函数依赖。</li><li>**BC范式：**如果关系R为1NF，并且R中不存在任何属性对码的部分依赖和函数依赖。那么称R为BCNF。</li><li>BC范式的特性：所有非主属性对每一个码都是完全函数依赖，所有的主属性对每一个不包含它的码，也是完全函数依赖，没有任何属性完全函数依赖于非码的任何一组属性。第三范式不一定是BC范式，BC范式一定是第三范式。3NF向BC范式关系转换，就是要消除主属性对码的部分和传递函数依赖。</li></ol><h1 id="第七章：数据库设计"><a href="#第七章：数据库设计" class="headerlink" title="第七章：数据库设计"></a>第七章：数据库设计</h1><ol><li><p>数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效的存储数据，满足各种用户的应用需求（信息要求和处理要求）。在数据库领域内，常常把使用数据库的各类系统统称为数据库应用系统。</p></li><li><p>设计方法是指设计数据库所使用的理论和步骤。数据库设计方法目前可分为三类：直观设计法、规范设计法、计算机辅助设计法。</p></li><li><p>数据库的设计可划分为六个阶段：需求分析阶段、概念结构设计阶段、逻辑结构设计阶段、物理结构设计阶段、数据库实施阶段、数据库运行和维护阶段。</p></li><li><p>数据库设计的特点：</p><p> 1.数据库设计是涉及多学科的综合技术。</p><p> 2.数据库设计是硬件、软件和干件的的结合。</p><p> 3.数据库设计具有反复性、试探性，应分步进行。</p><p> 4.数据库设计需要将结构设计和行为设计密切结合。</p></li><li><p>**数据字典（Data Dictionary，DD）：**是各类数据描述的集合。对数据库设计来讲，数据字典是进行详细的数据收集和数据分析所获得的结果。数据字典通常包括数据项、数据结构、数据流、数据存储和处理过程五个部分。数据项是数据的最小的组成单位，若干数据项可以组成数据结构，数据字典通过对数据项和数据结构的定义来描述数据流、数据存储和处理过程的逻辑内容。</p><p> 1.数据项：数据项是不可再分的数据单位。数据项描述&#x3D;{数据项编号，数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系}，其中逻辑范围、与其他数据项的逻辑关系定义了数据的完整性约束条件，是设计数据检验功能的依据。</p><p> 2.数据结构：数据结构反映了数据间的组合关系。它可以是由若干个数据项构成，也可以是由若干个数据结构组成，或者由若干数据项和数据结构混合组成。数据结构描述&#x3D;{数据结构编号，数据结构名称，含义说明，组成：{数据项名或数据结构名}}</p><p> 3.数据流：数据流是数据结构在系统内的传输途径，表示某一处理过程的输入或输出。数据流描述&#x3D;{数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}。</p><p> 4.数据存储：数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。数据存储描述&#x3D;{数据存储名，说明，编号，流入的数据流，流出的数据流，组成：{数据结构}，数据量，存取方式}。</p><p> 5.处理过程：处理过程描述业务处理的处理逻辑和输入、输出。具体的处理逻辑一般用判定表或判定树来描述。处理过程描述&#x3D;{处理过程编号，处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}，其中简要说明中主要说明该处理过程的功能及处理要求。功能是指该处理过程用来做什么。</p></li><li><p>系统分析和数据库设计人员是数据库设计的核心人员。</p></li><li><p>用户和数据库管理员在数据库设计中也是举足轻重的，他们主要参加需求分析和数据库的运行维护。程序员则在系统实施阶段参与进来，分别负责编制程序和准备软硬件环境。</p></li><li><p>目前，数据库设计人员使用最为广泛的仍然是以逻辑数据库设计和物理数据库设计为核心的规范设计方法。按照这种规范设计方法以及数据库应用系统的开发过程，数据库的设计可以划分为六个阶段：需求分析阶段，概念结构设计阶段，逻辑结构设计阶段，物理结构设计阶段，数据库实施阶段，数据库运行和维护阶段。</p></li><li><p><strong>需求分析阶段</strong>是指收集和分析组织内将由数据库应用程序支持的那部分信息，并用这些信息确定新系统中用户的需求。<strong>概念结构设计阶段</strong>就是对用户需求进行综合、归纳与抽象，建立一个独立于具体的DBMS并且与所有物理因素均无关的企业信息模型的过程，是整个数据库设计的关键。<strong>逻辑结构设计阶段</strong>的目的是将概念设计阶段设计好的全局ER模型转换成与选用的DBMS所支持的数据模型，并对其进行优化。<strong>物理结构设计阶段</strong>是为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。<strong>数据库实施阶段</strong>，数据库物理设计是面向特定的DBMS系统，所以在进行物理设计时，必须首先确定使用的数据库系统。</p></li><li><p>收集了需求信息之后，对调研阶段所获得的需求信息进行分析的过程叫做需求分析。</p></li><li><p>业务是企业、组织为实现自身目标、职能的一系列有序的活动过程。业务分析就是对上述各种流动及其交织过程的详细分析过程。数据是信息的载体，是数据库存储的主要对象。数据分析就是把数据在组织内部的业务流动情况，以数据流动的方式抽象出来，从数据流动过程来分析业务系统的数据处理模式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 确定业务：首先确定企业、组织中包含哪些业务，判断业务的标准是：是否为实现组织目标的有序活动过程。<br><span class="hljs-bullet">2.</span> 业务流程分析：业务流程是业务的活动过程，是指企业或组织为完成某一项目标或任务，而进行的跨时间或空间并在逻辑上相关的一系列活动的有序集合。<br><span class="hljs-bullet">3.</span> 业务规则分析：业务规则是保证业务能够正常运转的一致性和相关性的必须被遵守的约束性条件。<br><span class="hljs-bullet">4.</span> 数据流程分析，数据流程分析就是在业务流程分析的基础上，舍去物化因素、重点发现和解决数据流动过程中的问题，比如数据流程不畅、前后数据不匹配以及数据处理过程不合理等等。<br></code></pre></td></tr></table></figure></li><li><p>业务及数据分析的具体过程可以用业务流程图和数据流程图来表达。</p></li><li><p>概念结构设计：概念模型是现实世界和机器世界的中介，既独立于数据库的逻辑结构，也独立于某一数据库管理系统（DBMS）。</p><ol><li>概念模型是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定。</li><li>用ER图来描述现实世界的概念模型，规则：<ol><li>实体：用矩形表示，矩形框内写明实体名。</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体连接起来。</li><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型。联系本身也是一种实体，也可以有属性。如果一个联系具有属性，那这些属性也要用无向边与该联系连接起来。</li><li>概念结构设计的方法和步骤：自顶向下方法、自底向上方法、逐步扩张方法、混合策略方法。</li><li>概念模型设计分三步来完成：进行数据抽象，设计局部视图；将局部视图综合成全局视图及全局概念模型。分类、聚集、概括。</li><li>超类相当于父类。</li><li>决定一个对象是否作为属性对待，（1）作为属性，不能再具有需要描述的性质。即属性不能是另一些属性的聚集。（2）属性不能与其他实体具有联系，即E-R图中的联系是实体之间的联系。</li><li>视图集成：视图集成可分为一次集成方法和逐步集成方法。视图集成一般分两步走：第一步是合并，即将各分ER图合并生成初步ER图，第二步是修改和重构。即消除初步ER图中不必要的冗余，生成基本的ER图。</li><li>各分ER图之间的冲突分为三类：属性冲突、命名冲突和结构冲突。<ol><li>属性冲突：属性域冲突，即属性值的类型、取值范围或取值集合的不同。也有可能是属性取值单位冲突。</li><li>命名冲突：同名异义或异义同名。</li><li>结构冲突：<ol><li>同一对象在不同应用中具有的不同抽象。解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。</li><li>同一实体在不同的分ER图中属性组成不同，包括属性个数、次序。解决方法：使该实体的属性取各分ER图中属性的并集，再适当调整属性的次序。</li><li>实体之间的联系在不同的分ER图中呈现不同的类型。</li></ol></li></ol></li><li>视图集成的目的：不在于把若干分ER图形式上合并为一个ER图，而在于消除冲突使之成为能够被全系统中所有用户共同理解和接受的统一的概念模型。</li><li>消除视图冗余的方法主要有分析法和规范化理论方法。</li><li>**评审：**评审分为用户评审和DBA及开发人员评审两部分。</li><li>逻辑结构设计<ol><li>逻辑结构设计的任务就是把概念模型转换为基于特定数据模型但独立于特定DBMS和其他物理条件的企业信息模型的过程。这些模型在功能上、完整性上和一致性约束及数据库的可扩展性等方面均应满足用户的各种需求。</li><li>逻辑模型设计分三步：（1）把概念模型向一般的关系、网状、层次模型转换（2）对数据模型进行优化（3）设计用户子模式。</li><li>概念模型向关系模型的转换：将ER图转换为关系模型实际上就要将概念设计中所得到的ER图的实体和实体间的联系转换成关系的属性。<ol><li>一个实体转换成一个关系模式，实体的属性就是关系的属性，实体的码就是关系的码。</li><li>一个1：1的联系可以转换成一个独立的关系模式，也可以与任意一端的关系模式合并。如果转换成一个独立的关系模式，则与该关系相连的各实体的码以及联系本身的属性均转换为关系的属性。</li><li>一个1：n联系可以转换成一个独立的关系模式，也可以与n端对应的关系模式合并，如果转换成一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。</li><li>一个m：n联系转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体的码共同组成该关系模式的码。</li><li>三个或三个以上的实体间的一个多元联系可以转换为一个关系模式，与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，关系的码为诸实体码的组合。</li><li>具有相同码的关系模式可以合并。</li></ol></li></ol></li><li>关系模型的优化：从ER图转换而来的关系模式还只是逻辑模式的初步形式，而且数据库逻辑设计结果也不是唯一的。<ol><li>确定数据依赖。</li><li>对于各个关系模式之间的数据依赖进行极小化的处理，消除冗余的联系。</li><li>考察是否存在部分函数依赖，传递函数依赖，多值依赖等，确定各关系模式分别属于第几范式。</li><li>按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否适合，确定是否要对他们进行合并或分解。同时，需要注意：<em>并不是规范化程度越高的关系就越优，需要同时考虑时间效率，需要权衡响应时间和潜在问题两者的利弊。</em></li><li>对关系模式进行必要的合并和分解。<ol><li>对于多个关系模式具有相同的主码，并且对这些关系模式的处理主要是多关系的查询操作，则可对这些关系模式按照组合使用频率进行合并。</li><li>关系模式的分解可分为水平分解和垂直分解。<ol><li>水平分解是把关系模式按分类查询的条件分解成几个关系模式，这样可以减少应用系统每次查询需要访问的记录次数，从而提高查询效率。</li><li>垂直分解是把关系模式中经常一起使用的属性分解出来，形成一个子关系模式。</li></ol></li></ol></li></ol></li><li><strong>用户子模式设计</strong>：根据用户需求设计了局部应用视图，并将局部应用视图进行集成后形成了数据库应用系统的概念模型，用ER图表示。在将概念模型转换为逻辑模型后，即生成了整个应用系统的模式后，还应该根据局部应用需求，结合具体DBMS的特点，设计用户的外模式，外模式的设计也是逻辑设计的一部分。</li><li>**物理结构设计：**逻辑结构设计阶段完全独立于数据库的实现细节，如目标DBMS的特定功能和应用程序，但依赖于目标数据模型。</li><li>如果说逻辑数据库设计关注于”是什么”，那么物理数据库设计则关注于”怎么做”，数据库物理设计者必须知道计算机系统怎么处理DBMS操作，并需要对目标DBMS的功能有充分的了解。所以数据库的物理结构设计就是对于一个给定的逻辑数据模型选取一个最合适的应用环境的物理结构的过程，包括存储结构，存储方法以及为实现数据高效访问而建立的索引和任何完整性约束、安全策略等。</li><li>数据库的物理结构设计分为三步:<ol><li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。</li><li>对物理结构进行评价，评价的重点是时间和空间效率。</li><li>撰写物理设计说明书和相关文档。</li></ol></li><li>确定数据库的物理结构：<ol><li>数据库的物理结构主要是指数据库的存储记录格式、存储记录安排和存取方法。</li><li>数据库物理结构设计的主要目的之一就是高效的存取数据。</li><li>度量数据库存储效率的常用参数有事务吞吐量、响应时间和磁盘存储空间等。</li><li>物理结构设计的主要内容包括存储记录的结构设计、确定数据的存放位置、存取方法的设计、确定系统配置等。</li></ol></li><li>物理结构设计：<ol><li>存储记录的结构设计</li><li>确定数据的存放位置</li><li>存取方法的设计：数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的各种应用要求。数据库常用的存储方法有三类：索引方法、聚簇方法和Hash方法。</li><li>聚簇存取方法的选择：所谓聚簇就是把有关的元组集中在一个物理块内或物理上相邻的区域，以提高对某些数据的访问速度。<ol><li>建立聚簇索引的要求：当应用中主要是通过聚簇键进行访问或连接时。</li><li>对应每个聚簇键值平均元组数适当的情况。如果太少，簇集的效益不明显，甚至浪费空间；如果太多，需采用多个连接块，同样不利于提高性能。</li><li>聚簇键值应相对稳定，以减少修改簇集键所引起的维护开销。<ol><li>聚簇只能提高某些应用的性能，而且建立与维护聚簇的开销是相当大的。对已有关系建立聚簇，将导致关系中元组移动其物理存储位置，并使此关系上原有的索引无效，必须重建。当一个元组的聚簇码值改变时，该元组的存储位置也要做相应的移动，聚簇码值要相对稳定，以减少修改聚簇码值所引起的维护开销。</li></ol></li></ol></li><li>Hash存取方法的选择：Hash存取方法是使用散列函数根据记录的一个或多个字段的值来计算存放记录的页地址。<ol><li>存储使用Hash存储方法的规则：如果一个关系的属性主要出现在等值连接条件中或主要出现在相等比较选择条件中，而且满足下列两个条件之一，则此关系可以选择Hash存取方法。<ol><li>如果一个关系的大小可预知，而且不变。</li><li>如果关系的大小动态改变，而且数据库管理系统提供了动态的Hash存取方法。</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python错题笔记</title>
    <link href="/2021/05/22/Python%E9%94%99%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/05/22/Python%E9%94%99%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>1.优先级顺序是NOT、AND、OR。</p><p>2.None为false。</p><p>3.for和while语句都可以有else语句。</p><p>4.迭代输出序列时（如列表）使用for比while更好。</p><p>5.break语句用于终止当前循环。continue语句用于跳过当前剩余要执行的代码，执行下一次循环。break和continue语句通常与if，if…else和if…elif…else语句一起使用。</p><p>6.pass不做任何事情，一般用作占位语句。</p><p>7.函数是一段代码用于执行特定的任务。</p><p>8.如果函数没有使用return语句，则函数返回的是None对象。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs leaf">def greetPerson(*name):<br>    print(&#x27;Hello&#x27;, name)<br>  <br>greetPerson(&#x27;Runoob&#x27;, &#x27;Google&#x27;)<br><span class="hljs-punctuation">#</span><span class="hljs-keyword">Hello</span><span class="hljs-params">(&#x27;<span class="hljs-variable">Runoob</span>&#x27;,&#x27;<span class="hljs-variable">Google</span>&#x27;)</span><br></code></pre></td></tr></table></figure><p>9.加了星号*的参数会以元组（tuple）的形式导入，存放所有未命名的变量参数。</p><p>10.递归函数用于调用函数本身。</p><p>11.在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><p>12.lambda定义了一个匿名函数，lambda并不会带来程序效率的提高，只会使代码更简洁。如果可以使用for…in…if来完成，坚决不用lambda。如果使用lambda，lambda内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。</p><p>13.lambda是为了减少单行函数的定义而存在的。</p><p>14.如果我们需要从math模块中输出pi常量，那么</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">from <span class="hljs-built_in">math</span> import <span class="hljs-built_in">pi</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pi</span>)<br></code></pre></td></tr></table></figure><p>15.所有对象都可以用于布尔测试。</p><p>16.空字符串和空列表对象的布尔值是false。值为零的任何数字对象的布尔值是false。</p><p>17.python不支持的数据类型是char。</p><p>18.关于python中的复数，实部和虚部都是浮点数，虚部的后缀是j，也可以是J。方法conjugate返回复数的共轭复数。</p><p>19.在三引号字符串中可以包含换行回车等特殊字符。</p><p>20.python字符串是一个定长的字符数组，通过下标控制长度，没有结束标识。</p><p>21.字典中的元素只能用不可变的数据类型。</p><p>22.min &#x3D; x if x &lt; y else y</p><p>23.计算机中信息处理和信息储存用二进制代码</p><p>24.python源程序执行的方式为解析执行</p><p>25.python语言语句块的标记是缩进。</p><p>26.字符转换为字节的方法是encode()。</p><p>27.”ab”+”c”*2的结果为abcc</p><p>28.decode()方法以encoding指定的编码格式解码字符串。默认编码为字符串编码。该方法返回解码后的字符串。</p><p>29.python中的find()方法检测字符串中是否包含字符串str，如果指定beg（开始）和结束（end）范围，则检查是否包含在指定范围内，如果包含子字符串，返回开始的索引值，否则返回-1，str.find(str,beg&#x3D;0,end&#x3D;len(string))。</p><p>30.count()方法用于统计字符串里某个字符出现的次数。</p><p>31.find()方法检测字符串中是否包含子字符串str，如果包含子字符串返回开始的索引值，否则返回-1。index()方法检测字符串中是否包含子字符串str，如果str不在，会报一个异常。</p><p>32.final不是python中的关键字</p><p>33.类中默认含有__dir__()方法和__hash__()…</p><p>34.定义类如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,name</span>)<br><span class="hljs-variable language_">self</span>.name=name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">showInfo</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>)<br>print(<span class="hljs-variable language_">self</span>.name)<br></code></pre></td></tr></table></figure><p>下面代码能正确执行的是（C）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">A<span class="hljs-selector-class">.h</span> = Hello  h<span class="hljs-selector-class">.showInfo</span>()<br>B<span class="hljs-selector-class">.h</span> = <span class="hljs-built_in">Hello</span>() h<span class="hljs-selector-class">.showInfo</span>(‘张三’)<br>C<span class="hljs-selector-class">.h</span> = <span class="hljs-built_in">Hello</span>(‘张三’) h<span class="hljs-selector-class">.showInfo</span>()<br>D<span class="hljs-selector-class">.h</span> = <span class="hljs-built_in">Hello</span>(‘admin’) showInfo<br></code></pre></td></tr></table></figure><ol start="35"><li></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    def a():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>():<br>    def b():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>():<br>    def c():<br>        <span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(A,C):<br>    def d():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;d&quot;</span>)<br><br>d = D()<br>d.a()<br>d.b()<br>d.d()<br><span class="hljs-comment">#上面代码执行会报错</span><br><span class="hljs-comment">#d takes 0 positional arguments but 1 was given</span><br><span class="hljs-comment">#这是因为每个与类相关联的方法调用都自动传递实参self，他是一个指向实例本身的引用，让实例能够访问类中的属性和方法</span><br></code></pre></td></tr></table></figure><p>36.拼写错误、错误表达式、缩进错误python表达式都不能正常启动，但是手动抛出异常可以正常启动</p><p>37.程序中抛出异常不一定终止程序，程序捕获异常后会继续执行异常之后的程序。</p><p>38.import m from mo的语法错误</p><p>39.一个xx.py就是一个模块，任何一个普通的xx.py文件可以作为模块导入，模块的扩展名一定是.py，运行会从制定的目录搜索导入的模块，如果没有，会报错异常。</p><p>40.下面代码的运行结果是什么？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span> (<span class="hljs-variable language_">self</span>):<br>        pass<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(__name__)<br>p=<span class="hljs-title class_">Person</span>()<br>p.getAge()<br></code></pre></td></tr></table></figure><p>A、Person<br>B、getAge<br>C、usr.lib.python.person<br>D、–main– 答案<br>E、Anexception is thrown</p><ol start="41"><li></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;hello&#x27;</span>,[1,2,3]</span>]<br>b=<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[:]</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[0]</span>=<span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.append</span>(<span class="hljs-number">4</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b)</span></span><br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;hello&#x27;</span>, [1, 2, 3, 4]</span>]<br></code></pre></td></tr></table></figure><p>列表a中有两个元素hello和[1,2,3,4]</p><p>列表b拷贝了列表a，列表b中也有两个元素’hello’和[1,2,3,4]列表</p><p>列表a，b中的元素的内存地址是一样的</p><p>列表a，b是两个对象，这两个对象的数据类型是列表，有自己的内存地址。</p><p>列表中的两个元素也是对象，有自己的数据类型，分别是字符串和列表，也就是自己的内存地址。</p><p>字符串不可变，所以答案是</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;hello</span>&#x27;, [<span class="hljs-name">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br></code></pre></td></tr></table></figure><p>42.不可变数据：Number（数字），String（字符串），Tuple（元组）</p><p>可变数据：List（列表），Dictionary（字典），Set（集合）</p><p>43.Python变量名区分大小写，所以student，Student不是同一个变量。</p><p>44.str()是python的内置函数，这个例子是把列表&#x2F;元组&#x2F;字符串的每个元素变成了str类型，然后以列表的形式返回。</p><p>45.什么是lambda函数？它有什么作用？</p><p>不需要定义函数名称，匿名函数，只做简单运算，并返回值，没有复杂的函数体。</p><p>46.python中包含多少关键字？</p><p>36个关键字</p><ol start="47"><li></li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">A</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">B</span>():<br>        print(x)<br>    <span class="hljs-keyword">return</span> B<br>A(<span class="hljs-number">7</span>)()<br><span class="hljs-comment">#7</span><br></code></pre></td></tr></table></figure><p>当一个嵌套函数在其外部区域引用了一个值，该嵌套函数就是一个闭包。其意义就是会记录这个值。</p><p>48.python中包含7种运算符，算术运算符、关系运算符、赋值运算符、逻辑运算符、位运算符、成员运算符、身份运算符。</p><p>49.两种不同数据类型的数据不能被拼接</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;好好学习，天天向上&quot;</span>+8)<br><span class="hljs-comment">#这个会报错</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;好好学习，天天向上&quot;</span><span class="hljs-number">*8</span>)<br><span class="hljs-comment">#这个就不会报错，会打印八次</span><br></code></pre></td></tr></table></figure><p>50.如果我想在一个字符串中嵌入一个双引号，正确的做法是：</p><p>有两种做法，第一种可以使用反斜杠（\）对双引号转义，或者使用单引号引起这个字符串。</p><ol start="51"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">r&quot;\nwoow&quot;</span>)<br></code></pre></td></tr></table></figure><p>这个的打印结果是 \nwoow</p><p>python中字符串的前导r代表原始字符串标识符，该字符串中的特殊符号不会被转义，适用于正则表达式中繁杂的特殊符号表示。</p><p>52.x&#x3D;(y&#x3D;z+1) 并不适用于python，等号右边不能是赋值语句。</p><p>53.isinstance（）函数用来判断一个对象是否是一个已知类型，类似type（）。</p><p>但是type（）不会认为子类是一种父类类型，不考虑继承关系，isinstance（）会认为子类是一种父类类型，考虑继承关系。</p><p>isinstance（object，classinfo）其中object是实例类型，但是classinfo可以是直接或间接类名、基本类型或者由他们组成的元组。</p><p>54.0的任何次方都是1</p><p>55.python2的math.floor()函数返回值是浮点型，但是python3的返回值是整型。</p><p>56.函数可以赋值给一个变量；函数可以作为元素添加到集合对象中；函数可以作为参数值传递给其他函数；函数可以当作函数的返回值。</p><p>57.python中的标识符：标识符是由字符（A<del>Z和a</del>z）,下划线和数字组成，但是第一个字符不是数字。标识符不能和python中的保留字相同，python中的标识符中，不能包含空格，@，%以及$等特殊符号。</p><p>58.python不支持的数据类型是char，python中有五个标准的数据类型，Numbers，String，List，Tuple，Dictionary。</p><p>59.浮点数无法精确表示。</p><p>60.C语言中字符串用’\0‘作为结束符以防止越界，但python中字符串其实是一个固定长度的字符数组，并不需要结束符。</p><p>61.”a”&gt;”b” or “c” 其中比较运算符优先级大于逻辑运算符。</p><p>62.python中主要存在四种命名方式：</p><p>object：公用方法</p><p>_object: 半保护，被看做是protect，意思是只有类对象和子类对象自己能访问到这些变量，在模块或类外不可以使用，不能用from module import * 导入。</p><p>__object:全私有，全保护，私有成员“private”，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据，不能用from module import * 导入。</p><p>双下划线，是内建方法，用户不要这样定义。</p><p>63.集合的特点</p><p>（1）集合由<strong>不同元素</strong>组成</p><p>（2）集合是无序的</p><p>（3）<strong>集合中的元素必须是不可变类型。</strong></p><ol><li>str()函数可以避免类型错误。</li><li>range()函数的作用：生成一系列的数字</li><li>导入类可以把大部分逻辑存储在独立的文件中，然后在主程序中编写高级逻辑。</li><li>关键字 with 会在程序不再需要访问文件或出现异常的情况下，关闭文件 。</li><li>读取文本文件时， Python 会将文件中的所有文本都解释为字符串 。</li><li>使用 del（）和pop（）语句 指定字典名和要删除的键，即可删除键值对。del（key）没有返回值，pop有返回值。</li><li>创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</li><li>列表有序，字典无序，集合无序，元组无序。</li><li>字典中的key区分大小写。</li><li>集合是一个无序的不重复元素序列。</li><li>raise唯一的参数指定了要抛出的异常。他必须是一个异常的实例或者异常的类（也就是Exception的子类）</li><li>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</li><li>从键盘输入的任何字符（包含数字）都被当成字符串赋值给变量a。因此，从键盘输入的数据如果要作为非字符串进行操作，就要进行类型转换或格式转换。</li><li>汉字可以用作标识符。</li><li>两个下划线开头的标识符，声明该属性是私有，不能在类的外部被使用或直接访问。两个下划线开头，声明该方法为私有方法，只能在类的内部调用，不能在类的外部调用。</li><li>以单下划线开头的标识符，表示不能直接访问的类属性。</li><li>当标识符用作类名时，应采用单词首字母大写的形式。</li><li>以单下划线开头的属性和方法，用于指定属性和方法是私有的，但是python不像java一样具有私有属性、方法和类，在属性和方法之前加单下划线，只是代表该属性、方法、类只能在内部使用，是API非公开的部分，用from import *时，这些属性、方法、类将不能被导入。</li><li>python以双下划线开头的方法和属性表示私有的属性和方法。这个设计的实际目的是为了避免父类的方法被子类轻易的覆盖。</li><li>对于不可变类型，内存中只能有一个相同值的对象，比如字符串是不可变对象，则内存中关于一个字符串只能有一个，值为字符串且相等的变量都指向同一个位置。</li><li>字典是无序的键值对集合。</li><li>集合中的元素没有顺序，没有重复元素。是可变对象。</li><li>浮点数相等的比较判断，一般写成abs（0.1+0.2-0.3）&lt;1e-6</li><li>复数的实部和虚部都是浮点型。</li><li>bool是int类型的子类。</li><li>python允许连续进行比较，形如a&lt;b&lt;c。</li><li>eval（expression）：python将expression当作一个python表达式进行解析和计算。</li><li>在python中的所有有序的集合（字符串、列表、元组）都是有索引概念的，字典不是有序的，因此没有索引的概念。</li><li>控制结构就是控制程序执行顺序的结构，程序设计有三大控制结构，分别是顺序结构、选择结构（又叫分支结构）以及循环结构。</li><li>通过切片，字符串切片得到的仍然是字符串，但是列表切片得到的是列表。</li><li>列表的clear()和reverse()和sort()直接作用于原列表，函数返回None。</li><li>字典的 values()\items()\keys()三个方法返回的不是列表，是对象，就跟 range 对象一样。他们是惰性对象，只有在“参与运算”的时候才真正“表现出”列表的特性。</li><li>set()函数可以创建一个无序不重复的元素集，这个函数至多可以传入一个参数。</li><li>集合不能像列表元组一样通过索引访问集合存储的元素，也不能通过“键”名称来访问，对集合元素的访问只能通过成员操作符in或not in 来判断某元素是否在集合中，或者通过for语句进行遍历。</li><li>推导式可以从一个数据序列构建另一个新的数据序列。</li><li>列表推导式适用于列表、元组、字典、集合等这一系列可迭代(iterable)数据结构。</li><li>zip()函数用于将可迭代的对象作为参数，将对象中对应的元素一一对应起来打包成一个元组，然后返回由这些元组组成的zip对象，可以对zip对象进行解包，或者转换成list对象。</li><li>zip()函数 map()函数，zip函数从python3.0开始，不返回list，而是返回iterable()对象，这个可迭代的对象需要注意，只能进行一次迭代遍历，第二次就空了。</li><li>map得到的也是一个新的可迭代的对象，并且map函数不改变原可迭代对象。</li><li>sorted()函数对所有可迭代对象进行排序操作。</li><li>sort和sorted的区别：sort是应用到list上的方法，sorted可以对所有可迭代的对象进行的操作。list的sort方法返回的是对已经存在的列表进行操作，而内建函数sorted方法返回的是一个新的list，而不是在原来的基础上进行的操作。</li></ol><p>简答题：</p><p>1.list和tuple的区别</p><p>不同点：</p><p>(1)定义的方式 list[],tuple()</p><p>(2)是否可变 list可变，tuple()不可变</p><p>(3)list中有append(),insert()函数，tuple中没有</p><p>相同点：都是有序的集合（容器）</p><p>List和tuple互相转换，都是通过强制转换即可</p><p>temp_list &#x3D; [1,2,3,4,5] tuple(temp_list)</p><p>temp_tuple &#x3D; (1,2,3) list(temp_tuple)</p><p>2.定义函数的规则？</p><p>(1).函数代码块以def关键词开头，后接函数标识符名称和圆括号()。</p><p>(2).任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</p><p>(3).函数的第一行语句可以选择性的使用文档字符串-用于存放函数说明</p><p>(4).函数内容以冒号起始，并且缩进。</p><p>(5).return[表达式]结束函数，选择性的返回一个值给调用方。不带表达式的return相当于返回None。</p><p>3.–new–和–init–的区别？</p><p>(1).–new–是一个静态方法，而–init–是一个实例方法。</p><p>(2).–new–方法会返回一个创建的实例，而–init–什么都不返回。</p><p>(3).只有在–new–返回一个class实例时后面的–init–才能被调用。</p><p>(4).当创建一个新实例时调用–new–，初始化一个实例时使用–init–。</p><p>4.read，readline和readlines之间的区别？</p><p>read读取整个文件。readline读取下一行，使用生成器方法。readlines读取整个文件到一个迭代器以供我们遍历。</p><p>5.去掉old_list &#x3D; [1,1,1,3,4 ] 中的重复元素？</p><p>new_list &#x3D; list(set(old_list))</p><p>6.用两个元素之间有对应关系的list构造一个dict</p><p>names &#x3D; [‘Alice’,’Bob’]; ages &#x3D; [23,40]</p><p>m &#x3D; dict(zip(names,ages))</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="/2021/05/17/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/05/17/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是序列化和反序列化？"><a href="#什么是序列化和反序列化？" class="headerlink" title="什么是序列化和反序列化？"></a>什么是序列化和反序列化？</h1><p>从定义上来说：</p><p>序列化：java的序列化就是将对象转换成字节序列的过程。</p><p>反序列化：反序列化就是把字节序列恢复为对象的过程。</p><p>本质上讲：序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流中重建对象，恢复对象状态。</p><p>通俗点解释就是：如果我们想把很多的对象的数据中的一些信息持久的保存下来，那么这个就叫做序列化，就是把内存中的这些对象给变成一连串的字节的描述的过程。常见的就是变成文件。</p><h1 id="为什么要进行序列化和反序列化？"><a href="#为什么要进行序列化和反序列化？" class="headerlink" title="为什么要进行序列化和反序列化？"></a>为什么要进行序列化和反序列化？</h1><p>当两个进程在进行远程通信时，可以相互的发送的各种类型的数据，包括文本，图片，音频，视频等。而这些数据是以二进制序列的方式在网络上进行传送。</p><p>如果我们在两个进程进行通信时，想要实现进程间的对象传送，那么就要用到java的序列化和反序列化了。</p><p>一方面，发送方需要把这个java对象转换成字节序列，然后在网络中传送；另一方面，接收方需要从字节序列中恢复出java对象。</p><p>那么序列化的好处是什么？</p><p>1.实现了数据的持久化</p><p>2.利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><h1 id="如何实现序列化和反序列化？"><a href="#如何实现序列化和反序列化？" class="headerlink" title="如何实现序列化和反序列化？"></a>如何实现序列化和反序列化？</h1><p>1.jdk类库中序列化和反序列化API</p><p>对象输出流，对象输入流</p><p>2.实现序列化的要求</p><p>实现Serializable或者Externalizable接口的类的对象才能被序列化。transient代表属性不能被序列化。</p><p><strong>jdk类库序列化的步骤：</strong></p><p>1.创建一个对象输出流，他可以包装一个其他类型的目标输出流。</p><p>2.通过对象输出流的writeObject()方法写对象</p><p>反序列化的步骤：</p><p>1.创建一个对象输入流，他可以包装一个其他目标的目标输入流。</p><p>2.通过对象输入流的readObject()方法读取对象。</p><p>**注意：**为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。</p><h1 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h1><p>1、序列化时，只对对象的状态进行保存，而不管对象的方法；</p><p>2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p><p>3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p><p>4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p><p>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</p><p>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</p><p>5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p><p>6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p><p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</p><p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p><p>7、Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p><p>8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/05/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/05/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><p>正则表达式，又称为规则表达式，通常被用来检索、替换那些符合逻辑的某个模式（规则）的文本，是对字符串操作的一种逻辑公式。</p><p>正则表达式描述了一种字符串匹配的模式（Pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>正则表达式是由普通字符（例如字符a到z）以及特殊字符（称为“元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>[ABC]</td><td>匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。<img src="https://www.runoob.com/wp-content/uploads/2014/03/E691DDE1-E5CB-4EA8-8D16-759BD0D2B09D.jpg" alt="img"></td></tr><tr><td>[^ABC]</td><td>匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。<img src="https://www.runoob.com/wp-content/uploads/2014/03/ED971D92-30F4-4768-A2C7-02A84A3A9DEB.jpg" alt="img"></td></tr><tr><td>[A-Z]</td><td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。<img src="https://www.runoob.com/wp-content/uploads/2014/03/C5E357BD-65E3-4EB3-9D80-10D096F19287.jpg" alt="img"></td></tr><tr><td><strong>.</strong></td><td>匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。<img src="https://www.runoob.com/wp-content/uploads/2014/03/0FD7E77D-38A7-43BC-B51A-7DBA23A77756.jpg" alt="img"></td></tr><tr><td>[\s\S]</td><td>匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。<img src="https://www.runoob.com/wp-content/uploads/2014/03/47CA6C59-64CF-433A-909E-1E342349A4E0.jpg" alt="img"></td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]<img src="https://www.runoob.com/wp-content/uploads/2014/03/F35A5971-3519-4CAE-8BEC-9DE8F4A55257.jpg" alt="img"></td></tr></tbody></table><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\cx</td><td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>特殊字符就是指一些有特殊含义的字符，如前面说的runoo<em>b中的</em>就是表示任何字符串的意思。如果要查找字符串中的<em>符号，就要对</em>进行转义，即在其前面加一个\，runo*ob就匹配字符串runo*ob。</p><table><thead><tr><th>特别字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td>.</td><td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td>[</td><td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td>\</td><td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “”，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td>{</td><td>标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td>|</td><td>指明两项之间的一个选择。要匹配 |，请使用 |。</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>以下正则表达式匹配一个正整数，<strong>[1-9]<strong>设置第一个数字不是 0，</strong>[0-9]</strong>* 表示任意多个数字：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">/<span class="hljs-selector-attr">[1-9]</span><span class="hljs-selector-attr">[0-9]</span>*/<br></code></pre></td></tr></table></figure><p>如果要设置 0~99 的两位数，可以使用下面的表达式来至少指定一位但至多两位数字。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/[0-9]&#123;1,2&#125;/</span><br></code></pre></td></tr></table></figure><p>上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。</p><p>改进下，匹配 1~99 的正整数表达式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">/<span class="hljs-selector-attr">[1-9]</span><span class="hljs-selector-attr">[0-9]</span>?/<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">/<span class="hljs-selector-attr">[1-9]</span><span class="hljs-selector-attr">[0-9]</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;/<br></code></pre></td></tr></table></figure><p>*和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。</p><p>**贪婪：**下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/&lt;.*&gt;/</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/AD8F3320-2F2E-4513-9BB5-84450D62783D.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/AD8F3320-2F2E-4513-9BB5-84450D62783D.jpg" alt="img"></a></p><p>**非贪婪：**如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配</p><h1 id="。-也可以使用以下正则表达式来匹配-h1-标签，表达式则是：-通过在-、-或-限定符之后放置-，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。"><a href="#。-也可以使用以下正则表达式来匹配-h1-标签，表达式则是：-通过在-、-或-限定符之后放置-，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。" class="headerlink" title="。/&lt;.*?&gt;/也可以使用以下正则表达式来匹配 h1 标签，表达式则是：/&lt;\w+?&gt;/通过在 *****、*+* 或 ? 限定符之后放置 ?，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。"></a>。<code>/&lt;.*?&gt;/</code><img src="https://www.runoob.com/wp-content/uploads/2014/03/A6E72665-CE61-46F4-A72B-A34BC13F5820.jpg" alt="img">也可以使用以下正则表达式来匹配 h1 标签，表达式则是：<code>/&lt;\w+?&gt;/</code><img src="https://www.runoob.com/wp-content/uploads/2014/03/C6E89F76-D059-4600-A507-74C42306A790.jpg" alt="img">通过在 *****、*<em>+</em>* 或 <strong>?</strong> 限定符之后放置 <strong>?</strong>，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配。</h1><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使我们能够将正则表达式固定到行首或行尾。它们还使我们能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td>\b</td><td>匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td>\B</td><td>非单词边界匹配。</td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title="^"></a><strong>^</strong></h4><p><strong>匹配以^后面的字符开始的字符串。</strong></p><p>当^后见直接跟字符串时，表示以后面的整个字符串开始，当后面是一个表达式时，表示匹配以该表达式开始的字符串，详见下例：</p><p>grep -E ‘^123[0-9]*[3]’ data.txt &#x2F;&#x2F; 查找以【123 + 任意多的0-9之间的字符 + 3】 开始的字符串</p><p>grep -E ‘^[123][0-9]*[3]’ data.txt &#x2F;&#x2F; 查找以【1或2或3】开始 + 0-9之间的数字任意多个数字 + 3 的字符串</p><p>grep -E ‘^(123).*[3]’ data.txt &#x2F;&#x2F; 查找以【123】开始 + 任意多个任意字符 + 3 的字符串</p><h4 id="-1"><a href="#-1" class="headerlink" title="$"></a>$</h4><p><strong>匹配以$前面的字符结束的字符串。</strong></p><p>当$前面直接跟字符时，表示匹配以前面整个字符串结束的， 当前面是一个表达式时，表示匹配以该表达式结束的字符串，详见下例：</p><p>grep -E ‘123$’ data.txt &#x2F;&#x2F; 查找以【123】结束的字符串</p><p>grep -E ‘^[456][123]$’ data.txt &#x2F;&#x2F; 查找以【4或5或6】开始，以【1或2或3】结束的字符串</p><h4 id="b"><a href="#b" class="headerlink" title="\b"></a>\b</h4><p><strong>匹配单词边界（即从单词靠近空格的地方开始查找），查找匹配\b后或者前面字符的单词。</strong></p><p>grep -E ‘\bfine’ data.txt &#x2F;&#x2F; 查找单词fine 或者查找以fine开始的单词</p><p>grep -o -E ‘\bfi’ data.txt &#x2F;&#x2F; 查找单词fi 或者查找以fi开始单词</p><h4 id="B"><a href="#B" class="headerlink" title="\B"></a>\B</h4><p><strong>匹配非单词边界（即从单词中查找），查找匹配含有某个字符的单词，该字符不在开始也不在结束。</strong></p><p>grep -o -E ‘\Bfi’ data.txt &#x2F;&#x2F; 查找包含字符fi的单词</p><p>若要匹配一行文本开始处的文本，请在正则表达式的开始使用 <strong>^</strong> 字符。不要将 <strong>^</strong> 的这种用法与中括号表达式内的用法混淆。</p><p>若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 <strong>$</strong> 字符。</p><p>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p><p><strong>注意</strong>：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <strong>^*</strong> 之类的表达式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">/^Chapter <span class="hljs-selector-attr">[1-9]</span><span class="hljs-selector-attr">[0-9]</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;/<br></code></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，<strong>()</strong> 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/366574CC-3706-4B4C-8782-1BFF4CF57582.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/366574CC-3706-4B4C-8782-1BFF4CF57582.jpg" alt="img"></a></p><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/82A7298A-2A94-49E3-AA27-A7778EE89711.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/82A7298A-2A94-49E3-AA27-A7778EE89711.jpg" alt="img"></a></p><p>但<strong>用圆括号会有一个副作用，使相关的匹配会被缓存</strong>，此时<strong>可用 ?: 放在第一个选项前来消除这种副作用</strong>。</p><p>其中 <strong>?:</strong> 是<strong>非捕获元之一</strong>，还有两个非捕获元是 <strong>?&#x3D;</strong> 和 <strong>?!</strong>，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p><p><strong>捕获元与非捕获元：</strong></p><p>以前看到什么?:,?&#x3D;,?!，用的少，也就没留意，最近大面积灾荒，经常看到，甚是恐惧，以至于前面在读gulp里面碰见个regex表达式：&#x2F;-[0-9a-f]{8,10}-?&#x2F;(匹配app-7ef5d9ee29.css这一类表达式中的md5值),就一头栽进去，’-?’到底又有什么特殊的含义，最后才发现，那TMD就是一个贪婪匹配，你个蠢货，但确实搞不懂源码作者在想啥，也许是我没碰到app-7ef5d9ee29-any.css这样的文件名，要不非得多加个’-?’干啥，让我直往坑里跳。<br>回到正题，先搞懂什么叫捕获组，概括起来就是，用括号如‘（pattern）’这样的形式，匹配满足括号中的，就是一个捕获组。先看一张来自于菜鸟教程的定义：</p><p><a href="https://segmentfault.com/img/bVShnX?w=734&h=452"><img src="https://segmentfault.com/img/bVShnX?w=734&h=452" alt="img"></a></p><p>四种形式，<strong>加?和不加有什么区别，区别就是捕获元与非捕获元</strong>，表现形式就是用exec方法去匹配，捕获组会单纯保存在一组变量中。理论太枯燥，直接看例子，来源于JS高设page106，略有改动：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str =<span class="hljs-string">&#x27;mom and dad and baby&#x27;</span>;<br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/mom( and dad( and baby))/</span>; <span class="hljs-comment">//捕获元形式</span><br><span class="hljs-keyword">var</span> pat= <span class="hljs-regexp">/mom(?: and dad(?: and baby))/</span>; <span class="hljs-comment">//非捕获元形式</span><br><span class="hljs-keyword">var</span> mat = pattern.exec(str);<br><span class="hljs-keyword">var</span> match = pat.exec(str);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(mat)；<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(match)；<br></code></pre></td></tr></table></figure><p><a href="https://segmentfault.com/img/bVShpP?w=886&h=295"><img src="https://segmentfault.com/img/bVShpP?w=886&h=295" alt="img"></a></p><p>看着devtools打印的结果，是不是有点眉目，是的，匹配的结果虽一致，但捕获组匹配时，将满足捕获元形式的单元<strong>单独保存为一个匹配结果</strong>，而非捕获元不单独保存，只保存完整匹配结果。我们常见的Regexp.$1,$2其实就是对捕获组结果的引用。</p><p>捕获元与非捕获元搞懂了，那(?:pattern)与(?&#x3D;pattern)啥区别呢，答案，两个区别。区别一：前者匹配的结果包含捕获元，后者匹配的结果则不包含；区别二：前者匹配捕获元时，消耗字符（索引），而后者不消耗。还是来看一个例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str =<span class="hljs-string">&#x27;ababa&#x27;</span>;<br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/ab(?:a)/g</span>;<br><span class="hljs-keyword">var</span> pat=  <span class="hljs-regexp">/ab(?=a)/g</span>; <br><span class="hljs-keyword">var</span> mat = pattern.exec(str);<br><span class="hljs-keyword">var</span> match = pat.exec(str);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(mat);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(match);       <br> mat = pattern.exec(str); <span class="hljs-comment">//全局模式，第二次匹配</span><br> match = pat.exec(str); <span class="hljs-comment">//全局模式，第二次匹配</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(mat);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(match); <br></code></pre></td></tr></table></figure><p><a href="https://segmentfault.com/img/bVShs7?w=345&h=401"><img src="https://segmentfault.com/img/bVShs7?w=345&h=401" alt="img"></a></p><p>从上面代码运行的截图可以看出区别一，也就是(?:pattern)的形式的捕获元匹配的结果会保存在最终的结果中，而(?&#x3D;pattern)；区别二看的不是很明显，这时我们需要依靠RegexBuddy，这个过程中到底发生了什么？看运行截图，如果你够仔细，你可以发现区别，第一次匹配到结果，开始第二次匹配时，?:是从字符索引3开始,而?&#x3D;是从2开始，这就是前面所说的消耗字符与不消耗字符。</p><p><a href="https://segmentfault.com/img/bVShuK?w=708&h=358"><img src="https://segmentfault.com/img/bVShuK?w=708&h=358" alt="img"></a></p><p>好了，最后一个问题，整箱预查(?&#x3D;pattern)与负向预查(?!pattern)，其实从中文单纯来理解负向预查，是会带来歧义的。这里的负向其实单单就是正向预查的取反，即要匹配的字符不满足捕获的条件，才能匹配到结果。</p><h3 id="以下列出-、"><a href="#以下列出-、" class="headerlink" title="以下列出 ?&#x3D;、?&lt;&#x3D;、?!、?&lt;! 的使用区别"></a>以下列出 ?&#x3D;、?&lt;&#x3D;、?!、?&lt;! 的使用区别</h3><p><strong>exp1(?&#x3D;exp2)</strong>：查找 exp2 前面的 exp1。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/reg-111.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-111.jpg" alt="img"></a></p><p><strong>(?&lt;&#x3D;exp2)exp1</strong>：查找 exp2 后面的 exp1。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/reg-222.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-222.jpg" alt="img"></a></p><p><strong>exp1(?!exp2)</strong>：查找后面不是 exp2 的 exp1。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/reg-333.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-333.jpg" alt="img"></a></p><p><strong>(?&lt;!exp2)exp1</strong>：查找前面不是 exp2 的 exp1。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/reg-444.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/reg-444.jpg" alt="img"></a></p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以<strong>使用非捕获元字符 ?:、?&#x3D; 或 ?! 来重写捕获</strong>，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Is</span> <span class="hljs-keyword">is</span> the <span class="hljs-keyword">cost</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">of</span> gasoline going up up?<br></code></pre></td></tr></table></figure><p>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而<strong>不必查找每个单词的重复出现</strong>，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h6><p>查找重复的单词：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Is is the cost of of gasoline going up up&quot;</span>;<br><span class="hljs-built_in">var</span> patt1 = /\b([a-z]+) \<span class="hljs-number">1</span>\b/ig;<br>document.write(<span class="hljs-built_in">str</span>.match(patt1));<br></code></pre></td></tr></table></figure><p>捕获的表达式，正如 <strong>[a-z]+</strong> 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。<strong>\1</strong> 指定第一个子匹配项。</p><p>单词边界元字符确保只检测整个单词。否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。</p><p>正则表达式后面的全局标记 <strong>g</strong> 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。</p><p>表达式的结尾处的不区分大小写 <strong>i</strong> 标记指定不区分大小写。</p><p>多行标记指定换行符的两边可能出现潜在的匹配。</p><p>反向引用还可以<strong>将通用资源指示符 (URI) 分解为其组件</strong>。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页&#x2F;路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.runoob.com:<span class="hljs-number">80</span><span class="hljs-regexp">/html/</span>html-tutorial.html<br></code></pre></td></tr></table></figure><p>下面的正则表达式提供该功能：</p><p><strong>实例</strong></p><p>输出所有匹配的数据：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;http://www.runoob.com:80/html/html-tutorial.html&quot;</span>;<br><span class="hljs-built_in">var</span> patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^<span class="hljs-meta"># ]*)/;</span><br>arr = <span class="hljs-built_in">str</span>.match(patt1);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length ; i++) &#123;<br>    document.write(arr[i]);<br>    document.write(<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第三行代码 <strong>str.match(patt1)</strong> 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。</p><p>第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。</p><p>第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 <strong>:</strong> 和 <strong>&#x2F;</strong> 之后的一个或多个字符。</p><p>第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。</p><p>最后，第四个括号子表达式捕获 Web 地址指定的路径和 &#x2F; 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。</p><p>将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：</p><ul><li>第一个括号子表达式包含 <strong>http</strong></li><li>第二个括号子表达式包含 <strong><a href="http://www.runoob.com/">www.runoob.com</a></strong></li><li>第三个括号子表达式包含 <strong>:80</strong></li><li>第四个括号子表达式包含 <strong>&#x2F;html&#x2F;html-tutorial.html</strong></li></ul><h1 id="正则表达式-修饰符（标记）"><a href="#正则表达式-修饰符（标记）" class="headerlink" title="正则表达式 - 修饰符（标记）"></a>正则表达式 - 修饰符（标记）</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>flags<br></code></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th>修饰符</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>ignore - 不区分大小写</td><td>将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td>g</td><td>global - 全局匹配</td><td>查找所有的匹配项。</td></tr><tr><td>m</td><td>multi line - 多行匹配</td><td>使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td>s</td><td>特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td>默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h3 id="g-修饰符"><a href="#g-修饰符" class="headerlink" title="g 修饰符"></a>g 修饰符</h3><p>g 修饰符可以查找字符串中所有的匹配项：</p><p><a href="https://www.runoob.com/wp-content/uploads/2020/08/D1A5F1E7-E25E-448E-9BE3-68508E058E99.jpg"><img src="https://www.runoob.com/wp-content/uploads/2020/08/D1A5F1E7-E25E-448E-9BE3-68508E058E99.jpg" alt="img"></a></p><p><strong>实例</strong></p><p>在字符串中查找 “runoob”:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;Google runoob taobao runoob&quot;</span>; <br><span class="hljs-built_in">var</span> n1=<span class="hljs-built_in">str</span>.match(/runoob/);   <span class="hljs-comment">// 查找第一次匹配项</span><br><span class="hljs-built_in">var</span> n2=<span class="hljs-built_in">str</span>.match(/runoob/g);  <span class="hljs-comment">// 查找所有匹配项</span><br></code></pre></td></tr></table></figure><h3 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h3><p>i 修饰符为不区分大小写匹配，实例如下：</p><p><a href="https://www.runoob.com/wp-content/uploads/2020/08/FF2D211D-0B88-492C-BAA4-04183278383E.jpg"><img src="https://www.runoob.com/wp-content/uploads/2020/08/FF2D211D-0B88-492C-BAA4-04183278383E.jpg" alt="img"></a></p><p><strong>实例</strong></p><p>在字符串中查找 “runoob”:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;Google runoob taobao RUNoob&quot;</span>; <br><span class="hljs-built_in">var</span> n1=<span class="hljs-built_in">str</span>.match(/runoob/g);   <span class="hljs-comment">// 区分大小写</span><br><span class="hljs-built_in">var</span> n2=<span class="hljs-built_in">str</span>.match(/runoob/gi);  <span class="hljs-comment">// 不区分大小写</span><br></code></pre></td></tr></table></figure><h3 id="m-修饰符"><a href="#m-修饰符" class="headerlink" title="m 修饰符"></a>m 修饰符</h3><p>m 修饰符可以使 <strong>^</strong> 和 <strong>$</strong> 匹配一段文本中每行的开始和结束位置。</p><p>g 只匹配第一行，添加 m 之后实现多行。</p><p><a href="https://www.runoob.com/wp-content/uploads/2020/08/BC3E6D8A-21D2-44F8-A1AE-D90C4939D37A.jpg"><img src="https://www.runoob.com/wp-content/uploads/2020/08/BC3E6D8A-21D2-44F8-A1AE-D90C4939D37A.jpg" alt="img"></a></p><p>以下实例字符串中使用 <strong>\n</strong> 来换行：</p><p><strong>实例</strong></p><p>在字符串中查找 “runoob”:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str<span class="hljs-operator">=</span><span class="hljs-string">&quot;runoobgoogle<span class="hljs-subst">\n</span>taobao<span class="hljs-subst">\n</span>runoobweibo&quot;</span>;<br><span class="hljs-keyword">var</span> n1<span class="hljs-operator">=</span>str.match(<span class="hljs-regexp">/^runoob/</span>g);   <span class="hljs-comment">// 匹配一个</span><br><span class="hljs-keyword">var</span> n2<span class="hljs-operator">=</span>str.match(<span class="hljs-regexp">/^runoob/</span>gm);  <span class="hljs-comment">// 多行匹配</span><br></code></pre></td></tr></table></figure><h3 id="s-修饰符"><a href="#s-修饰符" class="headerlink" title="s 修饰符"></a>s 修饰符</h3><p>默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 s 之后, <strong>.</strong> 中包含换行符 <strong>\n</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2020/08/5CDFC964-F0C4-4ADE-80F3-17FB4748DE14.jpg"><img src="https://www.runoob.com/wp-content/uploads/2020/08/5CDFC964-F0C4-4ADE-80F3-17FB4748DE14.jpg" alt="img"></a></p><p>s 修饰符实例如下：</p><p><strong>实例</strong></p><p>在字符串中查找：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str<span class="hljs-operator">=</span><span class="hljs-string">&quot;google<span class="hljs-subst">\n</span>runoob<span class="hljs-subst">\n</span>taobao&quot;</span>;<br><span class="hljs-keyword">var</span> n1<span class="hljs-operator">=</span>str.match(<span class="hljs-regexp">/google./</span>);   <span class="hljs-comment">// 没有使用 s，无法匹配\n</span><br><span class="hljs-keyword">var</span> n2<span class="hljs-operator">=</span>str.match(<span class="hljs-regexp">/runoob./</span>s);  <span class="hljs-comment">// 使用 s，匹配\n</span><br></code></pre></td></tr></table></figure><h1 id="正则表达式-元字符"><a href="#正则表达式-元字符" class="headerlink" title="正则表达式 - 元字符"></a>正则表达式 - 元字符</h1><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “” 而 “(“ 则匹配 “(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td>.</td><td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td>(?&#x3D;pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?&lt;&#x3D;pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”&#96;(?&lt;&#x3D;95</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如”&#96;(?&lt;!95</td></tr><tr><td>x|y</td><td>匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\cx</td><td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td>\xn</td><td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td>\num</td><td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td>\nml</td><td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td>\un</td><td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><p><strong>实例</strong></p><p>接下来我们分析一个匹配邮箱的正则表达式，如下图：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;abcd test@runoob.com 1234&quot;</span>;<br><span class="hljs-built_in">var</span> patt1 = /\b[\w.%+-]+@[\w.-]+\.[a-zA-Z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;\b/g;<br>document.write(<span class="hljs-built_in">str</span>.match(patt1));<br></code></pre></td></tr></table></figure><p>以下标记的文本是获得的匹配的表达式：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">test@</span>runoob.com<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2014/03/3D635D20-FE65-420F-9E79-5B4F1E7E7374.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/03/3D635D20-FE65-420F-9E79-5B4F1E7E7374.jpg" alt="img"></a></p><p><strong>匹配邮箱的正则表达式</strong></p><p><strong>&#x2F;\b[\w.%+-]+@[\w.-]+.[a-zA-Z]{2,6}\b&#x2F;g</strong></p><h1 id="正则表达式-运算符优先级"><a href="#正则表达式-运算符优先级" class="headerlink" title="正则表达式 - 运算符优先级"></a>正则表达式 - 运算符优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>(), (?:), (?&#x3D;), []</td><td>圆括号和方括号</td></tr><tr><td>*, +, ?, {n}, {n,}, {n,m}</td><td>限定符</td></tr><tr><td>^, $, \任何元字符、任何字符</td><td>定位点和序列（即：位置和顺序）</td></tr><tr><td>|</td><td>替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><h1 id="正则表达式-匹配规则"><a href="#正则表达式-匹配规则" class="headerlink" title="正则表达式 - 匹配规则"></a>正则表达式 - 匹配规则</h1><h2 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h2><p>模式，**是正则表达式最基本的元素，他们是一组描述字符串特征的字符。**模式可以很简单，由基本的字符串组成，也可以很复杂，往往用特殊的字符表示一个范围内的字符，重复出现，或者表示上下文。例如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">^<span class="hljs-built_in">once</span><br></code></pre></td></tr></table></figure><p>这个模式包含一个特殊的字符^，**表示该模式只匹配那些以once开头的字符串。**例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">bucket<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符 <strong>^</strong> 和 <strong>$</strong> 同时使用时，表示<strong>精确匹配（字符串与模式一样）</strong>。例如：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-symbol">^bucket</span>$<br></code></pre></td></tr></table></figure><p>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">once</span><br></code></pre></td></tr></table></figure><p>与字符串</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">There once was <span class="hljs-selector-tag">a</span> man <span class="hljs-selector-tag">from</span> NewYork<br>Who kept <span class="hljs-attribute">all</span> of his cash in <span class="hljs-selector-tag">a</span> bucket.<br></code></pre></td></tr></table></figure><p>是匹配的。</p><p>在<strong>该模式中的字母(o-n-c-e)是字面的字符</strong>，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是 <strong>\t</strong>。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">^<span class="hljs-string">\t</span> <br></code></pre></td></tr></table></figure><p>类似的，用\n表示”新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p><h2 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h2><p>所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[AaEeIiOoUu]</span><br></code></pre></td></tr></table></figure><p>这个模式与任何元音字符匹配，但<strong>只能表示一个字符</strong>。用<strong>连字号</strong>可以表示一个字符的<strong>范围</strong>，如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[a-z]</span> <span class="hljs-comment">//匹配所有的小写字母 </span><br><span class="hljs-string">[A-Z]</span> <span class="hljs-comment">//匹配所有的大写字母 </span><br><span class="hljs-string">[a-zA-Z]</span> <span class="hljs-comment">//匹配所有的字母 </span><br><span class="hljs-string">[0-9]</span> <span class="hljs-comment">//匹配所有的数字 </span><br><span class="hljs-string">[0-9\.\-]</span> <span class="hljs-comment">//匹配所有的数字，句号和减号 </span><br><span class="hljs-string">[ \f\r\t\n]</span> <span class="hljs-comment">//匹配所有的白字符</span><br></code></pre></td></tr></table></figure><p>同样的，这些也<strong>只表示一个字符</strong>，这是一个非常重要的。如果要<strong>匹配一个由一个小写字母和一位数字组成的字符串</strong>，比如”z2”、”t6”或”g7”，但不是”ab2”、”r2d3” 或”b52”的话，用这个模式：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">^<span class="hljs-comment">[a-z]</span><span class="hljs-comment">[0-9]</span>$<br></code></pre></td></tr></table></figure><p>尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。</p><p>前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 <strong>^</strong> 时，它表示”<strong>非</strong>“或”<strong>排除</strong>“的意思，常常用来剔除某个字符。还用前面的例子，我们<strong>要求第一个字符不能是数字</strong>：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">^<span class="hljs-comment">[^0-9]</span><span class="hljs-comment">[0-9]</span>$<br></code></pre></td></tr></table></figure><p>这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[^a-z]</span> <span class="hljs-comment">//除了小写字母以外的所有字符 </span><br><span class="hljs-string">[^\\\/\^]</span> <span class="hljs-comment">//除了(\)(/)(^)之外的所有字符 </span><br><span class="hljs-string">[^\&quot;\&#x27;]</span> <span class="hljs-comment">//除了双引号(&quot;)和单引号(&#x27;)之外的所有字符</span><br></code></pre></td></tr></table></figure><p>特殊字符 <strong>.</strong>(点，句号)在正则表达式中用来<strong>表示除了”新行”之外的所有字符</strong>。所以模式 <strong>^.5$</strong> 与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式 <strong>.</strong> 可以匹配任何字符串，<strong>换行符（\n、\r）除外</strong>。</p><p><strong>PHP的正则表达式有一些内置的通用字符簇，列表如下：</strong></p><table><thead><tr><th>字符簇</th><th>描述</th></tr></thead><tbody><tr><td>[[:alpha:]]</td><td>任何字母</td></tr><tr><td>[[:digit:]]</td><td>任何数字</td></tr><tr><td>[[:alnum:]]</td><td>任何字母和数字</td></tr><tr><td>[[:space:]]</td><td>任何空白字符</td></tr><tr><td>[[:upper:]]</td><td>任何大写字母</td></tr><tr><td>[[:lower:]]</td><td>任何小写字母</td></tr><tr><td>[[:punct:]]</td><td>任何标点符号</td></tr><tr><td>[[:xdigit:]]</td><td>任何16进制的数字，相当于[0-9a-fA-F]</td></tr></tbody></table><h2 id="确定重复出现"><a href="#确定重复出现" class="headerlink" title="确定重复出现"></a>确定重复出现</h2><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。</p><table><thead><tr><th>字符簇</th><th>描述</th></tr></thead><tbody><tr><td>^[a-zA-Z_]$</td><td>所有的字母和下划线</td></tr><tr><td>^[[:alpha:]]{3}$</td><td>所有的3个字母的单词</td></tr><tr><td>^a$</td><td>字母a</td></tr><tr><td>^a{4}$</td><td>aaaa</td></tr><tr><td>^a{2,4}$</td><td>aa,aaa或aaaa</td></tr><tr><td>^a{1,3}$</td><td>a,aa或aaa</td></tr><tr><td>^a{2,}$</td><td>包含多于两个a的字符串</td></tr><tr><td>^a{2,}</td><td>如：aardvark和aaab，但apple不行</td></tr><tr><td>a{2,}</td><td>如：baad和aaa，但Nantucket不行</td></tr><tr><td>\t{2}</td><td>两个制表符</td></tr><tr><td>.{2}</td><td>所有的两个字符</td></tr></tbody></table><p>这些例子描述了花括号的三种不同的用法。一个数字 <strong>{x}</strong> 的意思是<strong>前面的字符或字符簇只出现x次</strong> ；一个数字加逗号 <strong>{x,}</strong> 的意思是<strong>前面的内容出现x或更多的次数</strong> ；两个数字用逗号分隔的数字 <strong>{x,y}</strong> 表示 <strong>前面的内容至少出现x次，但不超过y次</strong>。我们可以<strong>把模式扩展到更多的单词或数字</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">^<span class="hljs-selector-attr">[a-zA-Z0-9_]</span>&#123;<span class="hljs-number">1</span>,&#125;$      <span class="hljs-comment">// 所有包含一个以上的字母、数字或下划线的字符串 </span><br>^<span class="hljs-selector-attr">[1-9]</span><span class="hljs-selector-attr">[0-9]</span>&#123;<span class="hljs-number">0</span>,&#125;$        <span class="hljs-comment">// 所有的正整数 </span><br>^\-&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;<span class="hljs-selector-attr">[0-9]</span>&#123;<span class="hljs-number">1</span>,&#125;$      <span class="hljs-comment">// 所有的整数 </span><br>^<span class="hljs-selector-attr">[-]</span>?<span class="hljs-selector-attr">[0-9]</span>+\.?<span class="hljs-selector-attr">[0-9]</span>+$   <span class="hljs-comment">// 所有的浮点数??如果是0000.00002呢?</span><br></code></pre></td></tr></table></figure><p>最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 (<strong>[-]?</strong>) 开头 (<strong>^</strong>)、跟着1个或更多的数字(<strong>[0-9]+</strong>)、和一个小数点(<strong>.</strong>)再跟上1个或多个数字**([0-9]+<strong>)，并且后面没有其他任何东西(</strong>$**)。下面你将知道能够使用的更为简单的方法。</p><p>特殊字符 <strong>?</strong> 与 <strong>{0,1}</strong> 是相等的，它们都代表着： <strong>0个或1个前面的内容</strong> 或 <strong>前面的内容是可选的</strong> 。所以刚才的例子可以简化为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">^\-?[0-9]</span><span class="hljs-template-variable">&#123;1,&#125;</span><span class="language-xml">\.?[0-9]</span><span class="hljs-template-variable">&#123;1,&#125;</span><span class="language-xml">$</span><br></code></pre></td></tr></table></figure><p>特殊字符 ***** 与 <strong>{0,}</strong> 是相等的，它们都代表着 <strong>0 个或多个前面的内容</strong> 。最后，字符 <strong>+</strong> 与 <strong>{1,}</strong> 是相等的，表示 <strong>1 个或多个前面的内容</strong> ，所以上面的4个例子可以写成：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">^<span class="hljs-selector-attr">[a-zA-Z0-9_]</span>+$      <span class="hljs-comment">// 所有包含一个以上的字母、数字或下划线的字符串 </span><br>^<span class="hljs-selector-attr">[1-9]</span><span class="hljs-selector-attr">[0-9]</span>*$        <span class="hljs-comment">// 所有的正整数 </span><br>^\-?<span class="hljs-selector-attr">[0-9]</span>+$          <span class="hljs-comment">// 所有的整数 </span><br>^<span class="hljs-selector-attr">[-]</span>?<span class="hljs-selector-attr">[0-9]</span>+(\.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+)?$ <span class="hljs-comment">// 所有的浮点数</span><br></code></pre></td></tr></table></figure><p>当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。</p><h1 id="正则表达式-示例"><a href="#正则表达式-示例" class="headerlink" title="正则表达式 - 示例"></a>正则表达式 - 示例</h1><p><a href="https://www.runoob.com/regexp/regexp-example.html">https://www.runoob.com/regexp/regexp-example.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>范式</title>
    <link href="/2021/05/15/%E8%8C%83%E5%BC%8F/"/>
    <url>/2021/05/15/%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化的程度。” 晦涩难懂！！！</p><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>可以理解为数据表。</p><p><strong>“关系模式”和“关系”之间的区别：</strong></p><p>类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。</p><p>1NF是所有关系型数据库的最基本的要求。</p><p>常见问题：数据冗余过大，插入异常，删除异常，修改异常。</p><p><strong>关系完整型约束：</strong></p><ul><li>实体完整性</li></ul><p>若属性(指一个或者一组属性)A是基本关系R的主属性，则A不能取空值</p><ul><li>参照完整性</li></ul><p>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码K相对应（或者说F引用了K），则对于R中每个元组在F上的值必须为：或者取空值；或者等于S中某个元组的主码值。</p><ul><li>用户定义的完整性</li></ul><p>针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</p><p>码：关系中的某个属性或者几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）</p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</p><p>**函数依赖：**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。</p><p>在数据表中，不存在任意两条记录，他们在X属性（或属性组）上的值相同，而在Y属性上的值不同。</p><p>**完全函数依赖：**若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ’ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。</p><p>**部分函数依赖：**假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y。</p><p>**码：**设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。</p><p>**非主属性：**包含在任何一个码中的属性成为主属性。</p><p>判断是否是2NF的方法：</p><p>第一步：找出数据表中所有的码。<br>第二步：根据第一步所得到的码，找出所有的主属性。<br>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<br>第四步：查看是否存在非主属性对码的部分函数依赖。</p><p>消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。</p><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>框架</title>
    <link href="/2021/05/13/%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/13/%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>框架的作用</strong><br>　　任何语言、框架的发展都是为了降低程序之间的依赖性和耦合性，使重用性达到最高。<br>　　在我们平时的四层框架中，界面层page、action层、业务逻辑层service、数据访问层dao，虽然分层明确，代码清晰，但是层与层之间有着很高的依赖性，比如service层处理业务逻辑构造sql语句时需要引用dao层的对象，调用dao层的方法执行sql语句，而action层处理界面动作的时候又要引用service层的对象，调用service层的方法，这样一来，实例action对象的时候要同时实例至少一个service对象和一个dao对象，这样依赖性太强，因此我们把他们做成接口，只在类里写各层的引用，而不对引用进行实例化，用spring的ioc依赖注入，在spring容器启动时来实例化引用，降低了程序的依赖性，如果某个业务逻辑发生变化，可以重新写一个新的业务逻辑实现类，修改spring的配置文件即可，不用每个action代码中去改new的对象，这就是依赖注入。<br>　　我们通常说一个方法只做一件事情，但是实际是实现不了的，因为一个方法除了做业务逻辑处理外还要至少处理事务、日志等事情，这些东西没有办法脱离，因此spring的aop面向切面，就将事务和日志可以定义成切面，配置的配置文件中，在你需要的时候切入进来，代码中缺很清晰没有事务和日志，这就是spring的aop。<br>　　事务的处理： 在以往的JDBCTemplate 中事务提交成功，异常处理都是通过Try&#x2F;Catch 来完成，而在Spring中。Spring容器集成了TransactionTemplate，她封装了所有对事务处理的功能，包括异常时事务回滚，操作成功时数据提交等复杂业务功能。这都是由Spring 容器来管理，大大减少了程序员的代码量，也对事务有了很好的管理控制。Hibernate中也有对事务的管理，hibernate 中事务管理是通过SessionFactory 创建和维护Session 来完成。而Spring 对SessionFactory配置也进行了整合，不需要在通过hibernate.cfg.xml来对SessionaFactory进行设定。这样的话就可以很好的利用Sping对事务管理强大功能。避免了每次对数据操作都要现获得Session实例来启动事务&#x2F;提交&#x2F;回滚事务还有繁琐的Try&#x2F;Catch操作。这些也就是Spring中的AOP（面向切面编程）机制很好的应用。一方面使开发业务逻辑更清晰、专业分工更加容易进行。另一方面就是应用Spirng AOP隔离降低了程序的耦合性使我们可以在不同的应用中将各个切面结合起来使用大大提高了代码重用度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2021/04/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/04/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-socket"><a href="#1-socket" class="headerlink" title="1.socket"></a>1.socket</h1><p>在进行网络编程之前，我们需要了解socket。其中IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。</p><p>TCP&#x2F;IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP协议是应用层协议，主要解决如何包装数据。</p><p>那么<strong>socket</strong>是什么呢？</p><p>首先，socket是网络通信的工具，任何一门语言都有socket，他不是任何一门语言的专有名词，而是大家通过自己的程序与其他电脑进行网络通信的时候都用它。</p><p>实际上socket是对TCP&#x2F;IP协议的封装，它的出现只是使得程序员更方便的使用TCP&#x2F;IP协议栈而已。socket本身并不是协议，它是应用层与TCP&#x2F;IP协议通信的中间软件抽象层，是一组调用接口（TCP&#x2F;IP网络的API函数）。</p><p>socket非常类似于电话插座。以一个国家级电话网为例。电话的通话双方相当于相互通信的2个进程，区号是它的网络地址；区内一个单位的交换机相当于一台主机，主机分配给每个用户的局内号码相当于socket号。任何用户在通话之前，首先要占有一部电话机，相当于申请一个socket；同时要知道对方的号码，相当于对方有一个固定的socket。然后向对方拨号呼叫，相当于发出连接请求。对方假如在场并空闲，拿起电话话筒，双方就可以正式通话，相当于连接成功。双方通话的过程，是一方向电话机发出信号和对方从电话机接收信号的过程，相当于向socket发送数据和从socket接收数据。通话结束后，一方挂起电话机相当于关闭socket，撤消连接。</p><p><strong>socket在网路中的位置：</strong></p><p><a href="https://img2018.cnblogs.com/blog/1804804/201912/1804804-20191206181929276-344007041.png"><img src="https://img2018.cnblogs.com/blog/1804804/201912/1804804-20191206181929276-344007041.png" alt="img"></a></p><h1 id="2-Socket的TCP和UDP通信"><a href="#2-Socket的TCP和UDP通信" class="headerlink" title="2.Socket的TCP和UDP通信"></a>2.Socket的TCP和UDP通信</h1><p>socket有两种建立通信的方式，一种是基于TCP的可靠传输，一种是基于UDP的不可靠传输。</p><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><ul><li>可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；文件传输程序。</li><li>面向连接的协议，在socket之间进行数据传输之前必须要建立连接，所以在TCP中需要连接时间</li><li>TCP传输数据无大小限制，一旦建立连接，双方socket就可以按统一的格式传输大的数据（无限制）。</li><li>TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。</li></ul><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><ul><li>不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文(数据包)，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。</li><li>每个数据包中都给出了完整的地址信息，因此无需建立发送方和接收方的连接。</li><li>UDP传输数据时是有大小限制的，每个被传输的数据包必须限定在64KB之内。</li><li>UDP是一个不可靠的协议，发送方所发送的数据包并不一定以相同的顺序到达接收方。</li></ul><p><strong>socket中TCP和UDP对比：</strong><a href="https://img2018.cnblogs.com/blog/1804804/201912/1804804-20191206182728562-1766232336.png"><img src="https://img2018.cnblogs.com/blog/1804804/201912/1804804-20191206182728562-1766232336.png" alt="img"></a></p><h1 id="3-Java中Socket方法"><a href="#3-Java中Socket方法" class="headerlink" title="3.Java中Socket方法"></a>3.Java中Socket方法</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建ServerSocket</td></tr><tr><td>bind(SocketAddress bindpoint)</td><td>将套接字绑定到本地地址</td></tr><tr><td>accept()</td><td>阻塞方法，也就是说调用accept方法后程序会停下来等待连接请求</td></tr><tr><td>close()</td><td>关闭此套接字</td></tr><tr><td>connect(SocketAddress endpoint)</td><td>将此套接字连接到服务器</td></tr><tr><td>InetAddress getInetAddress()</td><td>返回套接字的连接地址</td></tr><tr><td>InetAddress getLocalAddress()</td><td>获取套接字绑定的本地地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr><tr><td>SocketAddress getLocalSocketAddress()</td><td>返回此套接字绑定的端点地址，如果尚未绑定则返回 null</td></tr><tr><td>SocketAddress getRemoteSocketAddress()</td><td>返回此套接字的连接的端点地址，如果尚未连接则返回 null</td></tr><tr><td>int getLoacalPort()</td><td>返回此套接字绑定的本地端口</td></tr><tr><td>int getPort()</td><td>返回此套接字连接的远程端口</td></tr></tbody></table><h1 id="4-基于Java的socket网络编程"><a href="#4-基于Java的socket网络编程" class="headerlink" title="4.基于Java的socket网络编程"></a>4.基于Java的socket网络编程</h1><h5 id="4-1代码结构"><a href="#4-1代码结构" class="headerlink" title="4.1代码结构"></a>4.1代码结构</h5><p><a href="https://img2018.cnblogs.com/blog/1804804/201912/1804804-20191206190418518-1346060472.png"><img src="https://img2018.cnblogs.com/blog/1804804/201912/1804804-20191206190418518-1346060472.png" alt="img"></a></p><h5 id="4-2基于TCP实现"><a href="#4-2基于TCP实现" class="headerlink" title="4.2基于TCP实现"></a>4.2基于TCP实现</h5><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><ul><li>创建一个服务器端socket套接字（套接字会在制定的端口上监听）</li><li>当有使用ServerSocket中的accept()获取客户端socket对象</li><li>使用多线程实现聊天：<ul><li>1.MyClientThread线程负责接收客户端发送给服务器端的消息</li><li>2.MyServerThread线程负责向客户端发送消息</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket.chat;<br><br><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * socket实现聊天</span><br><span class="hljs-comment"> * 1.创建一个服务器端socket套接字（套接字会在制定的端口上监听）；</span><br><span class="hljs-comment"> * 2.当有使用ServerSocket中的accept()获取客户端socket对象</span><br><span class="hljs-comment"> * 3.使用多线程实现聊天：1.MyClientThread线程负责接收客户端发送给服务器端的消息；</span><br><span class="hljs-comment"> *                      2.MyServerThread线程负责向客户端发送消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerSocket</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//服务器端socket</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//客户端socket</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建一个服务器端socket服务</span><br>            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//使用while死循环模拟客户端一直启动</span><br>                clientSocket = serverSocket.accept();<span class="hljs-comment">//获取连接服务端的客户端socket</span><br>                <span class="hljs-comment">//该线程用于接收客户端发送的消息，并将该消息打印到控制台</span><br>                <span class="hljs-type">MyClientThread</span> <span class="hljs-variable">myClientThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClientThread</span>(clientSocket);<br>                <span class="hljs-comment">//该线程用于向客户端发送的消息</span><br>                <span class="hljs-type">MyServerThread</span> <span class="hljs-variable">myServerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerThread</span>(clientSocket);<br><br>                <span class="hljs-comment">//启动线程</span><br>                myClientThread.start();<br>                myServerThread.start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException io) &#123;<br>            io.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (clientSocket != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    clientSocket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (serverSocket != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    serverSocket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-comment">//main--end</span><br>&#125;<span class="hljs-comment">//MyServerSocket--end</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收客户端的内容</span><br><span class="hljs-comment"> * 1.根据客户端Socket获取指向客户端Socket对象的输入流对象（输入源）</span><br><span class="hljs-comment"> * 2.通过输入流对象将客户端输入的信息读取到内存中</span><br><span class="hljs-comment"> * 3.通过输出流对象（System.out.print)将内存中的数据打印到控制台</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClientThread</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取客户端的输入流对象</span><br>            <span class="hljs-built_in">this</span>.dataInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(socket.getInputStream());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException io) &#123;<br>            io.printStackTrace();<br>        &#125;<br>    &#125;<span class="hljs-comment">//MyClientThread--end</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tellClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                tellClient = <span class="hljs-built_in">this</span>.dataInputStream.readUTF();<span class="hljs-comment">//将客户端发送的信息写入到内存中</span><br>                System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+tellClient);<span class="hljs-comment">//将读取的客户端信息打印到控制台</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException io) &#123;<br>            io.printStackTrace();<br>        &#125;<br>    &#125;<span class="hljs-comment">//run--end</span><br>&#125;<span class="hljs-comment">//MyClientThread--end</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向发送客户端的消息</span><br><span class="hljs-comment"> * 1.根据客户端Socket获取指向客户端Socket对象的输出流对象（输出目的地）</span><br><span class="hljs-comment"> * 2.获取控制台输入流对象（输入源）</span><br><span class="hljs-comment"> * 3.通过输入流对象将控制台输入的信息读取到内存中</span><br><span class="hljs-comment"> * 4.通过输出流对象将内存中的数据返回给服务器端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//用于输出服务器返回给客户端的信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//用于将服务器端在控制台输入的信息读取到内存中</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyServerThread</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//根据客户端获取输出流对象</span><br>            <span class="hljs-built_in">this</span>.dataOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(socket.getOutputStream());<br>            <span class="hljs-comment">//获取控制台输入流对象</span><br>            in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<span class="hljs-comment">//MyServerThread--end</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tellServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//将控制台中的信息读入到内存中</span><br>                tellServer = in.nextLine();<br>                <span class="hljs-comment">//服务器端向客户端发送消息</span><br>                <span class="hljs-built_in">this</span>.dataOutputStream.writeUTF(tellServer);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-comment">//run</span><br>&#125;<span class="hljs-comment">//server</span><br></code></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ul><li>根据IP和port获取和服务端连接的Socket对象</li><li>通过服务端Socket对象获取指向服务端Socket对象的输入流&#x2F;输出流，获取服务器端发送的信息或者向服务器发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket.chat;<br><br><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端socket</span><br><span class="hljs-comment"> * 1.根据IP和port获取和服务端连接的Socket对象</span><br><span class="hljs-comment"> * 2.通过服务端Socket对象获取指向服务端Socket对象的输入流/输出流，获取服务器端发送的信息或者向服务器发送消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientSocket</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br><br>            <span class="hljs-type">MyClientToSerThread</span> <span class="hljs-variable">myClientToSerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClientToSerThread</span>(serverSocket);<br>            <span class="hljs-type">MyAcceptServerThread</span> <span class="hljs-variable">myAcceptServerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAcceptServerThread</span>(serverSocket);<br><br>            myClientToSerThread.start();<br>            myAcceptServerThread.start();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException io) &#123;<br>            io.printStackTrace();<br>        &#125;<br><br>    &#125;<span class="hljs-comment">//main--end</span><br>&#125;<span class="hljs-comment">//MyClientSocket--end</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向服务端发送消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientToSerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClientToSerThread</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.dataOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(socket.getOutputStream());<br>            <span class="hljs-built_in">this</span>.in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException io) &#123;<br>            io.printStackTrace();<br>        &#125;<br>    &#125;<span class="hljs-comment">//MyClientToSerThread--end</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tell</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tell = in.nextLine();<br>                dataOutputStream.writeUTF(tell);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-comment">//run--end</span><br>&#125;<span class="hljs-comment">//MyClientToSerThread--end</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *接收客户端的信息</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAcceptServerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAcceptServerThread</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.dataInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(socket.getInputStream());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<span class="hljs-comment">//MyAcceptServerThread--end</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tell</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tell = <span class="hljs-built_in">this</span>.dataInputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;服务端：&quot;</span>+tell);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-comment">//run--end</span><br>&#125;<span class="hljs-comment">//MyAcceptServerThread--end</span><br></code></pre></td></tr></table></figure><h1 id="5-网络七层协议OSI"><a href="#5-网络七层协议OSI" class="headerlink" title="5.网络七层协议OSI"></a>5.网络七层协议OSI</h1><p>例如：采用socket通讯时，用到了IP和端口，表明涉及网络层和传输层；无视多台电脑通信的系统差别，所以它涉及了表示层；一般Socket都是基于一个应用程序的，所以会涉及到会话层和应用层。</p><h1 id="6-TCP、UDP、IP"><a href="#6-TCP、UDP、IP" class="headerlink" title="6.TCP、UDP、IP"></a>6.TCP、UDP、IP</h1><p>IP协议是在源地址和目的地址之间传送数据包，IP负责选择传送的道路，这种选择道路称为路由功能。当有些网络内只能传送小数据包时，还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。对数据没有差错控制，它只使用报头的校验码。</p><p>UDP（User Datagram Protocol 用户数据报协议）是无连接，无数据包分组排序的协议。</p><p>TCP（Transmission Control Protocol <a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/9727741">传输控制协议</a>）是一种面向连接的、可靠的、基于字节流的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536">传输层</a>通信协议。建立连接时需要三次“握手”</p><p>1、TCP与UDP区别总结：<br>1、TCP面向连接，发送数据要先建立连接;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>　　Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h1 id="7-Socket"><a href="#7-Socket" class="headerlink" title="7.Socket"></a>7.Socket</h1><p>socket不是通信协议，而是一种通信模型，是一种<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/9796867">进程通信</a>机制。</p><p>socket本质是编程接口(API)，对TCP&#x2F;IP的封装，TCP&#x2F;IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</p><h1 id="8-同步、异步网络通信"><a href="#8-同步、异步网络通信" class="headerlink" title="8.同步、异步网络通信"></a>8.同步、异步网络通信</h1><p>同步通信是一种比特同步通信技术，要求发收双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，使发收双方建立同步，此后便在同步时钟的控制下逐位发送&#x2F;接收。</p><p>异步通信不要求接收端时钟和发送端时钟同步，发送端发送完一个字节后，可经过任意长的时间间隔再发送下一个字节，所以必须加上开始位和停止位。</p><p>通俗理解：</p><p>同步、异步通信在网络通讯中是指，代码控制数据传输的具体手段。</p><p>同步通信时，发送端发送数据后一直处于阻塞状态，发送端接收到接受端对应回应后，再进行下一次发送。</p><p>异步通信时，a发个b后还未得到b回应前，可以再a发给c。</p><h1 id="9-软件结构"><a href="#9-软件结构" class="headerlink" title="9.软件结构"></a>9.软件结构</h1><p>软件结构一共有两种:C&#x2F;S B&#x2F;S</p><p>C&#x2F;S结构:全称为Client&#x2F;Server结构，是客户端和服务器结构。常见程序有QQ、迅雷、网盘等。(需要安装客户端软件)一般使用客户端软件访问服务器。<br>B&#x2F;S结构:全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌，火狐。(不需要下载软件)，一般使用浏览器访问服务器。<br>这两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<br>网络编程:就是在一定的协议下，实现两台计算机的通信的程序。</p><h1 id="10-什么是网络通信协议？"><a href="#10-什么是网络通信协议？" class="headerlink" title="10.什么是网络通信协议？"></a>10.什么是网络通信协议？</h1><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时候需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一的规定，通信双方必须同时遵守才能完成数据的交换。</p><h1 id="11-TCP-IP协议"><a href="#11-TCP-IP协议" class="headerlink" title="11.TCP&#x2F;IP协议"></a>11.TCP&#x2F;IP协议</h1><p><strong>TCP&#x2F;IP</strong></p><ul><li>传输控制协议&#x2F;因特网互联协议，TCP&#x2F;IP是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内容包含一系列的用于处理数据通信的协议，并采用4层分层模型。</li><li>每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li><li>下面是TCP&#x2F;IP协议中的4层分别是:应用层、传输层、网络层、链路层，每层分别负责不同的通信功能。</li></ul><p><strong>4层分层模型</strong></p><ul><li>链路层:定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li><li>网络层:是整个TCP&#x2F;IP协议的核心，主要用于将传输的数据进行分组，将分组的数据发送到目标计算机或网络。</li><li>运输层:主要负责网络通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li><li>应用层:主要负责应用程序的协议，例如Http协议,FTP协议等。(比如访问网站时必须遵循https协议)</li></ul><h1 id="12-网络通信协议分类（TCP-UDP）"><a href="#12-网络通信协议分类（TCP-UDP）" class="headerlink" title="12.网络通信协议分类（TCP&#x2F;UDP）"></a>12.网络通信协议分类（TCP&#x2F;UDP）</h1><ul><li>1.通信的协议还是比较复杂的，java.net包中包含的类和接口，他们提供<strong>低层次的通信细节</strong>。我们可以直接使用这些类和接口，来<strong>专注于网络程序开发</strong>，而不用考虑通信的细节。</li><li>2.java.net包中提供了<strong>两种常见的网络协议</strong>的支持**:UDP TCP**</li></ul><p><strong>UDP协议</strong></p><ul><li>UDP协议为<strong>用户数据报协议</strong>，UDP是<strong>无连接通信协议</strong>，即在数据传输时，数据的发送端和接收端不需建立逻辑连接。</li><li>简单说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样的，接收端在收到数据时，也不会向发送端反馈是否收到数据。</li></ul><p><strong>UDP适用场景</strong></p><ul><li>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输，例如视频会议都是使用UDP协议，因为这种情况下即时偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</li><li>但是在使用UDP协议传输数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。</li><li>UDP协议传输的数据被限制在64kb，超出这个范围就不能发送，就如qq发送很大的压缩包失败，是UDP不允许而不是qq问题。</li><li>数据报:网络传输的基本单位</li></ul><p><strong>TCP协议</strong></p><ul><li>TCP<strong>传输控制协议</strong>，TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间的<strong>可靠无差错的数据传输。</strong></li></ul><p><strong>TCP三次握手</strong></p><ul><li>在TCP连接中必须要明确客户端与服务器端，由客户端向服务器端发出连接请求，每次连接的创建都需经过”三次握手”。</li><li>三次握手:TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</li><li>第一次握手:客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手:服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手:客户端再次向服务器端发送确认信息，确认连接。</li><li>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输。</li></ul><p><strong>TCP适用场景</strong></p><ul><li><p>由于这种面向连接的特性，TCP协议可以<strong>保证传输数据的安全</strong>，所以应用十分广泛，例如<strong>下载文件，浏览网页</strong>等。</p><p><img src="https://img-blog.csdnimg.cn/20210212130312288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDU0ODYz,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h1 id="13-网络编程三要素"><a href="#13-网络编程三要素" class="headerlink" title="13.网络编程三要素"></a>13.网络编程三要素</h1><p>协议：</p><p>计算机网络通信必须遵守的规则。</p><p>IP地址：</p><p>指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电脑”的话，那么IP地址就相当于“电话号码”。</p><p>IP地址分类：</p><p>IPv4:是一个32位的二进制数，通常被分为4个字节，表示成a,b,c,d的形式，例如192.168.65.100.其中a,b,c,d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP地址的分配越发紧张。为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789,号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p><p>端口号：</p><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说IP地址可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><p>**端口号：**用两个字节表示的整数，它的取值范围是0<del>65535.其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</p><p>利用协议+IP地址+端口号三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其他进程进行交互。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2021/04/10/Spring/"/>
    <url>/2021/04/10/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Spring框架是什么？它有哪些好处？"><a href="#Java-Spring框架是什么？它有哪些好处？" class="headerlink" title="Java Spring框架是什么？它有哪些好处？"></a>Java Spring框架是什么？它有哪些好处？</h1><p>Spring是另一个主流的Java Web开发框架，该框架是一个轻量级的应用框架。</p><p>Spring是分层的Java SE&#x2F;EE full-stack轻量级开源框架，以IoC（Inverse of Control 控制反转）和AOP（Aspect Oriented Programming，面向切面编程）为内核。在实际开发中，通常服务器端采取三层架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。</p><p>Spring框架的主要优点是：</p><h4 id="1）方便解耦，简化开发"><a href="#1）方便解耦，简化开发" class="headerlink" title="1）方便解耦，简化开发"></a>1）方便解耦，简化开发</h4><p>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 管理。</p><h4 id="2）方便集成各种优秀框架"><a href="#2）方便集成各种优秀框架" class="headerlink" title="2）方便集成各种优秀框架"></a>2）方便集成各种优秀框架</h4><p>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis 等）的直接支持。</p><h4 id="3）降低-Java-EE-API-的使用难度"><a href="#3）降低-Java-EE-API-的使用难度" class="headerlink" title="3）降低 Java EE API 的使用难度"></a>3）降低 Java EE API 的使用难度</h4><p>Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低。</p><h4 id="4）方便程序的测试"><a href="#4）方便程序的测试" class="headerlink" title="4）方便程序的测试"></a>4）方便程序的测试</h4><p>Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。</p><h4 id="5）AOP-编程的支持"><a href="#5）AOP-编程的支持" class="headerlink" title="5）AOP 编程的支持"></a>5）AOP 编程的支持</h4><p>Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。</p><h4 id="6）声明式事务的支持"><a href="#6）声明式事务的支持" class="headerlink" title="6）声明式事务的支持"></a>6）声明式事务的支持</h4><p>只需要通过配置就可以完成对事务的管理，而无须手动编程。</p><h1 id="Spring体系结构详解"><a href="#Spring体系结构详解" class="headerlink" title="Spring体系结构详解"></a>Spring体系结构详解</h1><p><a href="http://c.biancheng.net/spring/">Spring</a> 框架采用分层架构，根据不同的功能被划分成了多个模块，这些模块大体可分为 Data Access&#x2F;Integration、Web、AOP、Aspects、Messaging、Instrumentation、Core Container 和 Test。</p><p><a href="https://imgtu.com/i/cdQXkt"><img src="https://z3.ax1x.com/2021/04/10/cdQXkt.gif" alt="cdQXkt.gif"></a></p><h4 id="1-Data-Access-Integration（数据访问／集成）"><a href="#1-Data-Access-Integration（数据访问／集成）" class="headerlink" title="1. Data Access&#x2F;Integration（数据访问／集成）"></a>1. Data Access&#x2F;Integration（数据访问／集成）</h4><p>数据访问&#x2F;集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块。</p><h4 id="2-Web-模块"><a href="#2-Web-模块" class="headerlink" title="2. Web 模块"></a>2. Web 模块</h4><p>Spring 的 Web 层包括 Web、<a href="http://c.biancheng.net/servlet/">Servlet</a>、Struts 和 Portlet 组件。</p><h4 id="3-Core-Container（核心容器）"><a href="#3-Core-Container（核心容器）" class="headerlink" title="3. Core Container（核心容器）"></a>3. Core Container（核心容器）</h4><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成。</p><h4 id="4-其他模块"><a href="#4-其他模块" class="headerlink" title="4. 其他模块"></a>4. 其他模块</h4><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块。</p><h1 id="Spring结构目录和基础JAR包介绍"><a href="#Spring结构目录和基础JAR包介绍" class="headerlink" title="Spring结构目录和基础JAR包介绍"></a>Spring结构目录和基础JAR包介绍</h1><p>Spring 框架压缩包下载完成后，解压文件的目录结构如图所示。</p><p><a href="https://imgtu.com/i/cd1HII"><img src="https://z3.ax1x.com/2021/04/10/cd1HII.png" alt="cd1HII.png"></a></p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>docs</td><td>包含 Spring 的 API 文档和开发规范</td></tr><tr><td>libs</td><td>包含开发需要的 JAR 包和源码包</td></tr><tr><td>schema</td><td>包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束</td></tr></tbody></table><p>在 libs 目录中，包含了 Spring 框架提供的所有 JAR 文件，其中有四个 JAR 文件是 Spring 框架的基础包，分别对应 Spring 容器的四个模块。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>spring-core-3.2.13.RELEASE.jar</td><td>包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。</td></tr><tr><td>spring-beans-3.2.13.RELEASE.jar</td><td>所有应用都要用到的，它包含访问配置文件、创建和管理 bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。</td></tr><tr><td>spring-context-3.2.13.RELEASE.jar</td><td>Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等</td></tr><tr><td>spring-expression-3.2.13.RELEASE.jar</td><td>定义了 Spring 的表达式语言。 需要注意的是，在使用 Spring 开发时，除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息</td></tr></tbody></table><p>使用 Spring 框架时，只需将 Spring 的四个基础包以及 commons-logging-1.2.jar 包复制到项目的 lib 目录，并发布到类路径中即可。</p><h1 id="Spring-IoC容器：BeanFactory和ApplicationContext"><a href="#Spring-IoC容器：BeanFactory和ApplicationContext" class="headerlink" title="Spring IoC容器：BeanFactory和ApplicationContext"></a>Spring IoC容器：BeanFactory和ApplicationContext</h1><p>IoC 是指在程序开发中，实例的创建不再由调用者管理，而是由 Spring 容器创建。Spring 容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此，控制权由程序代码转移到了 Spring 容器中，控制权发生了反转，这就是 Spring 的 IoC 思想。</p><p>Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>BeanFactory 是基础类型的 IoC 容器，它由 org.springframework.beans.facytory.BeanFactory 接口定义，并提供了完整的 IoC 服务支持。简单来说，BeanFactory 就是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。</p><p>BeanFactory 接口有多个实现类，最常见的是 org.springframework.beans.factory.xml.XmlBeanFactory，它是根据 XML 配置文件中的定义装配 Bean 的。</p><p>创建 BeanFactory 实例时，需要提供 Spring 所管理容器的详细配置信息，这些信息通常采用 XML 文件形式管理。其加载配置信息的代码具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResource</span>(<span class="hljs-string">&quot;D://applicationContext.xml&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。该接口的全路径为 org.springframework.context.ApplicationContext，它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。</p><p>ApplicationContext 接口有两个常用的实现类，具体如下。</p><h4 id="1）ClassPathXmlApplicationContext"><a href="#1）ClassPathXmlApplicationContext" class="headerlink" title="1）ClassPathXmlApplicationContext"></a>1）ClassPathXmlApplicationContext</h4><p>该类从类路径 ClassPath 中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext applicationContext <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(String configLocation)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2）FileSystemXmlApplicationContext"><a href="#2）FileSystemXmlApplicationContext" class="headerlink" title="2）FileSystemXmlApplicationContext"></a>2）FileSystemXmlApplicationContext</h4><p>该类从指定的文件系统路径中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext applicationContext <span class="hljs-operator">=</span> new FileSystemXmlApplicationContext(String configLocation)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>它与 ClassPathXmlApplicationContext 的区别是：在读取 Spring 的配置文件时，FileSystemXmlApplicationContext 不再从类路径中读取配置文件，而是通过参数指定配置文件的位置，它可以获取类路径之外的资源，如“F：&#x2F;workspaces&#x2F;applicationContext.xml”。</p><p>通常在 <a href="http://c.biancheng.net/java/">Java</a> 项目中，会采用通过 ClassPathXmlApplicationContext 类实例化 ApplicationContext 容器的方式，而在 Web 项目中，ApplicationContext 容器的实例化工作会交由 Web 服务器完成。Web 服务器实例化 ApplicationContext 容器通常使用基于 ContextLoaderListener 实现的方式，它只需要在 web.xml 中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--spring将加载spring目录下的applicationContext.xml文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>        classpath:spring/applicationContext.xml<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span><br>        org.springframework.web.context.ContextLoaderListener<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，BeanFactory 和 ApplicationContext 都是通过 XML 配置文件加载 Bean 的。</p><p>二者的主要区别在于，如果 Bean 的某一个属性没有注入，则使用 BeanFacotry 加载后，在第一次调用 getBean() 方法时会抛出异常，而 ApplicationContext 则在初始化时自检，这样有利于检查所依赖的属性是否注入。</p><p>因此，在实际开发中，通常都选择使用 ApplicationContext，而只有在系统资源较少时，才考虑使用 BeanFactory。本教程中使用的就是 ApplicationContext。</p><h1 id="第一个Spring程序"><a href="#第一个Spring程序" class="headerlink" title="第一个Spring程序"></a>第一个Spring程序</h1><h4 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h4><p>在 MyEclipse 中创建 Web 项目 springDemo01，将 Spring 框架所需的 JAR 包复制到项目的 lib 目录中，并将添加到类路径下。</p><h4 id="2-创建-PersonDao-接口"><a href="#2-创建-PersonDao-接口" class="headerlink" title="2. 创建 PersonDao 接口"></a>2. 创建 PersonDao 接口</h4><p>在项目的 src 目录下创建一个名为 com.mengma.ioc 的包，然后在该包中创建一个名为 PersonDao 的接口，并在接口中添加一个 add() 方法。</p><h4 id="3-创建接口实现类-PersonDaoImpl"><a href="#3-创建接口实现类-PersonDaoImpl" class="headerlink" title="3. 创建接口实现类 PersonDaoImpl"></a>3. 创建接口实现类 PersonDaoImpl</h4><p>在 com.mengma.ioc 包下创建 PersonDao 的实现类 PersonDaoImpl。</p><h4 id="4-创建-Spring-配置文件"><a href="#4-创建-Spring-配置文件" class="headerlink" title="4. 创建 Spring 配置文件"></a>4. 创建 Spring 配置文件</h4><p>在 src 目录下创建 Spring 的核心配置文件 applicationContext.xml，编辑后如下所示。</p><h4 id="5-编写测试类"><a href="#5-编写测试类" class="headerlink" title="5. 编写测试类"></a>5. 编写测试类</h4><p>在 com.mengma.ioc 包下创建测试类 FirstTest，并在该类中添加一个名为 test1() 的方法。</p><p>上述代码中，首先定义了 Spring 配置文件的路径，然后创建 Spring 容器，接下来通过 Spring 容器获取了 personDao 实例，最后调用实例的 save() 方法。</p><h4 id="6-运行项目并查看结果"><a href="#6-运行项目并查看结果" class="headerlink" title="6. 运行项目并查看结果"></a>6. 运行项目并查看结果</h4><p>使用 JUnit 测试运行 test1() 方法，运行成功。</p><p>在程序执行时，对象的创建并不是通过 new 一个类完成的，而是由 Spring 容器管理实现的。这就是 Spring IoC 容器思想的工作机制。</p><h1 id="Spring-DI（依赖注入）的实现方式：属性注入和构造注入"><a href="#Spring-DI（依赖注入）的实现方式：属性注入和构造注入" class="headerlink" title="Spring DI（依赖注入）的实现方式：属性注入和构造注入"></a>Spring DI（依赖注入）的实现方式：属性注入和构造注入</h1><p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。</p><p>当某个 <a href="http://c.biancheng.net/java/">Java</a> 实例需要另一个 Java 实例时，传统的方法是由调用者创建被调用者的实例（例如，使用 new 关键字获得被调用者实例），而使用 <a href="http://c.biancheng.net/spring/">Spring</a> 框架后，被调用者的实例不再由调用者创建，而是由 Spring 容器创建，这称为控制反转。</p><p>Spring容器在创建被调用者实例的时候，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过Spring容器获得被调用者实例，这称为依赖注入。</p><p>依赖注入主要有两种实现方式，分别是属性setter注入和构造方法注入。</p><h4 id="1）属性-setter-注入"><a href="#1）属性-setter-注入" class="headerlink" title="1）属性 setter 注入"></a>1）属性 setter 注入</h4><p>指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于 setter 的 DI。</p><h4 id="2）构造方法注入"><a href="#2）构造方法注入" class="headerlink" title="2）构造方法注入"></a>2）构造方法注入</h4><p>指 IoC 容器使用构造方法注入被依赖的实例。基于构造器的 DI 通过调用带参数的构造方法实现，每个参数代表一个依赖。</p><p>下面通过属性 setter 注入的案例演示 Spring 容器是如何实现依赖注入的。具体步骤如下。</p><h4 id="1-创建-PersonService-接口"><a href="#1-创建-PersonService-接口" class="headerlink" title="1. 创建 PersonService 接口"></a>1. 创建 PersonService 接口</h4><p>在 springDemo01 项目的 com.mengma.ioc 包下创建一个名为 PersonService 的接口，该接口中包含一个 addPerson() 方法，如下所示。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.mengma.ioc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPerson</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-创建接口实现类-PersonServiceImpl"><a href="#2-创建接口实现类-PersonServiceImpl" class="headerlink" title="2. 创建接口实现类 PersonServiceImpl"></a>2. 创建接口实现类 PersonServiceImpl</h4><p>在 com.mengma.ioc 包下创建一个名为 PersonServiceImpl 的类，该类实现了 PersonService 接口，如下所示。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.<span class="hljs-property">mengma</span>.<span class="hljs-property">ioc</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersonService</span> &#123;<br><br>    <span class="hljs-comment">// 定义接口声明</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">PersonDao</span> personDao;<br><br>    <span class="hljs-comment">// 提供set()方法，用于依赖注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setPersonDao</span>(<span class="hljs-params"><span class="hljs-title class_">PersonDao</span> personDao</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">personDao</span> = personDao;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现PersonService接口的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addPerson</span>(<span class="hljs-params"></span>) &#123;<br>        personDao.<span class="hljs-title function_">add</span>(); <span class="hljs-comment">// 调用PersonDao中的add()方法</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;addPerson()执行了...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-在-applicationContext-xml-中添加配置信息"><a href="#3-在-applicationContext-xml-中添加配置信息" class="headerlink" title="3. 在 applicationContext.xml 中添加配置信息"></a>3. 在 applicationContext.xml 中添加配置信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.ioc.PersonServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 将personDao实例注入personService实例中 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;personDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;personDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-编写测试方法"><a href="#4-编写测试方法" class="headerlink" title="4. 编写测试方法"></a>4. 编写测试方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 定义Spring配置文件的路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">xmlPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;applicationContext.xml&quot;</span>;<br>    <span class="hljs-comment">// 初始化Spring容器，加载配置文件</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<br>            xmlPath);<br>    <span class="hljs-comment">// 通过容器获取personService实例</span><br>    <span class="hljs-type">PersonService</span> <span class="hljs-variable">personService</span> <span class="hljs-operator">=</span> (PersonService) applicationContext<br>            .getBean(<span class="hljs-string">&quot;personService&quot;</span>);<br>    <span class="hljs-comment">// 调用personService的addPerson()方法</span><br>    personService.addPerson();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-运行项目并查看结果"><a href="#5-运行项目并查看结果" class="headerlink" title="5. 运行项目并查看结果"></a>5. 运行项目并查看结果</h4><h1 id="Spring-Bean的配置及常用属性"><a href="#Spring-Bean的配置及常用属性" class="headerlink" title="Spring Bean的配置及常用属性"></a>Spring Bean的配置及常用属性</h1><p>作为 <a href="http://c.biancheng.net/spring/">Spring</a> 核心机制的依赖注入，改变了传统的编程习惯，对组件的实例化不再由应用程序完成，转而交由 Spring 容器完成，在需要时注入应用程序中，从而对组件之间依赖关系进行了解耦。这一切都离不开 Spring 配置文件中使用的 元素。</p><p>Spring 容器可以被看作一个大工厂，而 Spring 容器中的 Bean 就相当于该工厂的产品。如果希望这个大工厂能够生产和管理 Bean，这时则需要告诉容器需要哪些 Bean，以及需要以何种方式将这些 Bean 装配到一起。</p><p>Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。</p><p>定义 Bean 的示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.damain.Person1&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--使用name属性定义person2，其对应的实现类为com.mengma.domain.Person2--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Person2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.domain.Person2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述代码中，分别使用 id 和 name 属性定义了两个 Bean，并使用 class 元素指定了 Bean 对应的实现类。</p><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成</td></tr><tr><td>name</td><td>Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td></tr><tr><td>class</td><td>该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名</td></tr><tr><td>scope</td><td>用于设定 Bean 实例的作用域，其属性值有 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton</td></tr><tr><td>constructor-arg</td><td>元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型</td></tr><tr><td>property</td><td>元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名</td></tr><tr><td>ref</td><td>和 等元素的子元索，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用</td></tr><tr><td>value</td><td>和 等元素的子元素，用于直接指定一个常量值</td></tr><tr><td>list</td><td>用于封装 List 或数组类型的依赖注入</td></tr><tr><td>set</td><td>用于封装 Set 类型属性的依赖注入</td></tr><tr><td>map</td><td>用于封装 Map 类型属性的依赖注入</td></tr><tr><td>entry</td><td>元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value 子元素指定其值</td></tr></tbody></table><h1 id="Spring实例化Bean的三种方法"><a href="#Spring实例化Bean的三种方法" class="headerlink" title="Spring实例化Bean的三种方法"></a>Spring实例化Bean的三种方法</h1><p>在面向对象的程序中，要想调用某个类的成员方法，就需要先实例化该类的对象。在 <a href="http://c.biancheng.net/spring/">Spring</a> 中，实例化 Bean 有三种方式，分别是构造器实例化、静态工厂方式实例化和实例工厂方式实例化。</p><h2 id="构造器实例化"><a href="#构造器实例化" class="headerlink" title="构造器实例化"></a>构造器实例化</h2><p>构造器实例化是指 Spring 容器通过 Bean 对应的类中默认的构造函数实例化 Bean。</p><h4 id="1-创建项目并导入-JAR-包"><a href="#1-创建项目并导入-JAR-包" class="headerlink" title="1. 创建项目并导入 JAR 包"></a>1. 创建项目并导入 JAR 包</h4><h4 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2. 创建实体类"></a>2. 创建实体类</h4><h4 id="3-创建-Spring-配置文件"><a href="#3-创建-Spring-配置文件" class="headerlink" title="3. 创建 Spring 配置文件"></a>3. 创建 Spring 配置文件</h4><h4 id="4-创建测试类"><a href="#4-创建测试类" class="headerlink" title="4. 创建测试类"></a>4. 创建测试类</h4><h4 id="5-运行程序并查看结果"><a href="#5-运行程序并查看结果" class="headerlink" title="5. 运行程序并查看结果"></a>5. 运行程序并查看结果</h4><p>在实际开发中，为了方便管理和维护，建议将这些文件根据类别放置在不同目录中。</p><h2 id="静态工厂方式实例化"><a href="#静态工厂方式实例化" class="headerlink" title="静态工厂方式实例化"></a>静态工厂方式实例化</h2><p>在 Spring 中，也可以使用静态工厂的方式实例化 Bean。</p><h4 id="1-创建实体类"><a href="#1-创建实体类" class="headerlink" title="1. 创建实体类"></a>1. 创建实体类</h4><h4 id="2-创建静态工厂类"><a href="#2-创建静态工厂类" class="headerlink" title="2. 创建静态工厂类"></a>2. 创建静态工厂类</h4><h4 id="3-创建-Spring-配置文件-1"><a href="#3-创建-Spring-配置文件-1" class="headerlink" title="3. 创建 Spring 配置文件"></a>3. 创建 Spring 配置文件</h4><h4 id="4-创建测试类-1"><a href="#4-创建测试类-1" class="headerlink" title="4. 创建测试类"></a>4. 创建测试类</h4><h4 id="5-运行程序并查看结果-1"><a href="#5-运行程序并查看结果-1" class="headerlink" title="5. 运行程序并查看结果"></a>5. 运行程序并查看结果</h4><h2 id="实例工厂方式实例化"><a href="#实例工厂方式实例化" class="headerlink" title="实例工厂方式实例化"></a>实例工厂方式实例化</h2><p>在 Spring 中，还有一种实例化 Bean 的方式就是采用实例工厂。在这种方式中，工厂类不再使用静态方法创建 Bean 的实例，而是直接在成员方法中创建 Bean 的实例。</p><p>同时，在配置文件中，需要实例化的 Bean 也不是通过 class 属性直接指向其实例化的类，而是通过 factory-bean 属性配置一个实例工厂，然后使用 factory-method 属性确定使用工厂中的哪个方法。</p><h4 id="1-创建实体类-1"><a href="#1-创建实体类-1" class="headerlink" title="1. 创建实体类"></a>1. 创建实体类</h4><h4 id="2-创建实例工厂类"><a href="#2-创建实例工厂类" class="headerlink" title="2. 创建实例工厂类"></a>2. 创建实例工厂类</h4><h4 id="3-创建-Spring-配置文件-2"><a href="#3-创建-Spring-配置文件-2" class="headerlink" title="3. 创建 Spring 配置文件"></a>3. 创建 Spring 配置文件</h4><h4 id="4-创建测试类-2"><a href="#4-创建测试类-2" class="headerlink" title="4. 创建测试类"></a>4. 创建测试类</h4><h1 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h1><h2 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h2><p>Spring 容器在初始化一个 Bean 的实例时，同时会指定该实例的作用域。</p><h4 id="1）singleton"><a href="#1）singleton" class="headerlink" title="1）singleton"></a>1）singleton</h4><p>单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</p><h4 id="2）prototype"><a href="#2）prototype" class="headerlink" title="2）prototype"></a>2）prototype</h4><p>原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</p><h4 id="3）request"><a href="#3）request" class="headerlink" title="3）request"></a>3）request</h4><p>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</p><h4 id="4）session"><a href="#4）session" class="headerlink" title="4）session"></a>4）session</h4><p>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</p><h4 id="5）global-Session"><a href="#5）global-Session" class="headerlink" title="5）global Session"></a>5）global Session</h4><p>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</p><h2 id="singleton-作用域"><a href="#singleton-作用域" class="headerlink" title="singleton 作用域"></a>singleton 作用域</h2><p>singleton 是 Spring 容器默认的作用域，当一个 Bean 的作用域为 singleton 时，Spring 容器中只会存在一个共享的 Bean 实例，并且所有对 Bean 的请求，只要 id 与该 Bean 定义相匹配，就只会返回 Bean 的同一个实例。</p><p>通常情况下，这种单例模式对于无会话状态的 Bean（如 DAO 层、Service 层）来说，是最理想的选择。</p><p>在 Spring 配置文件中，可以使用 元素的 scope 属性，将 Bean 的作用域定义成 singleton，其配置方式如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.mengma.scope.Person&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>由于 Spring 容器默认作用域是 singleton，如果不设置 scope&#x3D;”singleton”，则其输出结果也将是一个实例。</p><h2 id="prototype-作用域"><a href="#prototype-作用域" class="headerlink" title="prototype 作用域"></a>prototype 作用域</h2><p>使用 prototype 作用域的 Bean 会在每次请求该 Bean 时都会创建一个新的 Bean 实例。因此对需要保持会话状态的 Bean（如 <a href="http://c.biancheng.net/struts2/">Struts2</a> 的 Action 类）应该使用 prototype 作用域。</p><h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1><p><a href="http://c.biancheng.net/spring/">Spring</a> 容器可以管理 singleton 作用域 Bean 的生命周期，在此作用域下，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁。</p><p>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。每次客户端请求 prototype 作用域的 Bean 时，Spring 容器都会创建一个新的实例，并且不会管那些被配置成 prototype 作用域的 Bean 的生命周期。</p><p>了解 Spring 生命周期的意义就在于，可以利用 Bean 在其存活期间的指定时刻完成一些相关操作。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作。</p><p>Bean 生命周期的整个执行过程描述如下。</p><p>1）根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。</p><p>2）利用依赖注入完成 Bean 中所有属性值的配置注入。</p><p>3）如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。</p><p>4）如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</p><p>5）如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</p><p>6）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</p><p>7）如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。</p><p>8）如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</p><p>9）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</p><p>10）如果在 中指定了该 Bean 的作用范围为 scope&#x3D;”singleton”，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 中指定了该 Bean 的作用范围为 scope&#x3D;”prototype”，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</p><p>11）如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p><p>Spring 为 Bean 提供了细致全面的生命周期过程，通过实现特定的接口或 的属性设置，都可以对 Bean 的生命周期过程产生影响。虽然可以随意配置 的属性，但是建议不要过多地使用 Bean 实现接口，因为这样会导致代码和 Spring 的聚合过于紧密。</p><h1 id="Spring基于XML装配Bean"><a href="#Spring基于XML装配Bean" class="headerlink" title="Spring基于XML装配Bean"></a>Spring基于XML装配Bean</h1><p>Bean 的装配可以理解为依赖关系注入，Bean 的装配方式也就是 Bean 的依赖注入方式。<a href="http://c.biancheng.net/spring/">Spring</a> 容器支持多种形式的 Bean 的装配方式，如基于 XML 的 Bean 装配、基于 Annotation 的 Bean 装配和自动装配等。</p><p>Spring 基于 XML 的装配通常采用两种实现方式，即设值注入（Setter Injection）和构造注入（Constructor Injection）。</p><p>在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 <a href="http://c.biancheng.net/java/">Java</a> 的反射机制调用 setXxx() 方法进行属性的注入。因此，设值注入要求一个 Bean 的对应类必须满足以下两点要求。</p><ul><li>必须提供一个默认的无参构造方法。</li><li>必须为需要注入的属性提供对应的 setter 方法。</li></ul><p>使用设值注入时，在 Spring 配置文件中，需要使用 元素的子元素 元素为每个属性注入值。而使用构造注入时，在配置文件中，主要使用 标签定义构造方法的参数，可以使用其 value 属性（或子元素）设置该参数的值。</p><h4 id="1-创建-Person-类"><a href="#1-创建-Person-类" class="headerlink" title="1. 创建 Person 类"></a>1. 创建 Person 类</h4><h4 id="2-创建-Spring-配置文件"><a href="#2-创建-Spring-配置文件" class="headerlink" title="2. 创建 Spring 配置文件"></a>2. 创建 Spring 配置文件</h4><h4 id="3-创建测试类"><a href="#3-创建测试类" class="headerlink" title="3. 创建测试类"></a>3. 创建测试类</h4><h4 id="4-运行项目并查看结果"><a href="#4-运行项目并查看结果" class="headerlink" title="4. 运行项目并查看结果"></a>4. 运行项目并查看结果</h4><h1 id="Spring基于Annotation装配Bean"><a href="#Spring基于Annotation装配Bean" class="headerlink" title="Spring基于Annotation装配Bean"></a>Spring基于Annotation装配Bean</h1><p>在 <a href="http://c.biancheng.net/spring/">Spring</a> 中，尽管使用 XML 配置文件可以实现 Bean 的装配工作，但如果应用中 Bean 的数量较多，会导致 XML 配置文件过于臃肿，从而给维护和升级带来一定的困难。</p><h4 id="1）-Component"><a href="#1）-Component" class="headerlink" title="1）@Component"></a>1）@Component</h4><p>可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。</p><h4 id="2）-Repository"><a href="#2）-Repository" class="headerlink" title="2）@Repository"></a>2）@Repository</h4><p>用于将数据访问层（DAO层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</p><h4 id="3）-Service"><a href="#3）-Service" class="headerlink" title="3）@Service"></a>3）@Service</h4><p>通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</p><h4 id="4）-Controller"><a href="#4）-Controller" class="headerlink" title="4）@Controller"></a>4）@Controller</h4><p>通常作用在控制层（如 <a href="http://c.biancheng.net/struts2/">Struts2</a> 的 Action），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</p><h4 id="5）-Autowired"><a href="#5）-Autowired" class="headerlink" title="5）@Autowired"></a>5）@Autowired</h4><p>用于对 Bean 的属性变量、属性的 Set 方法及构造函数进行标注，配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型进行装配。</p><h4 id="6）-Resource"><a href="#6）-Resource" class="headerlink" title="6）@Resource"></a>6）@Resource</h4><p>其作用与 Autowired 一样。其区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 实例名称进行装配。</p><p>@Resource 中有两个重要属性：name 和 type。</p><p>Spring 将 name 属性解析为 Bean 实例名称，type 属性解析为 Bean 实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。</p><p>如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</p><h4 id="7）-Qualifier"><a href="#7）-Qualifier" class="headerlink" title="7）@Qualifier"></a>7）@Qualifier</h4><p>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。</p><h4 id="1-创建-DAO-层接口"><a href="#1-创建-DAO-层接口" class="headerlink" title="1. 创建 DAO 层接口"></a>1. 创建 DAO 层接口</h4><h4 id="2-创建-DAO-层接口的实现类"><a href="#2-创建-DAO-层接口的实现类" class="headerlink" title="2. 创建 DAO 层接口的实现类"></a>2. 创建 DAO 层接口的实现类</h4><h4 id="3-创建-Service-层接口"><a href="#3-创建-Service-层接口" class="headerlink" title="3. 创建 Service 层接口"></a>3. 创建 Service 层接口</h4><h4 id="4-创建-Service-层接口的实现类"><a href="#4-创建-Service-层接口的实现类" class="headerlink" title="4. 创建 Service 层接口的实现类"></a>4. 创建 Service 层接口的实现类</h4><h4 id="5-创建-Action"><a href="#5-创建-Action" class="headerlink" title="5. 创建 Action"></a>5. 创建 Action</h4><h4 id="6-创建-Spring-配置文件"><a href="#6-创建-Spring-配置文件" class="headerlink" title="6. 创建 Spring 配置文件"></a>6. 创建 Spring 配置文件</h4><h4 id="7-创建测试类"><a href="#7-创建测试类" class="headerlink" title="7. 创建测试类"></a>7. 创建测试类</h4><h4 id="8-运行程序并查看结果"><a href="#8-运行程序并查看结果" class="headerlink" title="8. 运行程序并查看结果"></a>8. 运行程序并查看结果</h4><h1 id="Spring自动装配Bean"><a href="#Spring自动装配Bean" class="headerlink" title="Spring自动装配Bean"></a>Spring自动装配Bean</h1><p>自动装配就是指 <a href="http://c.biancheng.net/spring/">Spring</a> 容器可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。</p><p>要使用自动装配，就需要配置 元素的 autowire 属性。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>byName</td><td>根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。</td></tr><tr><td>byType</td><td>根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。</td></tr><tr><td>constructor</td><td>根据构造方法的参数的数据类型，进行 byType 模式的自动装配。</td></tr><tr><td>autodetect</td><td>如果发现默认的构造方法，则用 constructor 模式，否则用 byType 模式。</td></tr><tr><td>no</td><td>默认情况下，不使用自动装配，Bean 依赖必须通过 ref 元素定义。</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;  </span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/aop </span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd  </span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/tx </span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.annotation.PersonDaoImpl&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.annotation.PersonServiceImpl&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personAction&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.annotation.PersonAction&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述文件中，用于配置personSevice和personAction的元素除了id和class属性外，还增加了autowire属性，并将其属性值设置为byName（按属性名称自动装配）。</p><p>默认情况下，配置文件中需要通过ref装配Bean，但设置了autowire&#x3D;“byName”，Spring会在配置文件中自动寻找与属性名字personDao相同的,找到后，通过调用setPersonDao（PersonDao personDao）方法将id为personDao的Bean注入id为personService的Bean中，这时就不需要通过ref装配了。</p><h1 id="Spring-AOP（面向切面编程）是什么？"><a href="#Spring-AOP（面向切面编程）是什么？" class="headerlink" title="Spring AOP（面向切面编程）是什么？"></a>Spring AOP（面向切面编程）是什么？</h1><p>面向切面编程（AOP）和面向对象编程（OOP）类似，也是一种编程模式。<a href="http://c.biancheng.net/spring/">Spring</a> AOP 是基于 AOP 编程模式的一个框架，它的使用有效减少了系统间的重复代码，达到了模块间的松耦合目的。</p><p>AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。</p><p>AOP 采取横向抽取机制，取代了传统纵向继承体系的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。</p><p>目前最流行的 AOP 框架有两个，分别为 Spring AOP 和 AspectJ。</p><p>Spring AOP 使用纯 <a href="http://c.biancheng.net/java/">Java</a> 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。</p><p>AspectJ 是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入。</p><p>为了更好地理解 AOP，就需要对 AOP 的相关术语有一些了解，这些专业术语主要包含 Joinpoint、Pointcut、Advice、Target、Weaving、Proxy 和 Aspect，它们的含义如下表所示。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Joinpoint（连接点）</td><td>指那些被拦截到的点，在 Spring 中，可以被动态代理拦截目标类的方法。</td></tr><tr><td>Pointcut（切入点）</td><td>指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。</td></tr><tr><td>Advice（通知）</td><td>指拦截到 Joinpoint 之后要做的事情，即对切入点增强的内容。</td></tr><tr><td>Target（目标）</td><td>指代理的目标对象。</td></tr><tr><td>Weaving（植入）</td><td>指把增强代码应用到目标上，生成代理对象的过程。</td></tr><tr><td>Proxy（代理）</td><td>指生成的代理对象。</td></tr><tr><td>Aspect（切面）</td><td>切入点和通知的结合。</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型详解</title>
    <link href="/2021/03/27/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/27/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一篇博文"><a href="#一篇博文" class="headerlink" title="一篇博文"></a>一篇博文</h1><p><a href="https://blog.csdn.net/s10461/article/details/53941091?ops_request_misc=%7B%22request_id%22:%22161726856216780262572785%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=161726856216780262572785&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53941091.first_rank_v2_pc_rank_v29&utm_term=java%E6%B3%9B%E5%9E%8B">https://blog.csdn.net/s10461/article/details/53941091?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522161726856216780262572785%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;161726856216780262572785&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-1-53941091.first_rank_v2_pc_rank_v29&amp;utm_term&#x3D;java%E6%B3%9B%E5%9E%8B</a></p><h1 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h1><p>泛型，即“参数化类型”，顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。</p><p>也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别称为泛型类、泛型接口、泛型方法。</p><h1 id="为什么要使用泛型？"><a href="#为什么要使用泛型？" class="headerlink" title="为什么要使用泛型？"></a>为什么要使用泛型？</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List arrayList = <span class="hljs-built_in">new</span> ArrayList();<br>arrayList.<span class="hljs-keyword">add</span>(&quot;aaaa&quot;);<br>arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; arrayList.size();i++)&#123;<br>    String item = (String)arrayList.<span class="hljs-keyword">get</span>(i);<br>    <span class="hljs-keyword">Log</span>.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);<br>&#125;<br></code></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似的问题（就是在编译阶段就可以解决），泛型应运而生。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; arrayList = <span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();<br><span class="hljs-params">...</span><br><span class="hljs-comment">//arrayList.add(100); 在编译阶段，编译器就会报错</span><br></code></pre></td></tr></table></figure><p>这样在编译阶段，程序就会报错！</p><p>为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，就不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候就指明类型，更加灵活。</p><h1 id="怎么使用泛型？"><a href="#怎么使用泛型？" class="headerlink" title="怎么使用泛型？"></a>怎么使用泛型？</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。</p><p>具体看：<a href="https://blog.csdn.net/s10461/article/details/53941091?ops_request_misc=%7B%22request_id%22:%22161726856216780262572785%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=161726856216780262572785&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53941091.first_rank_v2_pc_rank_v29&utm_term=java%E6%B3%9B%E5%9E%8B">https://blog.csdn.net/s10461/article/details/53941091?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522161726856216780262572785%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;161726856216780262572785&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-1-53941091.first_rank_v2_pc_rank_v29&amp;utm_term&#x3D;java%E6%B3%9B%E5%9E%8B</a></p><h1 id="泛型的注意点"><a href="#泛型的注意点" class="headerlink" title="泛型的注意点"></a>泛型的注意点</h1><p>1.泛型只在编译阶段有效。</p><p>在编译之后，程序会采取去泛型化的措施。泛型类型在逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型</p><p>2.泛型的类型参数只能是类类型，不能是简单类型。</p><p>3.不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Coffee&lt;Breve&gt; coffee = <span class="hljs-keyword">new</span> Coffee&lt;&gt;();<br><span class="hljs-comment">//if语句括号里面的直接在编译阶段就报错了</span><br>        <span class="hljs-keyword">if</span> (coffee <span class="hljs-keyword">instanceof</span> Coffee&lt;Breve&gt;)&#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;true&quot;</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><p>4.同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>5.’？‘泛型通配符是类型实参，而不是类型形参。什么意思？就是此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类，是一种真实的类型。</p><p>6.泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p>7.静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须将泛型定义在方法上。如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。</p><p>8.为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。</p><p>9.泛型的上下边界添加，必须与泛型的声明在一起。</p><p>10.不能创建一个确切的类型的数组，而使用通配符创建泛型数组是可以的。</p><p>11.数组的类型不可以是类型变量，除非是采用通配符的方式。因为对于通配符的方式，最后取出的数据是要做显式的类型转化</p><h1 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h1><p>ArrayList&lt;?extends Object&gt; al &#x3D; new ArrayList();</p><p>al.add(“aa”); &#x2F;&#x2F;错</p><p>&#x2F;&#x2F;因为集合具体对象中既可存储String，也可以存储Object的其他子类，所以添加具体的类型对象不合适，类型检查会出现安全问题。 ？extends Object 代表Object的子类型不确定，怎么能添加具体类型的对象呢？</p><p>public static void method(ArrayList&lt;? extends Object&gt; al) {<br>al.add(“abc”); &#x2F;&#x2F;错</p><p>&#x2F;&#x2F;只能对al集合中的元素调用Object类中的方法，具体子类型的方法都不能用，因为子类型不确定。</p><p>什么意思？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2021/03/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python3源码文件以UTF-8编码，所有字符都是unicode字符串。当然也可以为源码文件指定不同的编码。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li></ul><h2 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。</p><p>Python的标准库提供了一个keyword模板，可以输出当前版本的所有关键字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">import keyword<br>keyword.kwlist<br>[<span class="hljs-symbol">&#x27;Fals</span>e<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-literal">None</span><span class="hljs-string">&#x27;, &#x27;</span>True<span class="hljs-string">&#x27;, &#x27;</span>and<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">as</span><span class="hljs-string">&#x27;, &#x27;</span>assert<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">break</span><span class="hljs-string">&#x27;, &#x27;</span>class<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">continue</span><span class="hljs-string">&#x27;, &#x27;</span>def<span class="hljs-string">&#x27;, &#x27;</span>del<span class="hljs-string">&#x27;, &#x27;</span>elif<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">else</span><span class="hljs-string">&#x27;, &#x27;</span>except<span class="hljs-string">&#x27;, &#x27;</span>finally<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">for</span><span class="hljs-string">&#x27;, &#x27;</span>from<span class="hljs-string">&#x27;, &#x27;</span>global<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">if</span><span class="hljs-string">&#x27;, &#x27;</span>import<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">in</span><span class="hljs-string">&#x27;, &#x27;</span>is<span class="hljs-string">&#x27;, &#x27;</span>lambda<span class="hljs-string">&#x27;, &#x27;</span>nonlocal<span class="hljs-string">&#x27;, &#x27;</span>not<span class="hljs-string">&#x27;, &#x27;</span>or<span class="hljs-string">&#x27;, &#x27;</span>pass<span class="hljs-string">&#x27;, &#x27;</span>raise<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">return</span><span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">try</span><span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">while</span><span class="hljs-string">&#x27;, &#x27;</span>with<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">yield</span><span class="hljs-string">&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中的单行注释以#开头。</p><p>多行注释可以用多个#，还有’’’ ‘’’和””” “””</p><h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python中最具特色的就是使用缩进来表示代码块，不需要使用大括号{}。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p><h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠（\）来实现多行语句。</p><p>在[],{},或()中的多行语句，不需要使用反斜杠()</p><h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li><strong>bool</strong> (布尔), 如 True。</li><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul><li>python中单引号和双引号使用完全相同。</li><li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li><li>转义符 ‘’</li><li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></li></ul><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><p>**记住：**空行也是程序代码的一部分。</p><h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">input</span>(<span class="hljs-string">&quot;\n\n按下enter键后退出&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>以上代码中，“\n\n”在结果输出前会输出两个新的空行。一旦用户按下enter键时，程序将退出。</p><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python可以在同一行中使用多条语句，语句之间使用分号（；）分割。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">import sys; <span class="hljs-variable language_">x</span> = <span class="hljs-string">&#x27;runoob&#x27;</span>; sys.stdout.write(<span class="hljs-variable language_">x</span> + <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>我们将首行及后面的代码组称为一个子句(clause)。</p><h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end&#x3D;””</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">x</span>=<span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-attribute">y</span>=<span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-comment"># 换行输出</span><br><span class="hljs-built_in">print</span>( x )<br><span class="hljs-built_in">print</span>( y )<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------&#x27;</span>)<br><span class="hljs-comment"># 不换行输出</span><br><span class="hljs-built_in">print</span>( x, <span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span> )<br><span class="hljs-built_in">print</span>( y, <span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span> )<br><span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>在 python 用 <strong>import</strong> 或者 <strong>from…import</strong> 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></p><p>从某个模块中导入某个函数,格式为： <strong>from somemodule import somefunction</strong></p><p>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p><p>将某个模块中的全部函数导入，格式为： <strong>from somemodule import *</strong></p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息。</p><h1 id="Python基本数据类型"><a href="#Python基本数据类型" class="headerlink" title="Python基本数据类型"></a>Python基本数据类型</h1><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p>等号（&#x3D;）用来给变量赋值。</p><p>等号（&#x3D;）运算符左边是一个变量名,等号（&#x3D;）运算符右边是存储在变量中的值。例如：</p><h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>Python允许你同时为多个变量赋值。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span><span class="hljs-operator">=</span>b<span class="hljs-operator">=</span>c<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>以上实例，创建一个整型对象，值为1，从后向前赋值，三个变量被赋予相同的数值。</p><p>也可以为多个对象指定多个变量。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;runoob&quot;</span><br></code></pre></td></tr></table></figure><p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob” 分配给变量 c。</p><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；</li><li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h2 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number(数字)"></a>Number(数字)</h2><p>Python3支持int、float、bool、complex（复数）。</p><p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p><p>内置的 type() 函数可以用来查询变量所指的对象类型。</p><p>此外还可以用 isinstance 来判断：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=<span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">isinstance</span><span class="hljs-params">(a,int)</span></span><br></code></pre></td></tr></table></figure><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">pass</span></span><br><span class="hljs-meta prompt_">...</span> <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">pass</span></span><br><span class="hljs-meta prompt_">...</span> <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(A(), A)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(A()) == A </span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(B(), A)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(B()) == A</span><br>False<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> <em>在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。</em></p><p>当指定一个值时，Number 对象就会被创建，也可以使用del语句删除一些对象的引用。</p><p>可以使用del语句删除单个或多个对象。</p><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">5</span> + <span class="hljs-number">4</span>  <span class="hljs-comment"># 加法</span></span><br>9<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">4.3</span> - <span class="hljs-number">2</span> <span class="hljs-comment"># 减法</span></span><br>2.3<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">3</span> * <span class="hljs-number">7</span>  <span class="hljs-comment"># 乘法</span></span><br>21<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> / <span class="hljs-number">4</span>  <span class="hljs-comment"># 除法，得到一个浮点数</span></span><br>0.5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> // <span class="hljs-number">4</span> <span class="hljs-comment"># 除法，得到一个整数</span></span><br>0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">17</span> % <span class="hljs-number">3</span> <span class="hljs-comment"># 取余</span></span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> ** <span class="hljs-number">5</span> <span class="hljs-comment"># 乘方</span></span><br>32<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>1、Python可以同时为多个变量赋值，如a, b &#x3D; 1, 2。</li><li>2、一个变量可以通过赋值指向不同类型的对象。</li><li>3、数值的除法包含两个运算符：<strong>&#x2F;</strong> 返回一个浮点数，<strong>&#x2F;&#x2F;</strong> 返回一个整数。</li><li>4、在混合计算时，Python会把整型转换成为浮点数。</li></ul><h3 id="数值类型实例"><a href="#数值类型实例" class="headerlink" title="数值类型实例"></a>数值类型实例</h3><table><thead><tr><th>int</th><th>float</th><th>complex</th></tr></thead><tbody><tr><td>10</td><td>0.0</td><td>3.14j</td></tr><tr><td>100</td><td>15.20</td><td>45.j</td></tr><tr><td>-786</td><td>-21.9</td><td>9.322e-36j</td></tr><tr><td>080</td><td>32.3e+18</td><td>.876j</td></tr><tr><td>-0490</td><td>-90.</td><td>-.6545+0J</td></tr><tr><td>-0x260</td><td>-32.54e100</td><td>3e+26J</td></tr><tr><td>0x69</td><td>70.2E-12</td><td>4.53e-7j</td></tr></tbody></table><p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</p><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来，同时使用反斜杠 **** 转义特殊字符。</p><p>字符串的截取的语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标]</span><br></code></pre></td></tr></table></figure><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p><a href="https://static.runoob.com/wp-content/uploads/123456-20200923-1.svg"><img src="https://static.runoob.com/wp-content/uploads/123456-20200923-1.svg" alt="img"></a></p><p>加号 <strong>+</strong> 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。实例如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Runoob&#x27;</span><br><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span>)          <span class="hljs-meta"># 输出字符串</span><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>])    <span class="hljs-meta"># 输出第一个到倒数第二个的所有字符</span><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>])       <span class="hljs-meta"># 输出字符串第一个字符</span><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])     <span class="hljs-meta"># 输出从第三个开始到第五个的字符</span><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>:])      <span class="hljs-meta"># 输出从第三个开始的后的所有字符</span><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span> * <span class="hljs-number">2</span>)      <span class="hljs-meta"># 输出字符串两次，也可以写成 print (2 * str)</span><br><span class="hljs-keyword">print</span> (<span class="hljs-built_in">str</span> + <span class="hljs-string">&quot;TEST&quot;</span>) <span class="hljs-meta"># 连接字符串</span><br></code></pre></td></tr></table></figure><p>Python使用反斜杠\转义，如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Ru\noob&#x27;</span>)</span><br>Ru<br>oob<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;Ru\noob&#x27;</span>)</span><br>Ru\noob<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p><p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">word = <span class="hljs-string">&#x27;Python&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(word[<span class="hljs-number">0</span>], word[<span class="hljs-number">5</span>])</span><br>P n<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(word[-<span class="hljs-number">1</span>], word[-<span class="hljs-number">6</span>])</span><br>n P<br></code></pre></td></tr></table></figure><p>与c字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如word[0] &#x3D; ‘m’会导致错误。</p><p><strong>注意：</strong></p><ul><li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li><li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li><li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>4、Python中的字符串不能改变。</li></ul><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标]</span><br></code></pre></td></tr></table></figure><p>索引值以 <strong>0</strong> 为开始值，<strong>-1</strong> 为从末尾的开始位置。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/08/list_slicing1_new1.png"><img src="https://www.runoob.com/wp-content/uploads/2014/08/list_slicing1_new1.png" alt="img"></a></p><p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">list = [ <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">786</span> , <span class="hljs-number">2.23</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-number">70.2</span> ]<br>tinylist = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>]<br><br><span class="hljs-keyword">print</span> (list)            <span class="hljs-meta"># 输出完整列表</span><br><span class="hljs-keyword">print</span> (list[<span class="hljs-number">0</span>])         <span class="hljs-meta"># 输出列表第一个元素</span><br><span class="hljs-keyword">print</span> (list[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])       <span class="hljs-meta"># 从第二个开始输出到第三个元素</span><br><span class="hljs-keyword">print</span> (list[<span class="hljs-number">2</span>:])        <span class="hljs-meta"># 输出从第三个元素开始的所有元素</span><br><span class="hljs-keyword">print</span> (tinylist * <span class="hljs-number">2</span>)    <span class="hljs-meta"># 输出两次列表</span><br><span class="hljs-keyword">print</span> (list + tinylist) <span class="hljs-meta"># 连接列表</span><br></code></pre></td></tr></table></figure><p>与Python字符串不一样的是，列表中的元素是可以改变的：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = [<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span><br>[9, 2, 13, 14, 15, 6]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = []   <span class="hljs-comment"># 将对应的元素值设置为 []</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span><br>[9, 2, 6]<br></code></pre></td></tr></table></figure><p>List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。</p><p><strong>注意：</strong></p><ul><li>1、List写在方括号之间，元素用逗号隔开。</li><li>2、和字符串一样，list可以被索引和切片。</li><li>3、List可以使用+操作符进行拼接。</li><li>4、List中的元素是可以改变的。</li></ul><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/08/py-dict-1.png"><img src="https://www.runoob.com/wp-content/uploads/2014/08/py-dict-1.png" alt="img"></a></p><p>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br>     <br>    <span class="hljs-comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span><br>    inputWords = <span class="hljs-built_in">input</span>.split(<span class="hljs-string">&quot; &quot;</span>)<br> <br>    <span class="hljs-comment"># 翻转字符串</span><br>    <span class="hljs-comment"># 假设列表 list = [1,2,3,4],  </span><br>    <span class="hljs-comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span><br>    <span class="hljs-comment"># inputWords[-1::-1] 有三个参数</span><br>    <span class="hljs-comment"># 第一个参数 -1 表示最后一个元素</span><br>    <span class="hljs-comment"># 第二个参数为空，表示移动到列表末尾</span><br>    <span class="hljs-comment"># 第三个参数为步长，-1 表示逆向</span><br>    inputWords=inputWords[-<span class="hljs-number">1</span>::-<span class="hljs-number">1</span>]<br> <br>    <span class="hljs-comment"># 重新组合字符串</span><br>    output = <span class="hljs-string">&#x27; &#x27;</span>.join(inputWords)<br>     <br>    <span class="hljs-keyword">return</span> output<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">input</span> = <span class="hljs-string">&#x27;I like runoob&#x27;</span><br>    rw = reverseWords(<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(rw)<br></code></pre></td></tr></table></figure><h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。元组中的元素类型也可以不相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span> = ( <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">786</span> , <span class="hljs-number">2.23</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-number">70.2</span>  )<br>tinytuple = (<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>)<br><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">tuple</span>)             <span class="hljs-comment"># 输出完整元组</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">tuple</span>[<span class="hljs-number">0</span>])          <span class="hljs-comment"># 输出元组的第一个元素</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">tuple</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])        <span class="hljs-comment"># 输出从第二个元素开始到第三个元素</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">tuple</span>[<span class="hljs-number">2</span>:])         <span class="hljs-comment"># 输出从第三个元素开始的所有元素</span><br><span class="hljs-built_in">print</span> (tinytuple * <span class="hljs-number">2</span>)     <span class="hljs-comment"># 输出两次元组</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">tuple</span> + tinytuple) <span class="hljs-comment"># 连接元组</span><br></code></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p><p>其实，可以把字符串看作一种特殊的元组。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(tup[<span class="hljs-number">0</span>])</span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(tup[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>])</span><br>(2, 3, 4, 5)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span>  <span class="hljs-comment"># 修改元组元素的操作是非法的</span></span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>TypeError: &#x27;tuple&#x27; object does not support item assignment<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tup1</span> = ()    <span class="hljs-comment"># 空元组</span><br><span class="hljs-attr">tup2</span> = (<span class="hljs-number">20</span>,) <span class="hljs-comment"># 一个元素，需要在元素后添加逗号</span><br></code></pre></td></tr></table></figure><p>string、list 和 tuple 都属于 sequence（序列）。</p><p><strong>注意：</strong></p><ul><li>1、与字符串一样，元组的元素不能修改。</li><li>2、元组也可以被索引和切片，方法一样。</li><li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li><li>4、元组也可以使用+操作符进行拼接。</li></ul><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros">parame = &#123;value01,value02,<span class="hljs-built_in">..</span>.&#125;<br>或者<br><span class="hljs-built_in">set</span>(value)<br>sites = &#123;<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>, <span class="hljs-string">&#x27;Zhihu&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span>(sites)   # 输出集合，重复的元素被自动去掉<br><br><span class="hljs-comment"># 成员测试</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Runoob&#x27;</span> <span class="hljs-keyword">in</span> sites :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob 在集合中&#x27;</span>)<br><span class="hljs-keyword">else</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob 不在集合中&#x27;</span>)<br><br><br><span class="hljs-comment"># set可以进行集合运算</span><br>a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br>b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;alacazam&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-built_in">print</span>(a - b)     # a 和 b 的差集<br><br><span class="hljs-built_in">print</span>(a | b)     # a 和 b 的并集<br><br><span class="hljs-built_in">print</span>(a &amp; b)     # a 和 b 的交集<br><br><span class="hljs-built_in">print</span>(a ^ b)     # a 和 b 中不同时存在的元素<br></code></pre></td></tr></table></figure><h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;&#125;<br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&quot;1 - 菜鸟教程&quot;</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>]     = <span class="hljs-string">&quot;2 - 菜鸟工具&quot;</span><br><br>tinydict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;runoob&#x27;</span>,<span class="hljs-string">&#x27;code&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;site&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;<br><br><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;one&#x27;</span>])       <span class="hljs-comment"># 输出键为 &#x27;one&#x27; 的值</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">dict</span>[<span class="hljs-number">2</span>])           <span class="hljs-comment"># 输出键为 2 的值</span><br><span class="hljs-built_in">print</span> (tinydict)          <span class="hljs-comment"># 输出完整的字典</span><br><span class="hljs-built_in">print</span> (tinydict.keys())   <span class="hljs-comment"># 输出所有键</span><br><span class="hljs-built_in">print</span> (tinydict.values()) <span class="hljs-comment"># 输出所有值</span><br></code></pre></td></tr></table></figure><p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;&gt;&gt; <span class="hljs-title function_">dict</span>(<span class="hljs-params">[(<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-number">3</span>)]</span>)<br>&#123;<span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;<br>&gt;&gt;&gt; &#123;<span class="hljs-attr">x</span>: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-title function_">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)&#125;<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">6</span>: <span class="hljs-number">36</span>&#125;<br>&gt;&gt;&gt; <span class="hljs-title function_">dict</span>(<span class="hljs-params">Runoob=<span class="hljs-number">1</span>, Google=<span class="hljs-number">2</span>, Taobao=<span class="hljs-number">3</span></span>)<br>&#123;<span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p><p><strong>注意：</strong></p><ul><li>1、字典是一种映射类型，它的元素是键值对。</li><li>2、字典的关键字必须为不可变类型，且不能重复。</li><li>3、创建空字典使用 <strong>{ }</strong>。</li></ul><h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td>将x转换为一个整数</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td>将x转换到一个浮点数</td></tr><tr><td>[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td>创建一个复数</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td>将对象 x 转换为字符串</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td>将对象 x 转换为表达式字符串</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td>将序列 s 转换为一个元组</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td>将序列 s 转换为一个列表</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td>转换为可变集合</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td>创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td>转换为不可变集合</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td>将一个整数转换为一个字符</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td>将一个字符转换为它的整数值</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="Python3注释"><a href="#Python3注释" class="headerlink" title="Python3注释"></a>Python3注释</h2><p>确保对模块，函数，方法和行内注释使用正确的风格</p><p>Python中的注释有单行注释和多行注释；</p><p>Python中单行注释以#开头，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello, World!&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p>多行注释用三个单引号’’’ ‘’’或者三个双引号””” “””将注释括起来，例如：</p><h3 id="1、单引号（’’’）"><a href="#1、单引号（’’’）" class="headerlink" title="1、单引号（’’’）"></a>1、单引号（’’’）</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&#x27;&#x27;&#x27;<br>这是多行注释，用三个单引号<br>这是多行注释，用三个单引号 <br>这是多行注释，用三个单引号<br>&#x27;&#x27;&#x27;<br>print(&quot;Hello, World!&quot;)<br></code></pre></td></tr></table></figure><h3 id="2、双引号（”””）"><a href="#2、双引号（”””）" class="headerlink" title="2、双引号（”””）"></a>2、双引号（”””）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">这是多行注释，用三个双引号</span><br><span class="hljs-string">这是多行注释，用三个双引号 </span><br><span class="hljs-string">这是多行注释，用三个双引号</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Python运算符"><a href="#Python运算符" class="headerlink" title="Python运算符"></a>Python运算符</h1><p>Python语言支持以下类型的操作符：</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><h2 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h2><p>以下假设变量a为10，变量b为21：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 31</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -11</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 210</td></tr><tr><td>&#x2F;</td><td>除 - x 除以 y</td><td>b &#x2F; a 输出结果 2.1</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 1</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的21次方</td></tr><tr><td>&#x2F;&#x2F;</td><td>取整除 - 向下取接近商的整数</td><td><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table><h2 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h2><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于 - 比较对象是否相等</td><td>(a &#x3D;&#x3D; b) 返回 False。</td></tr><tr><td>!&#x3D;</td><td>不等于 - 比较两个对象是否不相等</td><td>(a !&#x3D; b) 返回 True。</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td><td>(a &gt; b) 返回 False。</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td>(a &lt; b) 返回 True。</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于 - 返回x是否大于等于y。</td><td>(a &gt;&#x3D; b) 返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于 - 返回x是否小于等于y。</td><td>(a &lt;&#x3D; b) 返回 True。</td></tr></tbody></table><h2 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h2><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取模赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>:&#x3D;</td><td>海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td>在这个示例中，赋值表达式可以避免调用 len() 两次:<code>if (n := len(a)) &gt; 10: print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td></tr></tbody></table><h2 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h2><p>按位运算符是把数字看作二进制来进行计算的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-number">0011 </span><span class="hljs-number">1100</span><br><br><span class="hljs-string">b</span> <span class="hljs-string">=</span> <span class="hljs-number">0000 </span><span class="hljs-number">1101</span><br><br><span class="hljs-string">-----------------</span><br><br><span class="hljs-string">a&amp;b</span> <span class="hljs-string">=</span> <span class="hljs-number">0000 </span><span class="hljs-number">1100</span><br><br><span class="hljs-string">a|b</span> <span class="hljs-string">=</span> <span class="hljs-number">0011 </span><span class="hljs-number">1101</span><br><br><span class="hljs-string">a^b</span> <span class="hljs-string">=</span> <span class="hljs-number">0011 </span><span class="hljs-number">0001</span><br><br><span class="hljs-string">~a</span>  <span class="hljs-string">=</span> <span class="hljs-number">1100 </span><span class="hljs-number">0011</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1</td><td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。<strong>~x</strong> 类似于 <strong>-x-1</strong></td><td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td><td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">60</span>            # <span class="hljs-number">60</span> = <span class="hljs-number">0011</span> <span class="hljs-number">1100</span> <br><span class="hljs-attribute">b</span> = <span class="hljs-number">13</span>            # <span class="hljs-number">13</span> = <span class="hljs-number">0000</span> <span class="hljs-number">1101</span> <br><span class="hljs-attribute">c</span> = <span class="hljs-number">0</span><br> <br><span class="hljs-attribute">c</span> = a &amp; b        # <span class="hljs-number">12</span> = <span class="hljs-number">0000</span> <span class="hljs-number">1100</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;1 - c 的值为：&quot;</span>, c)<br> <br><span class="hljs-attribute">c</span> = a | b        # <span class="hljs-number">61</span> = <span class="hljs-number">0011</span> <span class="hljs-number">1101</span> <br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;2 - c 的值为：&quot;</span>, c)<br> <br><span class="hljs-attribute">c</span> = a ^ b        # <span class="hljs-number">49</span> = <span class="hljs-number">0011</span> <span class="hljs-number">0001</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;3 - c 的值为：&quot;</span>, c)<br> <br><span class="hljs-attribute">c</span> = ~a           # -<span class="hljs-number">61</span> = <span class="hljs-number">1100</span> <span class="hljs-number">0011</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;4 - c 的值为：&quot;</span>, c)<br> <br><span class="hljs-attribute">c</span> = a &lt;&lt; <span class="hljs-number">2</span>       # <span class="hljs-number">240</span> = <span class="hljs-number">1111</span> <span class="hljs-number">0000</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;5 - c 的值为：&quot;</span>, c)<br> <br><span class="hljs-attribute">c</span> = a &gt;&gt; <span class="hljs-number">2</span>       # <span class="hljs-number">15</span> = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;6 - c 的值为：&quot;</span>, c)<br></code></pre></td></tr></table></figure><h2 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量a为10，b为20：</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td>(a and b) 返回 20。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10。</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td>not(a and b) 返回 False</td></tr></tbody></table><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = 10<br>b = 20<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">and</span> b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - 变量 a 和 b 都为 true&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - 变量 a 和 b 有一个不为 true&quot;</span>)<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">or</span> b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - 变量 a 和 b 都不为 true&quot;</span>)<br> <br><span class="hljs-comment"># 修改变量 a 的值</span><br>a = 0<br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">and</span> b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;3 - 变量 a 和 b 都为 true&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;3 - 变量 a 和 b 有一个不为 true&quot;</span>)<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">or</span> b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;4 - 变量 a 和 b 都不为 true&quot;</span>)<br> <br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>( a <span class="hljs-keyword">and</span> b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;5 - 变量 a 和 b 都为 true&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = 10<br>b = 20<br>list = [1, 2, 3, 4, 5 ]<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span>)<br> <br><span class="hljs-keyword">if</span> ( b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span>)<br> <br><span class="hljs-comment"># 修改变量 a 的值</span><br>a = 2<br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td><td><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td><strong>x is not y</strong> ， 类似 <strong>id(a) !&#x3D; id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p>**注：**id()函数用于获取对象内存地址。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = 20<br>b = 20<br> <br><span class="hljs-keyword">if</span> ( a is b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - a 和 b 有相同的标识&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - a 和 b 没有相同的标识&quot;</span>)<br> <br><span class="hljs-keyword">if</span> ( id(a) == id(b) ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - a 和 b 有相同的标识&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - a 和 b 没有相同的标识&quot;</span>)<br> <br><span class="hljs-comment"># 修改变量 b 的值</span><br>b = 30<br><span class="hljs-keyword">if</span> ( a is b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;3 - a 和 b 有相同的标识&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;3 - a 和 b 没有相同的标识&quot;</span>)<br> <br><span class="hljs-keyword">if</span> ( a is <span class="hljs-keyword">not</span> b ):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;4 - a 和 b 没有相同的标识&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;4 - a 和 b 有相同的标识&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>is 与 &#x3D;&#x3D; 区别：</strong></p><p>is 用于判断两个变量引用对象是否为同一个， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt;<span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[1, 2, 3]</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">b</span> is <span class="hljs-selector-tag">a</span> <br>True<br>&gt;&gt;&gt; <span class="hljs-selector-tag">b</span> == <span class="hljs-selector-tag">a</span><br>True<br>&gt;&gt;&gt; <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[:]</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">b</span> is <span class="hljs-selector-tag">a</span><br>False<br>&gt;&gt;&gt; <span class="hljs-selector-tag">b</span> == <span class="hljs-selector-tag">a</span><br>True<br></code></pre></td></tr></table></figure><h2 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>指数 (最高优先级)</td></tr><tr><td>~ + -</td><td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘，除，求余数和取整除</td></tr><tr><td>+ -</td><td>加法减法</td></tr><tr><td>&gt;&gt; &lt;&lt;</td><td>右移，左移运算符</td></tr><tr><td>&amp;</td><td>位 ‘AND’</td></tr><tr><td>^ |</td><td>位运算符</td></tr><tr><td>&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td>比较运算符</td></tr><tr><td>&#x3D;&#x3D; !&#x3D;</td><td>等于运算符</td></tr><tr><td>&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td>赋值运算符</td></tr><tr><td>is is not</td><td>身份运算符</td></tr><tr><td>in not in</td><td>成员运算符</td></tr><tr><td>not and or</td><td>逻辑运算符</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">20</span><br><span class="hljs-attribute">b</span> = <span class="hljs-number">10</span><br><span class="hljs-attribute">c</span> = <span class="hljs-number">15</span><br><span class="hljs-attribute">d</span> = <span class="hljs-number">5</span><br><span class="hljs-attribute">e</span> = <span class="hljs-number">0</span><br> <br><span class="hljs-attribute">e</span> = (a + b) * c / d       #( <span class="hljs-number">30</span> * <span class="hljs-number">15</span> ) / <span class="hljs-number">5</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;(a + b) * c / d 运算结果为：&quot;</span>,  e)<br> <br><span class="hljs-attribute">e</span> = ((a + b) * c) / d     # (<span class="hljs-number">30</span> * <span class="hljs-number">15</span> ) / <span class="hljs-number">5</span><br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;((a + b) * c) / d 运算结果为：&quot;</span>,  e)<br> <br><span class="hljs-attribute">e</span> = (a + b) * (c / d)    # (<span class="hljs-number">30</span>) * (<span class="hljs-number">15</span>/<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;(a + b) * (c / d) 运算结果为：&quot;</span>,  e)<br> <br><span class="hljs-attribute">e</span> = a + (b * c) / d      #  <span class="hljs-number">20</span> + (<span class="hljs-number">150</span>/<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;a + (b * c) / d 运算结果为：&quot;</span>,  e)<br></code></pre></td></tr></table></figure><p>and 拥有更高优先级:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">x</span> = <span class="hljs-variable"><span class="hljs-literal">True</span></span><br><span class="hljs-variable">y</span> = <span class="hljs-variable"><span class="hljs-literal">False</span></span><br><span class="hljs-variable">z</span> = <span class="hljs-variable"><span class="hljs-literal">False</span></span><br> <br><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> <span class="hljs-variable"><span class="hljs-keyword">or</span></span> <span class="hljs-variable">y</span> <span class="hljs-variable"><span class="hljs-keyword">and</span></span> <span class="hljs-variable">z</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;yes&quot;</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;no&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>**注意：**Pyhton3 已不支持 &lt;&gt; 运算符，可以使用 !&#x3D; 代替，如果你一定要使用这种比较运算符，可以使用以下的方式：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> barry_as_FLUFL</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">1</span> &lt;&gt; <span class="hljs-number">2</span></span><br>True<br></code></pre></td></tr></table></figure><h1 id="Python3数字（Number）"><a href="#Python3数字（Number）" class="headerlink" title="Python3数字（Number）"></a>Python3数字（Number）</h1><p>Python数字数据类型用于存储数值。</p><p>数据类型是不允许改变的，这就意味着如果改变数字数据类型的值，将重新分配内存空间。</p><p>可以使用del语句删除一些数字对象的引用。</p><p>也可以通过使用del语句删除单个或多个对象的引用，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">var</span><br><span class="hljs-selector-tag">del</span> var_a, var_b<br></code></pre></td></tr></table></figure><p>Python支持三种不同的数值类型：</p><ul><li><strong>整型(Int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。</li><li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x 102 &#x3D; 250）</li><li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li></ul><p>我们可以使用十六进制和八进制来代表整数:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">number = <span class="hljs-number">0xA0F</span> <span class="hljs-comment"># 十六进制</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">number</span><br>2575<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">number=<span class="hljs-number">0o37</span> <span class="hljs-comment"># 八进制</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">number</span><br>31<br></code></pre></td></tr></table></figure><ul><li>Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li></ul><h2 id="Python数字类型转换"><a href="#Python数字类型转换" class="headerlink" title="Python数字类型转换"></a>Python数字类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><ul><li><strong>int(x)</strong> 将x转换为一个整数。</li><li><strong>float(x)</strong> 将x转换到一个浮点数。</li><li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li><li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li></ul><p>以下实例将浮点数变量a转换为整数：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = <span class="hljs-number">1.0</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">int</span>(a)</span><br>1<br></code></pre></td></tr></table></figure><h2 id="Python数字运算"><a href="#Python数字运算" class="headerlink" title="Python数字运算"></a>Python数字运算</h2><p>Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。</p><p>表达式的语法很直白： <strong>+</strong>, <strong>-</strong>, ***** 和 <strong>&#x2F;</strong>, 和其它语言（如Pascal或C）里一样。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> + <span class="hljs-number">2</span></span><br>4<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">50</span> - <span class="hljs-number">5</span>*<span class="hljs-number">6</span></span><br>20<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">(<span class="hljs-number">50</span> - <span class="hljs-number">5</span>*<span class="hljs-number">6</span>) / <span class="hljs-number">4</span></span><br>5.0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">8</span> / <span class="hljs-number">5</span>  <span class="hljs-comment"># 总是返回一个浮点数</span></span><br>1.6<br></code></pre></td></tr></table></figure><p>**注意：**在不同的机器上浮点运算的结果可能会不一样。</p><p>在整数除法中，除法 <strong>&#x2F;</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>&#x2F;&#x2F;</strong> ：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">17</span> / <span class="hljs-number">3</span>  <span class="hljs-comment"># 整数除法返回浮点型</span></span><br>5.666666666666667<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">17</span> // <span class="hljs-number">3</span>  <span class="hljs-comment"># 整数除法返回向下取整后的结果</span></span><br>5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">17</span> % <span class="hljs-number">3</span>  <span class="hljs-comment"># ％操作符返回除法的余数</span></span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">5</span> * <span class="hljs-number">3</span> + <span class="hljs-number">2</span> </span><br>17<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：&#x2F;&#x2F; 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">7</span>//<span class="hljs-number">2</span></span><br>3<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">7.0</span>//<span class="hljs-number">2</span></span><br>3.0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">7</span>//<span class="hljs-number">2.0</span></span><br>3.0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <br></code></pre></td></tr></table></figure><p>等号&#x3D;用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何的结果。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">width = <span class="hljs-number">20</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">height = <span class="hljs-number">5</span>*<span class="hljs-number">9</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">width * height</span><br>900<br></code></pre></td></tr></table></figure><p>Python 可以使用 ****** 操作来进行幂运算：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">5</span> ** <span class="hljs-number">2</span>  <span class="hljs-comment"># 5 的平方</span></span><br>25<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> ** <span class="hljs-number">7</span>  <span class="hljs-comment"># 2的7次方</span></span><br>128<br></code></pre></td></tr></table></figure><p>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">&gt;&gt;&gt; n   # 尝试访问一个未定义的变量<br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>NameError: name <span class="hljs-string">&#x27;n&#x27;</span> <span class="hljs-keyword">is</span> not defined<br></code></pre></td></tr></table></figure><p>不同类型的数混合运算时会将整数转换为浮点数：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">3</span> * <span class="hljs-number">3.75</span> / <span class="hljs-number">1.5</span></span><br>7.5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">7.0</span> / <span class="hljs-number">2</span></span><br>3.5<br></code></pre></td></tr></table></figure><p>在交互模式中，最后被输出的表达式结果被赋值给变量_。例如：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tax = <span class="hljs-number">12.5</span> / <span class="hljs-number">100</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">price = <span class="hljs-number">100.50</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">price * tax</span><br>12.5625<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">price + _</span><br>113.0625<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">round</span>(_, <span class="hljs-number">2</span>)</span><br>113.06<br></code></pre></td></tr></table></figure><p>此处，_变量应被用户视为只读变量。</p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table><thead><tr><th>函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td>返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td>[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td>返回数字x的平方根。</td></tr></tbody></table><h2 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h2><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><p>Python包含以下常用随机数函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>[choice(seq)]</td><td>从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td>[randrange ([start,] stop [,step])]</td><td>从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td>[random()]</td><td>随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td>[seed([x])]</td><td>改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td>[shuffle(lst)]</td><td>将序列的所有元素随机排序</td></tr><tr><td>[uniform(x, y)]</td><td>随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>Python包括以下三角函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>[acos(x)]</td><td>返回x的反余弦弧度值。</td></tr><tr><td>[asin(x)]</td><td>返回x的反正弦弧度值。</td></tr><tr><td>[atan(x)]</td><td>返回x的反正切弧度值。</td></tr><tr><td>[atan2(y, x)]</td><td>返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td>[cos(x)]</td><td>返回x的弧度的余弦值。</td></tr><tr><td>[hypot(x, y)]</td><td>返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td>[sin(x)]</td><td>返回的x弧度的正弦值。</td></tr><tr><td>[tan(x)]</td><td>返回x弧度的正切值。</td></tr><tr><td>[degrees(x)]</td><td>将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td></tr><tr><td>[radians(x)]</td><td>将角度转换为弧度</td></tr></tbody></table><h2 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h2><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>pi</td><td>数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td>e</td><td>数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><h1 id="Python3字符串"><a href="#Python3字符串" class="headerlink" title="Python3字符串"></a>Python3字符串</h1><p>字符串是 Python 中最常用的数据类型。我们可以使用引号( <strong>‘</strong> 或 <strong>“</strong> )来创建字符串。</p><p>创建字符串很简单，只要为变量分配一个值即可。</p><h2 id="Python访问字符串中的值"><a href="#Python访问字符串中的值" class="headerlink" title="Python访问字符串中的值"></a>Python访问字符串中的值</h2><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</p><p>Python 访问子字符串，可以使用方括号 <strong>[]</strong> 来截取字符串，字符串的截取的语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标]</span><br></code></pre></td></tr></table></figure><p>索引值以 <strong>0</strong> 为开始值，<strong>-1</strong> 为从末尾的开始位置。</p><p><a href="https://static.runoob.com/wp-content/uploads/123456-20200923-1.svg"><img src="https://static.runoob.com/wp-content/uploads/123456-20200923-1.svg" alt="img"></a></p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/python-str-runoob.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/python-str-runoob.png" alt="img"></a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var1 = <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>var2 = <span class="hljs-string">&quot;Runoob&quot;</span><br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;var1[0]: &quot;</span>, var1[0])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;var2[1:5]: &quot;</span>, var2[1:5])<br></code></pre></td></tr></table></figure><p>以上实例执行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var1</span>[<span class="hljs-number">0</span>]:  H<br><span class="hljs-attribute">var2</span>[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]:  unoo<br></code></pre></td></tr></table></figure><h2 id="Python字符串更新"><a href="#Python字符串更新" class="headerlink" title="Python字符串更新"></a>Python字符串更新</h2><p>可以截取字符串的一部分并与其他字段拼接，如下实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var1 = <span class="hljs-string">&#x27;Hello World!&#x27;</span><br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;已更新字符串 : &quot;</span>, var1[:6] + <span class="hljs-string">&#x27;Runoob!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上实例执行结果</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">已更新字符串 :  <span class="hljs-type">Hello</span> Runoob!<br></code></pre></td></tr></table></figure><h2 id="Python转义字符"><a href="#Python转义字符" class="headerlink" title="Python转义字符"></a>Python转义字符</h2><p>在需要在字符中使用特殊字符时，python 用反斜杠 \ 转义字符。</p><table><thead><tr><th>转义字符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>(在行尾时)</td><td>续行符</td><td><code>&gt;&gt;&gt; print(&quot;line1 \ ... line2 \ ... line3&quot;) line1 line2 line3 &gt;&gt;&gt;</code></td></tr><tr><td>\</td><td>反斜杠符号</td><td><code>&gt;&gt;&gt; print(&quot;\\&quot;) \</code></td></tr><tr><td>‘</td><td>单引号</td><td><code>&gt;&gt;&gt; print(&#39;\&#39;&#39;) &#39;</code></td></tr><tr><td>“</td><td>双引号</td><td><code>&gt;&gt;&gt; print(&quot;\&quot;&quot;) &quot;</code></td></tr><tr><td>\a</td><td>响铃</td><td><code>&gt;&gt;&gt; print(&quot;\a&quot;)</code>执行后电脑有响声。</td></tr><tr><td>\b</td><td>退格(Backspace)</td><td><code>&gt;&gt;&gt; print(&quot;Hello \b World!&quot;) Hello World!</code></td></tr><tr><td>\000</td><td>空</td><td><code>&gt;&gt;&gt; print(&quot;\000&quot;) &gt;&gt;&gt;</code></td></tr><tr><td>\n</td><td>换行</td><td><code>&gt;&gt;&gt; print(&quot;\n&quot;) &gt;&gt;&gt;</code></td></tr><tr><td>\v</td><td>纵向制表符</td><td><code>&gt;&gt;&gt; print(&quot;Hello \v World!&quot;) Hello World! &gt;&gt;&gt;</code></td></tr><tr><td>\t</td><td>横向制表符</td><td><code>&gt;&gt;&gt; print(&quot;Hello \t World!&quot;) Hello World! &gt;&gt;&gt;</code></td></tr><tr><td>\r</td><td>回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成。</td><td><code>&gt;&gt;&gt; print(&quot;Hello\rWorld!&quot;) World! &gt;&gt;&gt; print(&#39;google runoob taobao\r123456&#39;) 123456 runoob taobao</code></td></tr><tr><td>\f</td><td>换页</td><td><code>&gt;&gt;&gt; print(&quot;Hello \f World!&quot;) Hello World! &gt;&gt;&gt;</code></td></tr><tr><td>\yyy</td><td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td><td><code>&gt;&gt;&gt; print(&quot;\110\145\154\154\157\40\127\157\162\154\144\41&quot;) Hello World!</code></td></tr><tr><td>\xyy</td><td>十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td><td><code>&gt;&gt;&gt; print(&quot;\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21&quot;) Hello World!</code></td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td><td></td></tr></tbody></table><h2 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h2><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>字符串连接</td><td>a + b 输出结果： HelloPython</td></tr><tr><td>*</td><td>重复输出字符串</td><td>a*2 输出结果：HelloHello</td></tr><tr><td>[]</td><td>通过索引获取字符串中字符</td><td>a[1] 输出结果 <strong>e</strong></td></tr><tr><td>[ : ]</td><td>截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td><td>a[1:4] 输出结果 <strong>ell</strong></td></tr><tr><td>in</td><td>成员运算符 - 如果字符串中包含给定的字符返回 True</td><td><strong>‘H’ in a</strong> 输出结果 True</td></tr><tr><td>not in</td><td>成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td><strong>‘M’ not in a</strong> 输出结果 True</td></tr><tr><td>r&#x2F;R</td><td>原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td><code>print( r&#39;\n&#39; ) print( R&#39;\n&#39; )</code></td></tr><tr><td>%</td><td>格式字符串</td><td>请看下一节内容。</td></tr></tbody></table><h2 id="Python字符串格式化"><a href="#Python字符串格式化" class="headerlink" title="Python字符串格式化"></a>Python字符串格式化</h2><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p><p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;我叫 <span class="hljs-variable">%s</span> 今年 <span class="hljs-variable">%d</span> 岁!&quot;</span> % (<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>python字符串格式化符号：</p><table><thead><tr><th>符 号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整型</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数（大写）</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%f 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><p>格式化操作符辅助指令：</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>用做左对齐</td></tr><tr><td>+</td><td>在正数前面显示加号( + )</td></tr><tr><td></td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n.</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>python2.6开始，新增了一种格式化字符串的函数str.format(),它增强了字符串格式化的功能。</p><h2 id="Python三引号"><a href="#Python三引号" class="headerlink" title="Python三引号"></a>Python三引号</h2><p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">para_str = <span class="hljs-string">&quot;&quot;&quot;这是一个多行字符串的实例</span><br><span class="hljs-string">多行字符串可以使用制表符</span><br><span class="hljs-string">TAB ( \t )。</span><br><span class="hljs-string">也可以使用换行符 [ \n ]。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span> (para_str)<br></code></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">这是一个多行字符串的实例<br>多行字符串可以使用制表符<br><span class="hljs-literal">TAB</span> (    )。<br>也可以使用换行符 [ <br> ]。<br></code></pre></td></tr></table></figure><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p><p>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">errHTML = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span><br><span class="hljs-string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span><br><span class="hljs-string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span><br><span class="hljs-string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span><br><span class="hljs-string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span><br><span class="hljs-string">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</span><br><span class="hljs-string">&lt;/BODY&gt;&lt;/HTML&gt;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>cursor.execute(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">CREATE TABLE users (  </span><br><span class="hljs-string">login VARCHAR(8), </span><br><span class="hljs-string">uid INTEGER,</span><br><span class="hljs-string">prid INTEGER)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</p><p>之前我们习惯用百分号 (%):</p><p><strong>f-string</strong> 格式化字符串以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Runoob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;Hello <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>  <span class="hljs-comment"># 替换变量</span></span><br>&#x27;Hello Runoob&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-number">1</span>+<span class="hljs-number">2</span>&#125;</span>&#x27;</span>         <span class="hljs-comment"># 使用表达式</span></span><br>&#x27;3&#x27;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">w = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;w[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>: <span class="hljs-subst">&#123;w[<span class="hljs-string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br>&#x27;Runoob: www.runoob.com&#x27;<br></code></pre></td></tr></table></figure><p>用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。</p><p>在 Python 3.8 的版本中可以使用 <strong>&#x3D;</strong> 符号来拼接运算表达式与结果：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x = <span class="hljs-number">1</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;x+<span class="hljs-number">1</span>&#125;</span>&#x27;</span>)   <span class="hljs-comment"># Python 3.6</span></span><br>2<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x = <span class="hljs-number">1</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;x+<span class="hljs-number">1</span>=&#125;</span>&#x27;</span>)   <span class="hljs-comment"># Python 3.8</span></span><br>&#x27;x+1=2&#x27;<br></code></pre></td></tr></table></figure><h2 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h2><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p><p>在Python3中，所有的字符串都是Unicode字符串。</p><h2 id="Python的字符串内建函数"><a href="#Python的字符串内建函数" class="headerlink" title="Python的字符串内建函数"></a>Python的字符串内建函数</h2><table><thead><tr><th>序号</th><th>方法及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a> 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg&#x3D; 0,end&#x3D;len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding&#x3D;”utf-8”, errors&#x3D;”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding&#x3D;’UTF-8’,errors&#x3D;’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize&#x3D;8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg&#x3D;0, end&#x3D;len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg&#x3D;0, end&#x3D;len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td>11</td><td><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td>14</td><td><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td>15</td><td><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td>16</td><td><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td>17</td><td><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td>18</td><td><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td>19</td><td><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr><tr><td>20</td><td>[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td>21</td><td><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr><tr><td>22</td><td><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr><tr><td>23</td><td><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td>24</td><td><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr><tr><td>25</td><td><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr><tr><td>26</td><td>[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td>27</td><td><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg&#x3D;0,end&#x3D;len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td>28</td><td><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg&#x3D;0, end&#x3D;len(string))</a> 类似于 index()，不过是从右边开始.</td></tr><tr><td>29</td><td>[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td>30</td><td><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串字符串末尾的空格.</td></tr><tr><td>31</td><td><a href="https://www.runoob.com/python3/python3-string-split.html">split(str&#x3D;””, num&#x3D;string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td>32</td><td>[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td>33</td><td><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg&#x3D;0,end&#x3D;len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td>34</td><td>[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td>35</td><td><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td>36</td><td><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td>37</td><td><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars&#x3D;””)</a> 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td>38</td><td><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr><tr><td>39</td><td><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td>40</td><td><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h1 id="Python3列表"><a href="#Python3列表" class="headerlink" title="Python3列表"></a>Python3列表</h1><p>序列是 Python 中最基本的数据结构。</p><p>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。</p><p>Python 有 6 个序列的内置类型，但最常见的是列表和元组。</p><p>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</p><p>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。</p><p>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。</p><p>列表的数据项不需要具有相同的类型</p><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">list1</span> = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>]<br><span class="hljs-attr">list2</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br><span class="hljs-attr">list3</span> = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]<br><span class="hljs-attr">list4</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h2><p>与字符串的索引一样，列表索引从0开始，第二个索引是1，以此类推。</p><p>通过索引列表可以进行截取、组合等操作。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/positive-indexes-1.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/positive-indexes-1.png" alt="img"></a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">list = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[<span class="hljs-number">0</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[<span class="hljs-number">1</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[<span class="hljs-number">2</span>] )</span></span><br></code></pre></td></tr></table></figure><p>索引也可以从尾部开始，最后一个元素的索引为 <strong>-1</strong>，往前一位为 <strong>-2</strong>，以此类推。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/negative-indexes.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/negative-indexes.png" alt="img"></a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">list = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[-<span class="hljs-number">1</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[-<span class="hljs-number">2</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[-<span class="hljs-number">3</span>] )</span></span><br></code></pre></td></tr></table></figure><p>使用下标索引来访问列表中的值，同样你也可以使用方括号 <strong>[]</strong> 的形式截取字符，如下所示：</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/first-slice.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/first-slice.png" alt="img"></a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nums = <span class="hljs-selector-attr">[10, 20, 30, 40, 50, 60, 70, 80, 90]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(nums[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])</span></span><br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[10, 20, 30, 40]</span><br></code></pre></td></tr></table></figure><p>使用负数索引值截取：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&quot;Zhihu&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>, <span class="hljs-string">&quot;Wiki&quot;</span>]<br> <br><span class="hljs-comment"># 读取第二位</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;list[1]: &quot;</span>, list[1])<br><span class="hljs-comment"># 从第二位开始（包含）截取到倒数第二位（不包含）</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;list[1:-2]: &quot;</span>, list[1:-2])<br></code></pre></td></tr></table></figure><h2 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h2><p>可以对列表的数据项进行修改或更新，也可以使用append()方法来添加列表项，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000]<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;第三个元素为 : &quot;</span>, list[2])<br>list[2] = 2001<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;更新后的第三个元素为 : &quot;</span>, list[2])<br> <br>list1 = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>]<br>list1.append(<span class="hljs-string">&#x27;Baidu&#x27;</span>)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;更新后的列表 : &quot;</span>, list1)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">第三个元素为 :  1997<br>更新后的第三个元素为 :  2001<br>更新后的列表 :  [&#x27;<span class="hljs-type">Google</span>&#x27;, <span class="hljs-symbol">&#x27;Runoob</span>&#x27;, <span class="hljs-symbol">&#x27;Taobao</span>&#x27;, <span class="hljs-symbol">&#x27;Baidu</span>&#x27;]<br></code></pre></td></tr></table></figure><h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><p>可以使用del语句来删除列表中的元素，如下实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000]<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;原始列表 : &quot;</span>, list)<br>del list[2]<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;删除第三个元素 : &quot;</span>, list)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">原始列表 :  <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000]</span><br>删除第三个元素 :  <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 2000]</span><br></code></pre></td></tr></table></figure><h2 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h2><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td>3</td><td>长度</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td>[1, 2, 3, 4, 5, 6]</td><td>组合</td></tr><tr><td>[‘Hi!’] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>重复</td></tr><tr><td>3 in [1, 2, 3]</td><td>True</td><td>元素是否存在于列表中</td></tr><tr><td>for x in [1, 2, 3]: print(x, end&#x3D;” “)</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><h2 id="Python列表截取与拼接"><a href="#Python列表截取与拼接" class="headerlink" title="Python列表截取与拼接"></a>Python列表截取与拼接</h2><p>Python的列表截取与字符串操作类型，如下所示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">L</span>=[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>]<br></code></pre></td></tr></table></figure><p>操作：</p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>L[2]</td><td>‘Taobao’</td><td>读取第三个元素</td></tr><tr><td>L[-2]</td><td>‘Runoob’</td><td>从右侧开始读取倒数第二个元素: count from the right</td></tr><tr><td>L[1:]</td><td>[‘Runoob’, ‘Taobao’]</td><td>输出从第二个元素开始后的所有元素</td></tr></tbody></table><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&gt;&gt;&gt;<span class="hljs-symbol">L</span>=[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>]<br>&gt;&gt;&gt; <span class="hljs-symbol">L</span>[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;Taobao&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-symbol">L</span>[<span class="hljs-number">-2</span>]<br><span class="hljs-string">&#x27;Runoob&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-symbol">L</span>[<span class="hljs-number">1</span>:]<br>[<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>列表还支持拼接操作：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">&gt;&gt;&gt;squares = [1, 4, 9, 16, 25]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">squares += [<span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">squares</span><br>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>使用嵌套列表即在列表里创建其他列表，例如：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&gt;&gt;&gt;a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>&gt;&gt;&gt; n = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&gt;&gt;&gt; x = [a, n]<br>&gt;&gt;&gt; x<br>[[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]<br>&gt;&gt;&gt; x[<span class="hljs-number">0</span>]<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>&gt;&gt;&gt; x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Python列表函数-方法"><a href="#Python列表函数-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h2><p>Python包含以下函数：</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td>[len(list)] 列表元素个数</td></tr><tr><td>2</td><td>[max(list)] 返回列表元素最大值</td></tr><tr><td>3</td><td>[min(list)] 返回列表元素最小值</td></tr><tr><td>4</td><td>[list(seq)] 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法：</p><table><thead><tr><th>序号</th><th>方法</th></tr></thead><tbody><tr><td>1</td><td>[list.append(obj)]在列表末尾添加新的对象</td></tr><tr><td>2</td><td>[list.count(obj)] 统计某个元素在列表中出现的次数</td></tr><tr><td>3</td><td>[list.extend(seq)] 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>4</td><td>[list.index(obj)]从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>5</td><td>[list.insert(index, obj)] 将对象插入列表</td></tr><tr><td>6</td><td>[list.pop([index&#x3D;-1])] 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>7</td><td>[list.remove(obj)] 移除列表中某个值的第一个匹配项</td></tr><tr><td>8</td><td>[list.reverse()]反向列表中元素</td></tr><tr><td>9</td><td>[list.sort( key&#x3D;None, reverse&#x3D;False)]对原列表进行排序</td></tr><tr><td>10</td><td>[list.clear()]清空列表</td></tr><tr><td>11</td><td>[list.copy()]复制列表</td></tr></tbody></table><h1 id="Python3元组"><a href="#Python3元组" class="headerlink" title="Python3元组"></a>Python3元组</h1><p>Python的元组与列表类似，不同之处在于元祖的元素不能修改。</p><p>元组使用小括号()，列表使用方括号[]。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup1 = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> )</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup3 = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>   <span class="hljs-comment">#  不需要括号也可以</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(tup3)</span><br>&lt;class &#x27;tuple&#x27;&gt;<br></code></pre></td></tr></table></figure><p>创建空元组</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">tup1</span> <span class="hljs-operator">=</span> ()<br></code></pre></td></tr></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>tup1 = (<span class="hljs-number">50</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(tup1)     <span class="hljs-comment"># 不加逗号，类型为整型</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>tup1 = (<span class="hljs-number">50</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(tup1)     <span class="hljs-comment"># 加上逗号，类型为元组</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等。</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/04/py-tup-10-26.png"><img src="https://www.runoob.com/wp-content/uploads/2016/04/py-tup-10-26.png" alt="img"></a></p><h2 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h2><p>元组可以使用下标索引来访问元组中的值，如下实例:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tup1</span> = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>)<br><span class="hljs-attribute">tup2</span> = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> )<br> <br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;tup1[0]: &quot;</span>, tup1[<span class="hljs-number">0</span>])<br><span class="hljs-attribute">print</span> (<span class="hljs-string">&quot;tup2[1:5]: &quot;</span>, tup2[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tup1</span>[<span class="hljs-number">0</span>]:  Google<br><span class="hljs-attribute">tup2</span>[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]:  (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h2 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h2><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">tup1 = (12, 34.56)<br>tup2 = (<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>)<br> <br><span class="hljs-comment"># 以下修改元组元素操作是非法的。</span><br><span class="hljs-comment"># tup1[0] = 100</span><br> <br><span class="hljs-comment"># 创建一个新的元组</span><br>tup3 = tup1 + tup2<br><span class="hljs-built_in">print</span> (tup3)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">12</span>, <span class="hljs-number">34.56</span>, <span class="hljs-symbol">&#x27;abc</span>&#x27;, <span class="hljs-symbol">&#x27;xyz</span>&#x27;)<br></code></pre></td></tr></table></figure><h2 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h2><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">tup = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000)<br> <br><span class="hljs-built_in">print</span> (tup)<br>del tup<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;删除后的元组 tup : &quot;</span>)<br><span class="hljs-built_in">print</span> (tup)<br></code></pre></td></tr></table></figure><p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">删除后的元组 tup : <br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">8</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    <span class="hljs-keyword">print</span> (tup)<br>NameError: name <span class="hljs-string">&#x27;tup&#x27;</span> <span class="hljs-keyword">is</span> not defined<br></code></pre></td></tr></table></figure><h2 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h2><p>与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len((1, 2, 3))</td><td>3</td><td>计算元素个数</td></tr><tr><td>(1, 2, 3) + (4, 5, 6)</td><td>(1, 2, 3, 4, 5, 6)</td><td>连接</td></tr><tr><td>(‘Hi!’,) * 4</td><td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td>复制</td></tr><tr><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td></tr><tr><td>for x in (1, 2, 3): print (x,)</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><h2 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h2><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</p><p>元组：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tup</span> = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Wiki&#x27;</span>, <span class="hljs-string">&#x27;Weibo&#x27;</span>,<span class="hljs-string">&#x27;Weixin&#x27;</span>)<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/04/py-tup-7.png"><img src="https://www.runoob.com/wp-content/uploads/2016/04/py-tup-7.png" alt="img"></a></p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>tup[1]</td><td>‘Runoob’</td><td>读取第二个元素</td></tr><tr><td>tup[-2]</td><td>‘Weibo’</td><td>反向读取，读取倒数第二个元素</td></tr><tr><td>tup[1:]</td><td>(‘Runoob’, ‘Taobao’, ‘Wiki’, ‘Weibo’, ‘Weixin’)</td><td>截取元素，从第二个开始后的所有元素。</td></tr><tr><td>tup[1:4]</td><td>(‘Runoob’, ‘Taobao’, ‘Wiki’)</td><td>截取元素，从第二个开始到第四个元素（索引为 3）。</td></tr></tbody></table><p>运行实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>tup = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Wiki&#x27;</span>, <span class="hljs-string">&#x27;Weibo&#x27;</span>,<span class="hljs-string">&#x27;Weixin&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tup[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;Runoob&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tup[-<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;Weibo&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tup[<span class="hljs-number">1</span>:]<br>(<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Wiki&#x27;</span>, <span class="hljs-string">&#x27;Weibo&#x27;</span>, <span class="hljs-string">&#x27;Weixin&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tup[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>(<span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Wiki&#x27;</span>)<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h2 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h2><p>Python元组包含了以下内置函数</p><table><thead><tr><th>序号</th><th>方法及描述</th><th>实例</th></tr></thead><tbody><tr><td>1</td><td>len(tuple) 计算元组元素个数。</td><td><code>&gt;&gt;&gt; tuple1 = (&#39;Google&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;) &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt;</code></td></tr><tr><td>2</td><td>max(tuple) 返回元组中元素最大值。</td><td><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; max(tuple2) &#39;8&#39; &gt;&gt;&gt;</code></td></tr><tr><td>3</td><td>min(tuple) 返回元组中元素最小值。</td><td><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; min(tuple2) &#39;4&#39; &gt;&gt;&gt;</code></td></tr><tr><td>4</td><td>tuple(iterable) 将可迭代系列转换为元组。</td><td><code>&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 (&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)</code></td></tr></tbody></table><h3 id="关于元组是不可变的"><a href="#关于元组是不可变的" class="headerlink" title="关于元组是不可变的"></a>关于元组是不可变的</h3><p>所谓的元组是不可变指的是元组所指向的内存中的内容不可变。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup = (<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;g&#x27;</span>     <span class="hljs-comment"># 不支持修改元素</span></span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>TypeError: &#x27;tuple&#x27; object does not support item assignment<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">id</span>(tup)     <span class="hljs-comment"># 查看内存地址</span></span><br>4440687904<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">id</span>(tup)</span><br>4441088800    # 内存地址不一样了<br></code></pre></td></tr></table></figure><p>从以上实例可以看出，重新赋值的元组tup，绑定到新的对象了，不是修改了原来的对象。</p><h1 id="Python3字典"><a href="#Python3字典" class="headerlink" title="Python3字典"></a>Python3字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p><p>字典的每个键值对key&#x3D;&gt;value用冒号：分割，每个对之间用逗号（，）分割，整个字典包括在花括号{}中，格式如下所示：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">d = &#123;key1 : <span class="hljs-type">value1</span>, key2 : <span class="hljs-type">value2</span>, key3 : <span class="hljs-type">value3</span> &#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/04/py-dict-3.png"><img src="https://www.runoob.com/wp-content/uploads/2016/04/py-dict-3.png" alt="img"></a></p><p>键必须是唯一的，但值则不必。</p><p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</p><p>一个简单的字典实例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;likes&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/04/py-dict-2.png"><img src="https://www.runoob.com/wp-content/uploads/2016/04/py-dict-2.png" alt="img"></a></p><p>也可如此创建字典：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict1</span> = &#123; <span class="hljs-string">&#x27;abc&#x27;</span>: <span class="hljs-number">456</span> &#125;<br><span class="hljs-attr">dict2</span> = &#123; <span class="hljs-string">&#x27;abc&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-number">98.6</span>: <span class="hljs-number">37</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h2><p>把相应的键放入到方括号中，如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Name&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Age&#x27;</span>])<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">dict</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Name&#x27;</span>]</span>:  <span class="hljs-selector-tag">Runoob</span><br><span class="hljs-selector-tag">dict</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span>:  <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>如果用字典里没有的键访问数据，会输出错误如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Alice&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Alice&#x27;</span>])<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">5</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;dict[&#x27;Alice&#x27;]: &quot;</span>, dict[<span class="hljs-string">&#x27;Alice&#x27;</span>])<br>KeyError: <span class="hljs-string">&#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h2><p>向字典添加新内容的方法是增加新的键&#x2F;值对，修改或删除已有键&#x2F;值对如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Age&#x27;</span>] = <span class="hljs-number">8</span>               <span class="hljs-comment"># 更新 Age</span><br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;School&#x27;</span>] = <span class="hljs-string">&quot;菜鸟教程&quot;</span>  <span class="hljs-comment"># 添加信息</span><br> <br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;School&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;School&#x27;</span>])<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">dict</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span>:  <span class="hljs-number">8</span><br><span class="hljs-selector-tag">dict</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;School&#x27;</span>]</span>:  菜鸟教程<br></code></pre></td></tr></table></figure><h2 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h2><p>能删单一的元素也能清空字典，清空只需一项操作。</p><p>显示删除一个字典用del命令，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-keyword">del</span> <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Name&#x27;</span>] <span class="hljs-comment"># 删除键 &#x27;Name&#x27;</span><br><span class="hljs-built_in">dict</span>.clear()     <span class="hljs-comment"># 清空字典</span><br><span class="hljs-keyword">del</span> <span class="hljs-built_in">dict</span>         <span class="hljs-comment"># 删除字典</span><br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;School&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;School&#x27;</span>])<br></code></pre></td></tr></table></figure><p>但这会引发一个异常，因为用执行del操作后字典不再存在：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">9</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, dict[<span class="hljs-string">&#x27;Age&#x27;</span>])<br>TypeError: <span class="hljs-string">&#x27;type&#x27;</span> object <span class="hljs-keyword">is</span> not subscriptable<br></code></pre></td></tr></table></figure><h3 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h3><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住：</p><p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;小菜鸟&#x27;</span>&#125;<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Name&#x27;</span>]<br></code></pre></td></tr></table></figure><p>以下实例输出结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">dict<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Name&#x27;</span>]</span>:  小菜鸟<br></code></pre></td></tr></table></figure><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;[<span class="hljs-string">&#x27;Name&#x27;</span>]: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>&#125;<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;Name&#x27;</span>])<br></code></pre></td></tr></table></figure><p>以下实例输出结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">3</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    dict = &#123;[<span class="hljs-string">&#x27;Name&#x27;</span>]: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>&#125;<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字典内置函数-方法"><a href="#字典内置函数-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th>序号</th><th>函数及描述</th><th>实例</th></tr></thead><tbody><tr><td>1</td><td>len(dict) 计算字典元素个数，即键的总数。</td><td><code>&gt;&gt;&gt; dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(dict) 3</code></td></tr><tr><td>2</td><td>str(dict) 输出字典，以可打印的字符串表示。</td><td><code>&gt;&gt;&gt; dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(dict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td>3</td><td>type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td><code>&gt;&gt;&gt; dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(dict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1</td><td>[radiansdict.clear()]删除字典内所有元素</td></tr><tr><td>2</td><td>[radiansdict.copy()]返回一个字典的浅复制</td></tr><tr><td>3</td><td>[radiansdict.fromkeys()]创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td>4</td><td>[radiansdict.get(key, default&#x3D;None)] 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td>5</td><td>[key in dict] 如果键在字典dict里返回true，否则返回false</td></tr><tr><td>6</td><td>[radiansdict.items()] 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td>7</td><td>[radiansdict.keys()] 返回一个迭代器，可以使用 list() 来转换为列表</td></tr><tr><td>8</td><td>[radiansdict.setdefault(key, default&#x3D;None)] 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td>9</td><td>[radiansdict.update(dict2)] 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td>10</td><td>[radiansdict.values()]返回一个迭代器，可以使用 list() 来转换为列表</td></tr><tr><td>11</td><td>[pop(key[,default])] 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td>12</td><td>[popitem()]随机返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h1 id="Python3集合"><a href="#Python3集合" class="headerlink" title="Python3集合"></a>Python3集合</h1><p>集合（set）是一个无序的不重复元素序列。</p><p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">parame = &#123;value01,value02,...&#125;<br>或者<br><span class="hljs-built_in">set</span>(value)<br><span class="hljs-meta">&gt;&gt;&gt; </span>basket = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(basket)                      <span class="hljs-comment"># 这里演示的是去重功能</span><br>&#123;<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-keyword">in</span> basket                 <span class="hljs-comment"># 快速判断元素是否在集合内</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;crabgrass&#x27;</span> <span class="hljs-keyword">in</span> basket<br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 下面展示两个集合间的运算.</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;alacazam&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a                                  <br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a - b                              <span class="hljs-comment"># 集合a中包含而集合b中不包含的元素</span><br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a | b                              <span class="hljs-comment"># 集合a或b中包含的所有元素</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="hljs-comment"># 集合a和b中都包含了的元素</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a ^ b                              <span class="hljs-comment"># 不同时包含于a和b的元素</span><br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>类似列表推导式，同样集合支持集合推导式(Set comprehension):</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">&gt;&gt;&gt; a = &#123;<span class="hljs-variable language_">x</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span> in <span class="hljs-string">&#x27;abracadabra&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">x</span> <span class="hljs-keyword">not</span> in <span class="hljs-string">&#x27;abc&#x27;</span>&#125;<br>&gt;&gt;&gt; a<br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h2><h3 id="1、添加元素"><a href="#1、添加元素" class="headerlink" title="1、添加元素"></a>1、添加元素</h3><p><strong>语法格式如下：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">s.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">x</span>)<br></code></pre></td></tr></table></figure><p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))<br>&gt;&gt;&gt; thisset.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Facebook&quot;</span>)<br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(thisset)<br>&#123;<span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s<span class="hljs-selector-class">.update</span>( <span class="hljs-attribute">x</span> )<br></code></pre></td></tr></table></figure><p>x可以有多个，用逗号分开。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset.update(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(thisset)</span><br>&#123;1, 3, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset.update([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])  </span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(thisset)</span><br>&#123;1, 3, 4, 5, 6, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、移除元素"><a href="#2、移除元素" class="headerlink" title="2、移除元素"></a>2、移除元素</h3><p><strong>语法格式如下：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">s.<span class="hljs-built_in">remove</span>(x)<br></code></pre></td></tr></table></figure><p>将元素x从集合s中移除，如果元素不存在，则会发生错误。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset.remove(<span class="hljs-string">&quot;Taobao&quot;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(thisset)</span><br>&#123;&#x27;Google&#x27;, &#x27;Runoob&#x27;&#125;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset.remove(<span class="hljs-string">&quot;Facebook&quot;</span>)   <span class="hljs-comment"># 不存在会发生错误</span></span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>KeyError: &#x27;Facebook&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s.discard(x)<br><span class="hljs-meta">&gt;&gt;&gt; </span>thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>thisset.discard(<span class="hljs-string">&quot;Facebook&quot;</span>)  <span class="hljs-comment"># 不存在不会发生错误</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(thisset)<br>&#123;<span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以设置随机删除集合中的一个元素，语法格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">s.pop()<br>thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>, <span class="hljs-string">&quot;Facebook&quot;</span>))<br>x = thisset.pop()<br><br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python3</span> test.<span class="hljs-keyword">py</span> <br>Runoob<br></code></pre></td></tr></table></figure><p>多次执行测试结果都不一样。</p><p>set集合的pop方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。</p><h3 id="3、计算集合元素个数"><a href="#3、计算集合元素个数" class="headerlink" title="3、计算集合元素个数"></a>3、计算集合元素个数</h3><p><strong>语法格式如下：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(s)</span></span><br></code></pre></td></tr></table></figure><p>计算集合s元素个数。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(thisset)</span><br>3<br></code></pre></td></tr></table></figure><h3 id="4、清空集合"><a href="#4、清空集合" class="headerlink" title="4、清空集合"></a>4、清空集合</h3><p><strong>语法格式如下：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">s.<span class="hljs-built_in">clear</span>()<br></code></pre></td></tr></table></figure><p>清空集合s。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset.clear()</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(thisset)</span><br>set()<br></code></pre></td></tr></table></figure><h3 id="5、判断元素是否在集合中存在"><a href="#5、判断元素是否在集合中存在" class="headerlink" title="5、判断元素是否在集合中存在"></a>5、判断元素是否在集合中存在</h3><p><strong>语法格式如下：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">x</span> in s<br></code></pre></td></tr></table></figure><p>判断元素x是否在集合s中，存在返回True，不存在返回False。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">thisset = <span class="hljs-built_in">set</span>((<span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>))</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&quot;Runoob&quot;</span> <span class="hljs-keyword">in</span> thisset</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&quot;Facebook&quot;</span> <span class="hljs-keyword">in</span> thisset</span><br>False<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="集合内置方法完整列表"><a href="#集合内置方法完整列表" class="headerlink" title="集合内置方法完整列表"></a>集合内置方法完整列表</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>[add()]</td><td>为集合添加元素</td></tr><tr><td>[clear()]</td><td>移除集合中的所有元素</td></tr><tr><td>[copy()]</td><td>拷贝一个集合</td></tr><tr><td>[difference()]</td><td>返回多个集合的差集</td></tr><tr><td>[difference_update()]</td><td>移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td>[discard()]</td><td>删除集合中指定的元素</td></tr><tr><td>[intersection()]</td><td>返回集合的交集</td></tr><tr><td>[intersection_update()]</td><td>返回集合的交集。</td></tr><tr><td>[isdisjoint()]</td><td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td>[issubset()]</td><td>判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td>[issuperset()]</td><td>判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td>[pop()]</td><td>随机移除元素</td></tr><tr><td>[remove()]</td><td>移除指定元素</td></tr><tr><td>[symmetric_difference()]</td><td>返回两个集合中不重复的元素集合。</td></tr><tr><td>[symmetric_difference_update()]</td><td>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td>[union()]</td><td>返回两个集合的并集</td></tr><tr><td>[update()]</td><td>给集合添加元素</td></tr></tbody></table><h1 id="Python3编程第一步"><a href="#Python3编程第一步" class="headerlink" title="Python3编程第一步"></a>Python3编程第一步</h1><h3 id="end关键字"><a href="#end关键字" class="headerlink" title="end关键字"></a>end关键字</h3><p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># Fibonacci series: 斐波纳契数列</span><br><span class="hljs-comment"># 两个元素的总和确定了下一个数</span><br><span class="hljs-keyword">a</span>, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> b &lt; <span class="hljs-number">1000</span>:<br>    print(b, <span class="hljs-keyword">end</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-keyword">a</span>, b = b, <span class="hljs-keyword">a</span>+b<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">89</span>,<span class="hljs-number">144</span>,<span class="hljs-number">233</span>,<span class="hljs-number">377</span>,<span class="hljs-number">610</span>,<span class="hljs-number">987</span>,<br></code></pre></td></tr></table></figure><h1 id="Python3条件控制"><a href="#Python3条件控制" class="headerlink" title="Python3条件控制"></a>Python3条件控制</h1><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。</p><p>可以通过下图来简单了解条件语句的执行过程。</p><p><a href="https://www.runoob.com/wp-content/uploads/2013/11/if-condition.jpg"><img src="https://www.runoob.com/wp-content/uploads/2013/11/if-condition.jpg" alt="img"></a></p><p>代码执行过程：</p><p><a href="https://static.runoob.com/images/mix/python-if.webp"><img src="https://static.runoob.com/images/mix/python-if.webp" alt="img"></a></p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>Python中if语句的一般形式如下所示：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">if condition_1</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">statement_block_1</span><br><span class="hljs-attribute">elif condition_2</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">statement_block_2</span><br><span class="hljs-attribute">else</span><span class="hljs-punctuation">:</span><br>    statement_block_3<br></code></pre></td></tr></table></figure><ul><li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li><li>如果 “condition_1” 为False，将判断 “condition_2”</li><li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li><li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li></ul><p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><p><strong>注意：</strong></p><ul><li>1、每个条件后面要使用冒号 <strong>:</strong>，表示接下来是满足条件后要执行的语句块。</li><li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>3、在Python中没有switch – case语句。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif"><img src="https://www.runoob.com/wp-content/uploads/2014/05/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif" alt="img"></a></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下是一个简单的if实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var1 = 100<br><span class="hljs-keyword">if</span> var1:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;1 - if 表达式条件为 true&quot;</span>)<br>    <span class="hljs-built_in">print</span> (var1)<br> <br>var2 = 0<br><span class="hljs-keyword">if</span> var2:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;2 - if 表达式条件为 true&quot;</span>)<br>    <span class="hljs-built_in">print</span> (var2)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Good bye!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 - <span class="hljs-keyword">if</span> 表达式条件为 <span class="hljs-literal">true</span><br>100<br>Good <span class="hljs-built_in">bye</span>!<br></code></pre></td></tr></table></figure><p>从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。</p><p>以下实例演示了狗的年龄计算判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你家狗狗的年龄: &quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> age &lt;= <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你是在逗我吧!&quot;</span>)<br><span class="hljs-keyword">elif</span> age == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;相当于 14 岁的人。&quot;</span>)<br><span class="hljs-keyword">elif</span> age == <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;相当于 22 岁的人。&quot;</span>)<br><span class="hljs-keyword">elif</span> age &gt; <span class="hljs-number">2</span>:<br>    human = <span class="hljs-number">22</span> + (age -<span class="hljs-number">2</span>)*<span class="hljs-number">5</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对应人类年龄: &quot;</span>, human)<br> <br><span class="hljs-comment">### 退出提示</span><br><span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;点击 enter 键退出&quot;</span>)<br></code></pre></td></tr></table></figure><p>将以上脚本保存在dog.py文件中，并执行该脚本：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python3</span> dog.<span class="hljs-keyword">py</span> <br>请输入你家狗狗的年龄: <span class="hljs-number">1</span><br><br>相当于 <span class="hljs-number">14</span> 岁的人。<br>点击 enter 键退出<br></code></pre></td></tr></table></figure><p>以下为if中常用的操作运算符:</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td></tr><tr><td><code>==</code></td><td>等于，比较两个值是否相等</td></tr><tr><td><code>!=</code></td><td>不等于</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 程序演示了 == 操作符</span><br><span class="hljs-comment"># 使用数字</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">5</span> == <span class="hljs-number">6</span>)<br><span class="hljs-comment"># 使用变量</span><br><span class="hljs-attribute">x</span> = <span class="hljs-number">5</span><br><span class="hljs-attribute">y</span> = <span class="hljs-number">8</span><br><span class="hljs-attribute">print</span>(x == y)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><p>False</p><p>False</p><p>high_low.py文件演示了数字的比较运算：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim"># 该实例演示了数字猜谜游戏<br><span class="hljs-keyword">number</span> = <span class="hljs-number">7</span><br>guess = -<span class="hljs-number">1</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;数字猜谜游戏!&quot;</span>)<br><span class="hljs-keyword">while</span> guess != <span class="hljs-keyword">number</span>:<br>    guess = <span class="hljs-keyword">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你猜的数字：&quot;</span>))<br> <br>    <span class="hljs-keyword">if</span> guess == <span class="hljs-keyword">number</span>:<br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;恭喜，你猜对了！&quot;</span>)<br>    elif guess &lt; <span class="hljs-keyword">number</span>:<br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;猜的数字小了...&quot;</span>)<br>    elif guess &gt; <span class="hljs-keyword">number</span>:<br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;猜的数字大了...&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本，实例输出结果如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$ </span>python3 high_low.py <br>数字猜谜游戏!<br>请输入你猜的数字：<span class="hljs-number">1</span><br>猜的数字小了...<br>请输入你猜的数字：<span class="hljs-number">9</span><br>猜的数字大了...<br>请输入你猜的数字：<span class="hljs-number">7</span><br>恭喜，你猜对了！<br></code></pre></td></tr></table></figure><h2 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> 表达式1:<br>    语句<br>    <span class="hljs-keyword">if</span> 表达式2:<br>        语句<br>    elif 表达式3:<br>        语句<br>    <span class="hljs-keyword">else</span>:<br>        语句<br>elif 表达式4:<br>    语句<br><span class="hljs-keyword">else</span>:<br>    语句<br><span class="hljs-attribute">num</span>=int(input(&quot;输入一个数字：&quot;))<br><span class="hljs-keyword">if</span> num%<span class="hljs-attribute">2</span>==0:<br>    <span class="hljs-keyword">if</span> num%<span class="hljs-attribute">3</span>==0:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你输入的数字可以整除 2 和 3&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你输入的数字可以整除 2，但不能整除 3&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">if</span> num%<span class="hljs-attribute">3</span>==0:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你输入的数字可以整除 3，但不能整除 2&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>  (<span class="hljs-string">&quot;你输入的数字不能整除 2 和 3&quot;</span>)<br></code></pre></td></tr></table></figure><p>将以上程序保存到 test_if.py 文件中，执行后输出结果为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python3</span> test.<span class="hljs-keyword">py</span> <br>输入一个数字：<span class="hljs-number">6</span><br>你输入的数字可以整除 <span class="hljs-number">2</span> 和 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="Python3-循环语句"><a href="#Python3-循环语句" class="headerlink" title="Python3 循环语句"></a>Python3 循环语句</h1><p>Python中的循环语句有for和while。</p><p>Python 循环语句的控制结构图如下所示：</p><p><a href="https://www.runoob.com/wp-content/uploads/2015/12/loop.png"><img src="https://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt="img"></a></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>Python中的while语句的一般形式：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(<span class="hljs-built_in">statements</span>)……<br></code></pre></td></tr></table></figure><p>执行流程图如下：</p><p><a href="https://www.runoob.com/wp-content/uploads/2013/11/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg"><img src="https://www.runoob.com/wp-content/uploads/2013/11/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg" alt="img"></a></p><p>执行Gif演示：</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/006faQNTgw1f5wnm06h3ug30ci08cake.gif"><img src="https://www.runoob.com/wp-content/uploads/2014/05/006faQNTgw1f5wnm06h3ug30ci08cake.gif" alt="img"></a></p><p>同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。</p><p>以下实例使用了while来计算1到100的总和：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">n = <span class="hljs-number">100</span><br> <br><span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span><br>counter = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> counter &lt;= n:<br>    <span class="hljs-keyword">sum</span> = <span class="hljs-keyword">sum</span> + counter<br>    counter += <span class="hljs-number">1</span><br> <br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;1 到 %d 之和为: %d&quot;</span> % (n,<span class="hljs-keyword">sum</span>))<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>到 <span class="hljs-number">100</span> 之和为: <span class="hljs-number">5050</span><br></code></pre></td></tr></table></figure><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">var</span> == <span class="hljs-number">1</span> :  # 表达式永远为 <span class="hljs-keyword">true</span><br>   <span class="hljs-built_in">num</span> = <span class="hljs-built_in">int</span>(input(<span class="hljs-string">&quot;输入一个数字  :&quot;</span>))<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你输入的数字是: &quot;</span>, <span class="hljs-built_in">num</span>)<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Good bye!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本，输出结果如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext">输入一个数字  :5<br><span class="hljs-attribute">你输入的数字是</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> 5</span><br><span class="hljs-attribute">输入一个数字  </span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><p>你可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p><p>无限循环在服务器上客户端的实时请求非常有用。</p><h3 id="while循环使用else语句"><a href="#while循环使用else语句" class="headerlink" title="while循环使用else语句"></a>while循环使用else语句</h3><p>在 while … else 在条件语句为 false 时执行 else 的语句块。</p><p>语法格式如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">while</span></span> &lt;<span class="hljs-variable">expr</span>&gt;:<br>    &lt;<span class="hljs-function"><span class="hljs-title">statement</span>(<span class="hljs-variable">s</span>)&gt;</span><br><span class="hljs-function"><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:</span><br><span class="hljs-function">    &lt;<span class="hljs-title">additional_statement</span>(<span class="hljs-variable">s</span>)&gt;</span><br></code></pre></td></tr></table></figure><p>循环输出数字，并判断大小：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">count</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">count</span> &lt; <span class="hljs-number">5</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-keyword">count</span>, <span class="hljs-string">&quot; 小于 5&quot;</span>)<br>   <span class="hljs-keyword">count</span> = <span class="hljs-keyword">count</span> + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-keyword">count</span>, <span class="hljs-string">&quot; 大于或等于 5&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本，输出结果如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span> 小于 <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span> 小于 <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span> 小于 <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span> 小于 <span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span> 小于 <span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span> 大于或等于 <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="简单语句组"><a href="#简单语句组" class="headerlink" title="简单语句组"></a>简单语句组</h3><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">flag = 1<br> <br><span class="hljs-keyword">while</span> (flag): <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;欢迎访问菜鸟教程!&#x27;</span>)<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Good bye!&quot;</span>)<br></code></pre></td></tr></table></figure><p>**注意：**以上的无限循环你可以使用 CTRL+C 来中断循环。</p><p>执行以上脚本，输出结果如下：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">欢迎访问菜鸟教程!<br>欢迎访问菜鸟教程!<br>欢迎访问菜鸟教程!<br>欢迎访问菜鸟教程!<br>欢迎访问菜鸟教程!<br>……<br></code></pre></td></tr></table></figure><h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python for 循环可以遍历任何可选代对象，如一个列表或者一个字符串。</p><p>for循环的一般格式如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">for <span class="hljs-symbol">&lt;variable&gt;</span> <span class="hljs-keyword">in</span> <span class="hljs-symbol">&lt;sequence&gt;</span>:<br>    <span class="hljs-symbol">&lt;statements&gt;</span><br><span class="hljs-params">else:</span><br>    <span class="hljs-symbol">&lt;statements&gt;</span><br></code></pre></td></tr></table></figure><p>流程图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2013/11/A71EC47E-BC53-4923-8F88-B027937EE2FF.jpg"><img src="https://www.runoob.com/wp-content/uploads/2013/11/A71EC47E-BC53-4923-8F88-B027937EE2FF.jpg" alt="img"></a></p><p>Python for循环实例</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">&gt;&gt;&gt;languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;] <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> languages:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span> (x)</span><br><span class="hljs-meta prompt_">...</span> <br>C<br>C++<br>Perl<br>Python<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>以下for实例中使用了break语句，break语句用于跳出当前的循环体：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sites = [<span class="hljs-string">&quot;Baidu&quot;</span>, <span class="hljs-string">&quot;Google&quot;</span>,<span class="hljs-string">&quot;Runoob&quot;</span>,<span class="hljs-string">&quot;Taobao&quot;</span>]<br><span class="hljs-keyword">for</span> site <span class="hljs-keyword">in</span> sites:<br>    <span class="hljs-keyword">if</span> site == <span class="hljs-string">&quot;Runoob&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;菜鸟教程!&quot;</span>)<br>        break<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;循环数据 &quot;</span> + site)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有循环数据!&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;完成循环!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行脚本后，在循环到”Runoob”时会跳出循环体：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">循环数据 Baidu<br>循环数据 Google<br>菜鸟教程!<br>完成循环!<br></code></pre></td></tr></table></figure><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h2><p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">for i in range(5):<br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(i)</span><br><span class="hljs-meta prompt_">...</span><br>0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><p>你也可以使用range指定区间的值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt;for <span class="hljs-selector-tag">i</span> in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>) :<br>    <span class="hljs-built_in">print</span>(i)<br> <br>    <br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>也可以使range以指定数字开始并指定不同的增量（甚至可以是负数，有时这也叫做“步长”）：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt;for <span class="hljs-selector-tag">i</span> in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>) :<br>    <span class="hljs-built_in">print</span>(i)<br> <br>    <br><span class="hljs-number">0</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">9</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>负数：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&gt;&gt;&gt;for i in range(<span class="hljs-string">-10</span>, <span class="hljs-string">-100</span>, <span class="hljs-string">-30</span>) :<br>    print(i)<br> <br>    <br><span class="hljs-string">-10</span><br><span class="hljs-string">-40</span><br><span class="hljs-string">-70</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt;<span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;QQ&#x27;</span>]</span><br>&gt;&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>...     <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>)<br>... <br><span class="hljs-number">0</span> Google<br><span class="hljs-number">1</span> Baidu<br><span class="hljs-number">2</span> Runoob<br><span class="hljs-number">3</span> Taobao<br><span class="hljs-number">4</span> QQ<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>还可以使用range()函数来创建一个列表：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt;<span class="hljs-built_in">list</span>(range(<span class="hljs-number">5</span>))<br><span class="hljs-selector-attr">[0, 1, 2, 3, 4]</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h2 id="break-和-continue-语句及循环中的-else-子句"><a href="#break-和-continue-语句及循环中的-else-子句" class="headerlink" title="break 和 continue 语句及循环中的 else 子句"></a>break 和 continue 语句及循环中的 else 子句</h2><p><strong>break 执行流程图：</strong></p><p><a href="https://www.runoob.com/wp-content/uploads/2014/09/E5A591EF-6515-4BCB-AEAA-A97ABEFC5D7D.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/09/E5A591EF-6515-4BCB-AEAA-A97ABEFC5D7D.jpg" alt="img"></a></p><p><strong>continue 执行流程图：</strong></p><p><a href="https://www.runoob.com/wp-content/uploads/2014/09/8962A4F1-B78C-4877-B328-903366EA1470.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/09/8962A4F1-B78C-4877-B328-903366EA1470.jpg" alt="img"></a></p><p>while语句代码执行过程：</p><p><a href="https://static.runoob.com/images/mix/python-while.webp"><img src="https://static.runoob.com/images/mix/python-while.webp" alt="img"></a></p><p>for语句代码执行过程：</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/break-continue-536.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/break-continue-536.png" alt="img"></a></p><p><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</p><p><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p><p><strong>实例</strong></p><p>while 中使用 break：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">n</span> = <span class="hljs-number">5</span><br><span class="hljs-variable"><span class="hljs-keyword">while</span></span> <span class="hljs-variable">n</span> &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-variable">n</span> -= <span class="hljs-number">1</span><br>    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">n</span> == <span class="hljs-number">2</span>:<br>        <span class="hljs-variable">break</span><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">n</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;循环结束。&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>3<br>循环结束。<br></code></pre></td></tr></table></figure><p>while 中使用 continue：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">n</span> = <span class="hljs-number">5</span><br><span class="hljs-variable"><span class="hljs-keyword">while</span></span> <span class="hljs-variable">n</span> &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-variable">n</span> -= <span class="hljs-number">1</span><br>    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">n</span> == <span class="hljs-number">2</span>:<br>        <span class="hljs-variable">continue</span><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">n</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;循环结束。&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>3<br>1<br>0<br>循环结束。<br></code></pre></td></tr></table></figure><p>更多实例如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Runoob&#x27;</span>:     <span class="hljs-meta"># 第一个实例</span><br>   <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;b&#x27;</span>:<br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;当前字母为 :&#x27;</span>, letter)<br>  <br><span class="hljs-built_in">var</span> = <span class="hljs-number">10</span>                    <span class="hljs-meta"># 第二个实例</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">var</span> &gt; <span class="hljs-number">0</span>:              <br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;当期变量值为 :&#x27;</span>, <span class="hljs-built_in">var</span>)<br>   <span class="hljs-built_in">var</span> = <span class="hljs-built_in">var</span> <span class="hljs-number">-1</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">var</span> == <span class="hljs-number">5</span>:<br>      <span class="hljs-keyword">break</span><br> <br><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;Good bye!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">当前字母为 : <span class="hljs-type">R</span><br>当前字母为 : <span class="hljs-type">u</span><br>当前字母为 : <span class="hljs-type">n</span><br>当前字母为 : <span class="hljs-type">o</span><br>当前字母为 : <span class="hljs-type">o</span><br>当期变量值为 : 10<br>当期变量值为 : 9<br>当期变量值为 : 8<br>当期变量值为 : 7<br>当期变量值为 : 6<br>Good bye!<br></code></pre></td></tr></table></figure><p>以下实例循环字符串 Runoob，碰到字母 o 跳过输出：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Runoob&#x27;</span>:     <span class="hljs-meta"># 第一个实例</span><br>   <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;o&#x27;</span>:        <span class="hljs-meta"># 字母为 o 时跳过输出</span><br>      <span class="hljs-keyword">continue</span><br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;当前字母 :&#x27;</span>, letter)<br> <br><span class="hljs-built_in">var</span> = <span class="hljs-number">10</span>                    <span class="hljs-meta"># 第二个实例</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">var</span> &gt; <span class="hljs-number">0</span>:              <br>   <span class="hljs-built_in">var</span> = <span class="hljs-built_in">var</span> <span class="hljs-number">-1</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">var</span> == <span class="hljs-number">5</span>:             <span class="hljs-meta"># 变量为 5 时跳过输出</span><br>      <span class="hljs-keyword">continue</span><br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;当前变量值 :&#x27;</span>, <span class="hljs-built_in">var</span>)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;Good bye!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">当前字母 : <span class="hljs-type">R</span><br>当前字母 : <span class="hljs-type">u</span><br>当前字母 : <span class="hljs-type">n</span><br>当前字母 : <span class="hljs-type">b</span><br>当前变量值 : 9<br>当前变量值 : 8<br>当前变量值 : 7<br>当前变量值 : 6<br>当前变量值 : 4<br>当前变量值 : 3<br>当前变量值 : 2<br>当前变量值 : 1<br>当前变量值 : 0<br>Good bye!<br></code></pre></td></tr></table></figure><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。</p><p>如下实例用于查询质数的循环例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> n in <span class="hljs-keyword">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">for</span> x in <span class="hljs-keyword">range</span>(<span class="hljs-number">2</span>, n):<br>        <span class="hljs-keyword">if</span> n % x == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(n, <span class="hljs-string">&#x27;等于&#x27;</span>, x, <span class="hljs-string">&#x27;*&#x27;</span>, n<span class="hljs-comment">//x)</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        # 循环中没有找到元素<br>        <span class="hljs-built_in">print</span>(n, <span class="hljs-string">&#x27; 是质数&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本输出结果为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span> 是质数<br><span class="hljs-symbol">3 </span> 是质数<br><span class="hljs-symbol">4 </span>等于 <span class="hljs-number">2</span> * <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span> 是质数<br><span class="hljs-symbol">6 </span>等于 <span class="hljs-number">2</span> * <span class="hljs-number">3</span><br><span class="hljs-symbol">7 </span> 是质数<br><span class="hljs-symbol">8 </span>等于 <span class="hljs-number">2</span> * <span class="hljs-number">4</span><br><span class="hljs-symbol">9 </span>等于 <span class="hljs-number">3</span> * <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。</p><p>pass 不做任何事情，一般用做占位语句，如下实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 等待键盘中断 (Ctrl+C)</span><br></code></pre></td></tr></table></figure><p>最小的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&gt;&gt;&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmptyClass</span>:<br><span class="hljs-type">...</span>     <span class="hljs-title">pass</span><br></code></pre></td></tr></table></figure><p>以下实例在字母为o时，执行pass语句块：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Runoob&#x27;</span>: <br>   <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;o&#x27;</span>:<br>      pass<br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;执行 pass 块&#x27;</span>)<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;当前字母 :&#x27;</span>, letter)<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Good bye!&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上脚本输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">当前字母 : <span class="hljs-type">R</span><br>当前字母 : <span class="hljs-type">u</span><br>当前字母 : <span class="hljs-type">n</span><br>执行 pass 块<br>当前字母 : <span class="hljs-type">o</span><br>执行 pass 块<br>当前字母 : <span class="hljs-type">o</span><br>当前字母 : <span class="hljs-type">b</span><br>Good bye!<br></code></pre></td></tr></table></figure><h1 id="Python3迭代器和生成器"><a href="#Python3迭代器和生成器" class="headerlink" title="Python3迭代器和生成器"></a>Python3迭代器和生成器</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p><p>字符串，列表或元组对象都可用于创建迭代器：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))   <span class="hljs-comment"># 输出迭代器的下一个元素</span></span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>迭代器对象可以使用常规for语句进行遍历：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-attribute">it</span> = iter(list)    # 创建迭代器对象<br><span class="hljs-attribute">for</span> x in it:<br>    <span class="hljs-attribute">print</span> (x, end=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：1234</p><p>也可以使用 next() 函数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">import sys         <span class="hljs-comment"># 引入 sys 模块</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> True:<br>    try:<br>        print (<span class="hljs-keyword">next</span>(it))<br>    except StopIteration:<br>        sys.<span class="hljs-keyword">exit</span>()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><h3 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p><p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p><p><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p><p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p><p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-variable language_">self</span>.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    x = <span class="hljs-variable language_">self</span>.a<br>    <span class="hljs-variable language_">self</span>.a += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br> <br>myclass = MyNumbers()<br>myiter = <span class="hljs-built_in">iter</span>(myclass)<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(myiter))<br></code></pre></td></tr></table></figure><p>执行输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>4<br>5<br></code></pre></td></tr></table></figure><h3 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h3><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><p>在 20 次迭代后停止执行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.a &lt;= <span class="hljs-number">20</span>:<br>      x = <span class="hljs-variable language_">self</span>.a<br>      <span class="hljs-variable language_">self</span>.a += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> x<br>    <span class="hljs-symbol">else:</span><br>      <span class="hljs-keyword">raise</span> <span class="hljs-title class_">StopIteration</span><br> <br>myclass = <span class="hljs-title class_">MyNumbers</span>()<br>myiter = iter(myclass)<br> <br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-symbol">myiter:</span><br>  print(x)<br></code></pre></td></tr></table></figure><p>执行输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><p>以下实例使用 yield 实现斐波那契数列：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">import sys<br> <br>def fibonacci(n): <span class="hljs-comment"># 生成器函数 - 斐波那契</span><br>    a, b, counter = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> True:<br>        <span class="hljs-keyword">if</span> (counter &gt; n): <br>            return<br>        yield a<br>        a, b = b, a + b<br>        counter += <span class="hljs-number">1</span><br>f = fibonacci(<span class="hljs-number">10</span>) <span class="hljs-comment"># f 是一个迭代器，由生成器返回生成</span><br> <br><span class="hljs-keyword">while</span> True:<br>    try:<br>        print (<span class="hljs-keyword">next</span>(f), end=<span class="hljs-string">&quot; &quot;</span>)<br>    except StopIteration:<br>        sys.<span class="hljs-keyword">exit</span>()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span> <span class="hljs-number">34</span> <span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><h1 id="Python3函数"><a href="#Python3函数" class="headerlink" title="Python3函数"></a>Python3函数</h1><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p><p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以def关键字开头，后接函数标识符名称和圆括号()。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性的使用文档字符串——用于存放函数说明。</li><li>函数内容以冒号：起始，并且缩进。</li><li>return[表达式]结束函数，选择性的返回一个值给调用方，不带表达式的return相当于返回None。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/py-tup-10-26-1.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/py-tup-10-26-1.png" alt="img"></a></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python 定义函数使用 def 关键字，一般格式如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名（参数列表）:</span><br><span class="hljs-function">    函数体</span><br></code></pre></td></tr></table></figure><p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p><p><strong>实例</strong></p><p>让我们使用函数来输出“Hello World！”：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">hello</span>() :</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-title">hello</span>()</span><br></code></pre></td></tr></table></figure><p>更复杂点的应用，函数中带上参数变量：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def <span class="hljs-built_in">max</span>(<span class="hljs-keyword">a</span>, b):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">a</span> &gt; b:<br>        <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-literal">return</span> b<br> <br><span class="hljs-keyword">a</span> = <span class="hljs-number">4</span><br>b = <span class="hljs-number">5</span><br>print(<span class="hljs-built_in">max</span>(<span class="hljs-keyword">a</span>, b))<br></code></pre></td></tr></table></figure><p>计算面积函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算面积函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">width, height</span>):<br>    <span class="hljs-keyword">return</span> width * height<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_welcome</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Welcome&quot;</span>, name)<br> <br>print_welcome(<span class="hljs-string">&quot;Runoob&quot;</span>)<br>w = <span class="hljs-number">4</span><br>h = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;width =&quot;</span>, w, <span class="hljs-string">&quot; height =&quot;</span>, h, <span class="hljs-string">&quot; area =&quot;</span>, area(w, h))<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Welcome Runoob<br><span class="hljs-attribute">width</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>  height <span class="hljs-operator">=</span> <span class="hljs-number">5</span>  area <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p><p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p><p>如下实例调用了 <strong>printme()</strong> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"> <span class="hljs-built_in">str</span> </span>):<br>   <span class="hljs-comment"># 打印任何传入的字符串</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用函数</span><br>printme(<span class="hljs-string">&quot;我要调用用户自定义函数!&quot;</span>)<br>printme(<span class="hljs-string">&quot;再次调用同一函数&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">我要调用用户自定义函数!<br>再次调用同一函数<br></code></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在 python 中，类型属于对象，变量是没有类型的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-attr">a</span>=<span class="hljs-string">&quot;Runoob&quot;</span><br></code></pre></td></tr></table></figure><p>以上代码中，<strong>[1,2,3]</strong> 是 List 类型，<strong>”Runoob”</strong> 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p><h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li>**不可变类型：**变量赋值 <strong>a&#x3D;5</strong> 后再赋值 <strong>a&#x3D;10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li><li>**可变类型：**变量赋值 <strong>la&#x3D;[1,2,3,4]</strong> 后再赋值 <strong>la[2]&#x3D;5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li>**不可变类型：**类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li><li>**可变类型：**类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h3 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h3><p>通过id()函数来查看内存地址变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))   <span class="hljs-comment"># 指向的是同一个对象</span><br>    a=<span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))   <span class="hljs-comment"># 一个新对象</span><br> <br>a=<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))<br>change(a)<br></code></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">4379369136</span><br><span class="hljs-number">4379369136</span><br><span class="hljs-number">4379369424</span><br></code></pre></td></tr></table></figure><p>可以看见在调用函数前后，形参和实参指向的是同一个对象（对象id相同），在函数内部修改形参后，形参指向的是不同的id。</p><h3 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h3><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">changeme</span>(<span class="hljs-params"> mylist </span>):<br>   <span class="hljs-string">&quot;修改传入的列表&quot;</span><br>   mylist.append([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;函数内取值: &quot;</span>, mylist)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用changeme函数</span><br>mylist = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br>changeme( mylist )<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;函数外取值: &quot;</span>, mylist)<br></code></pre></td></tr></table></figure><p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">函数内取值:  <span class="hljs-comment">[10, 20, 30, <span class="hljs-comment">[1, 2, 3, 4]</span>]</span><br>函数外取值:  <span class="hljs-comment">[10, 20, 30, <span class="hljs-comment">[1, 2, 3, 4]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>以下是调用函数时可使用的正式参数类型：</p><ul><li>必需参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><h3 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h3><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><p>调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#可写函数说明</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"> <span class="hljs-built_in">str</span> </span>):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用 printme 函数，不加参数会报错</span><br>printme()<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">10</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    printme()<br>TypeError: printme() missing <span class="hljs-number">1</span> required positional <span class="hljs-keyword">argument</span>: <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><p>以下实例在函数 printme() 调用时使用参数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#可写函数说明</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"> <span class="hljs-built_in">str</span> </span>):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment">#调用printme函数</span><br>printme( <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;菜鸟教程&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">菜鸟教程<br></code></pre></td></tr></table></figure><p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#可写函数说明</span><br>def printinfo( name, age ):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;名字: &quot;</span>, name)<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;年龄: &quot;</span>, age)<br>   return<br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( <span class="hljs-attribute">age</span>=50, <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;runoob&quot;</span> )<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">名字:  runoob</span><br><span class="hljs-section">年龄:  50</span><br></code></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#可写函数说明</span><br>def printinfo( name, age = 35 ):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;名字: &quot;</span>, name)<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;年龄: &quot;</span>, age)<br>   return<br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( <span class="hljs-attribute">age</span>=50, <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;runoob&quot;</span> )<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;------------------------&quot;</span>)<br>printinfo( <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;runoob&quot;</span> )<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">名字:  runoob<br><span class="hljs-section">年龄:  50</span><br><span class="hljs-section">------------------------</span><br>名字:  runoob<br>年龄:  35<br></code></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">def functionname([<span class="hljs-keyword">formal</span><span class="hljs-number">_</span>args,] *var<span class="hljs-number">_</span>args<span class="hljs-number">_</span>tuple ):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   <span class="hljs-keyword">function</span><span class="hljs-number">_</span>suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p><em>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</em></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 可写函数说明</span><br>def printinfo( arg1, *vartuple ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>   <span class="hljs-built_in">print</span> (arg1)<br>   <span class="hljs-built_in">print</span> (vartuple)<br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( 70, 60, 50 )<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输出: </span><br>70<br>(60, 50)<br></code></pre></td></tr></table></figure><p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 可写函数说明</span><br>def printinfo( arg1, *vartuple ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>   <span class="hljs-keyword">print</span> (arg1)<br>   <span class="hljs-keyword">for</span> <span class="hljs-built_in">var</span> <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-keyword">print</span> (<span class="hljs-built_in">var</span>)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-meta"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> )<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br><span class="hljs-meta">#以上实例输出结果</span><br>输出:<br><span class="hljs-number">10</span><br>输出:<br><span class="hljs-number">70</span><br><span class="hljs-number">60</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>还有一种就是参数带两个星号 ******基本语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">def functionname([<span class="hljs-keyword">formal</span><span class="hljs-number">_</span>args,] **var<span class="hljs-number">_</span>args<span class="hljs-number">_</span>dict ):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   <span class="hljs-keyword">function</span><span class="hljs-number">_</span>suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p><em>加了两个星号 ****** 的参数会以字典的形式导入。</em></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 可写函数说明</span><br>def printinfo( arg1, **vardict ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>   <span class="hljs-built_in">print</span> (arg1)<br>   <span class="hljs-built_in">print</span> (vardict)<br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo(1, <span class="hljs-attribute">a</span>=2,b=3)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输出<span class="hljs-punctuation">:</span> <br><span class="hljs-number">1</span><br>&#123;&#x27;a&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> &#x27;b&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,*,c</span>):<br>    <span class="hljs-keyword">return</span> a+b+c<br></code></pre></td></tr></table></figure><p>如果单独出现星号 ***** 后的参数必须用关键字传入。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,*,c</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">return</span> a+b+c</span><br><span class="hljs-meta prompt_">...</span> <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)   <span class="hljs-comment"># 报错</span></span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>TypeError: f() takes 2 positional arguments but 3 were given<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>) <span class="hljs-comment"># 正常</span></span><br>6<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>python 使用 lambda 来创建匿名函数。</p><p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p><ul><li>lambda 只是一个表达式，函数体比 def 简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda 函数的语法只包含一个语句，如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-built_in">lambda</span> [arg1 [,arg2,.....argn]]<span class="hljs-symbol">:expression</span><br></code></pre></td></tr></table></figure><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> ))<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">相加后的值为 :  30<br>相加后的值为 :  40<br></code></pre></td></tr></table></figure><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 可写函数说明<br>def <span class="hljs-built_in">sum</span>( arg1, arg2 ):<br>   # 返回2个参数的和.&quot;<br>   <span class="hljs-keyword">total</span> = arg1 + arg2<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;函数内 : &quot;</span>, <span class="hljs-keyword">total</span>)<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">total</span><br> <br># 调用<span class="hljs-keyword">sum</span>函数<br><span class="hljs-keyword">total</span> = <span class="hljs-built_in">sum</span>( 10, 20 )<br><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;函数外 : &quot;</span>, <span class="hljs-keyword">total</span>)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">函数内 :  30<br>函数外 :  30<br></code></pre></td></tr></table></figure><h2 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h2><p>Python3.8 新增了一个函数形参语法 &#x2F; 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p><p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">def f(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, /, c, d, *, e, f):<br>    <span class="hljs-built_in">print</span>(a, b, c, d, e, f)<br></code></pre></td></tr></table></figure><p>以下使用方法是正确的:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, d=<span class="hljs-number">40</span>, e=<span class="hljs-number">50</span>, f=<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p>以下使用方法会发生错误:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>, c=<span class="hljs-number">30</span>, d=<span class="hljs-number">40</span>, e=<span class="hljs-number">50</span>, f=<span class="hljs-number">60</span>)   # b 不能使用关键字参数的形式<br><span class="hljs-attribute">f</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, f=<span class="hljs-number">60</span>)           # e 必须使用关键字参数的形式<br></code></pre></td></tr></table></figure><h1 id="Python3数据结构"><a href="#Python3数据结构" class="headerlink" title="Python3数据结构"></a>Python3数据结构</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。</p><p>以下是 Python 中列表的方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>list.append(x)</td><td>把一个元素添加到列表的结尾，相当于 a[len(a):] &#x3D; [x]。</td></tr><tr><td>list.extend(L)</td><td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] &#x3D; L。</td></tr><tr><td>list.insert(i, x)</td><td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td></tr><tr><td>list.remove(x)</td><td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td></tr><tr><td>list.pop([i])</td><td>从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td></tr><tr><td>list.clear()</td><td>移除列表中的所有项，等于del a[:]。</td></tr><tr><td>list.index(x)</td><td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td></tr><tr><td>list.count(x)</td><td>返回 x 在列表中出现的次数。</td></tr><tr><td>list.sort()</td><td>对列表中的元素进行排序。</td></tr><tr><td>list.reverse()</td><td>倒排列表中的元素。</td></tr><tr><td>list.copy()</td><td>返回列表的浅复制，等于a[:]。</td></tr></tbody></table><p>下面示例演示了列表的大部分方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[66.25, 333, 333, 1, 1234.5]</span><br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.count</span>(<span class="hljs-number">333</span>), <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.count</span>(<span class="hljs-number">66.25</span>), <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.count</span>(<span class="hljs-string">&#x27;x&#x27;</span>))<br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.insert</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)<br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.append</span>(<span class="hljs-number">333</span>)<br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-attr">[66.25, 333, -1, 333, 1, 1234.5, 333]</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.index</span>(<span class="hljs-number">333</span>)<br><span class="hljs-number">1</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.remove</span>(<span class="hljs-number">333</span>)<br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-attr">[66.25, -1, 333, 1, 1234.5, 333]</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.reverse</span>()<br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-attr">[333, 1234.5, 1, 333, -1, 66.25]</span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.sort</span>()<br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-attr">[-1, 1, 66.25, 333, 333, 1234.5]</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：类似 insert, remove 或 sort 等修改列表的方法没有返回值。</p><h2 id="将列表当做堆栈使用"><a href="#将列表当做堆栈使用" class="headerlink" title="将列表当做堆栈使用"></a>将列表当做堆栈使用</h2><p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。例如：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.append(<span class="hljs-number">6</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.append(<span class="hljs-number">7</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack</span><br>[3, 4, 5, 6, 7]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.pop()</span><br>7<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack</span><br>[3, 4, 5, 6]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.pop()</span><br>6<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack.pop()</span><br>5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">stack</span><br>[3, 4]<br></code></pre></td></tr></table></figure><h2 id="将列表当作队列使用"><a href="#将列表当作队列使用" class="headerlink" title="将列表当作队列使用"></a>将列表当作队列使用</h2><p>也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">#实例<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue = deque([<span class="hljs-string">&quot;Eric&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Michael&quot;</span>])</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.append(<span class="hljs-string">&quot;Terry&quot;</span>)           <span class="hljs-comment"># Terry arrives</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.append(<span class="hljs-string">&quot;Graham&quot;</span>)          <span class="hljs-comment"># Graham arrives</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.popleft()                 <span class="hljs-comment"># The first to arrive now leaves</span></span><br>&#x27;Eric&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue.popleft()                 <span class="hljs-comment"># The second to arrive now leaves</span></span><br>&#x27;John&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">queue                           <span class="hljs-comment"># Remaining queue in order of arrival</span></span><br>deque([&#x27;Michael&#x27;, &#x27;Terry&#x27;, &#x27;Graham&#x27;])<br></code></pre></td></tr></table></figure><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p><p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p><p>这里我们将列表中每个数值乘三，获得一个新的列表：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">vec = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[<span class="hljs-number">3</span>*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> vec]</span><br>[6, 12, 18]<br></code></pre></td></tr></table></figure><p>现在我们玩一点小花样：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;&gt;&gt; <span class="hljs-comment">[<span class="hljs-comment">[x, x**2]</span> for x in vec]</span><br><span class="hljs-comment">[<span class="hljs-comment">[2, 4]</span>, <span class="hljs-comment">[4, 16]</span>, <span class="hljs-comment">[6, 36]</span>]</span><br></code></pre></td></tr></table></figure><p>这里我们对序列里每一个元素逐个调用某方法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#实例<br>&gt;&gt;&gt; freshfruit = [<span class="hljs-string">&#x27;  banana&#x27;</span>, <span class="hljs-string">&#x27;  loganberry &#x27;</span>, <span class="hljs-string">&#x27;passion fruit  &#x27;</span>]<br>&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]<br>[<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;loganberry&#x27;</span>, <span class="hljs-string">&#x27;passion fruit&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们可以用if子句作为过滤器：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">&gt;&gt;&gt; [<span class="hljs-number">3</span>*<span class="hljs-variable language_">x</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span> in vec <span class="hljs-keyword">if</span> <span class="hljs-variable language_">x</span> &gt; <span class="hljs-number">3</span>]<br>[<span class="hljs-number">12</span>, <span class="hljs-number">18</span>]<br>&gt;&gt;&gt; [<span class="hljs-number">3</span>*<span class="hljs-variable language_">x</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span> in vec <span class="hljs-keyword">if</span> <span class="hljs-variable language_">x</span> &lt; <span class="hljs-number">2</span>]<br>[]<br></code></pre></td></tr></table></figure><p>以下是一些关于循环和其他技巧的演示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">vec1 = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">vec2 = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[x*y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> vec1 <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> vec2]</span><br>[8, 6, -18, 16, 12, -36, 24, 18, -54]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[x+y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> vec1 <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> vec2]</span><br>[6, 5, -7, 8, 7, -5, 10, 9, -3]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[vec1[i]*vec2[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(vec1))]</span><br>[8, 12, -54]<br></code></pre></td></tr></table></figure><p>列表推导式可以使用复杂表达式或嵌套函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">355</span>/<span class="hljs-number">113</span>, i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)]<br>[<span class="hljs-string">&#x27;3.1&#x27;</span>, <span class="hljs-string">&#x27;3.14&#x27;</span>, <span class="hljs-string">&#x27;3.142&#x27;</span>, <span class="hljs-string">&#x27;3.1416&#x27;</span>, <span class="hljs-string">&#x27;3.14159&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="嵌套列表解析"><a href="#嵌套列表解析" class="headerlink" title="嵌套列表解析"></a>嵌套列表解析</h2><p>Python的列表还可以嵌套。</p><p>以下实例展示了3X4的矩阵列表：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">matrix = [</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>],</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">]</span><br></code></pre></td></tr></table></figure><p>以下实例将3X4的矩阵列表转换为4X3列表：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;&gt;&gt; <span class="hljs-comment">[<span class="hljs-comment">[row<span class="hljs-comment">[i]</span> for row in matrix]</span> for i in range(4)]</span><br><span class="hljs-comment">[<span class="hljs-comment">[1, 5, 9]</span>, <span class="hljs-comment">[2, 6, 10]</span>, <span class="hljs-comment">[3, 7, 11]</span>, <span class="hljs-comment">[4, 8, 12]</span>]</span><br></code></pre></td></tr></table></figure><p>以下实例也可以使用以下方法来实现：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">transposed = []</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    transposed.append([row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix])</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">transposed</span><br>[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]<br></code></pre></td></tr></table></figure><p>另外一种实现方法：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">transposed = []</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-comment"># the following 3 lines implement the nested listcomp</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    transposed_row = []</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        transposed_row.append(row[i])</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    transposed.append(transposed_row)</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">transposed</span><br>[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]<br></code></pre></td></tr></table></figure><h2 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h2><p>使用 del 语句可以从一个列表中依索引而不是值来删除一个元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">66.25</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1234.5</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">del</span> a[<span class="hljs-number">0</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span><br>[1, 66.25, 333, 333, 1234.5]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">del</span> a[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span><br>[1, 66.25, 1234.5]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">del</span> a[:]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span><br>[]<br></code></pre></td></tr></table></figure><p>也可以用 del 删除实体变量：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">del</span> a</span><br></code></pre></td></tr></table></figure><h2 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h2><p>元组由若干逗号分隔的值组成，例如：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t = <span class="hljs-number">12345</span>, <span class="hljs-number">54321</span>, <span class="hljs-string">&#x27;hello!&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t[<span class="hljs-number">0</span>]</span><br>12345<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t</span><br>(12345, 54321, &#x27;hello!&#x27;)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Tuples may be nested:</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">u = t, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">u</span><br>((12345, 54321, &#x27;hello!&#x27;), (1, 2, 3, 4, 5))<br></code></pre></td></tr></table></figure><p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号，不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。</p><p>可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。</p><p>以下是一个简单的演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>basket = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(basket)                      <span class="hljs-comment"># 删除重复的</span><br>&#123;<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-keyword">in</span> basket                 <span class="hljs-comment"># 检测成员</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;crabgrass&#x27;</span> <span class="hljs-keyword">in</span> basket<br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 以下演示了两个集合的操作</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;alacazam&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a                                  <span class="hljs-comment"># a 中唯一的字母</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a - b                              <span class="hljs-comment"># 在 a 中的字母，但不在 b 中</span><br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a | b                              <span class="hljs-comment"># 在 a 或 b 中的字母</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="hljs-comment"># 在 a 和 b 中都有的字母</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a ^ b                              <span class="hljs-comment"># 在 a 或 b 中的字母，但不同时在 a 和 b 中</span><br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>集合也支持推导式：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml">&gt;&gt;&gt; a = &#123;<span class="hljs-variable language_">x</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span> in <span class="hljs-string">&#x27;abracadabra&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">x</span> <span class="hljs-keyword">not</span> in <span class="hljs-string">&#x27;abc&#x27;</span>&#125;<br>&gt;&gt;&gt; a<br>&#123;<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>另一个非常有用的 Python 内建数据类型是字典。</p><p>序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p><p>理解字典的最佳方式是把它看做无序的键&#x3D;&gt;值对集合。在同一个字典之内，关键字必须是互不相同。</p><p>一对大括号创建一个空的字典：{}。</p><p>这是一个字典运用的简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>tel = &#123;<span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>tel[<span class="hljs-string">&#x27;guido&#x27;</span>] = <span class="hljs-number">4127</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tel<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>, <span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>tel[<span class="hljs-string">&#x27;jack&#x27;</span>]<br><span class="hljs-number">4098</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> tel[<span class="hljs-string">&#x27;sape&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>tel[<span class="hljs-string">&#x27;irv&#x27;</span>] = <span class="hljs-number">4127</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tel<br>&#123;<span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>, <span class="hljs-string">&#x27;irv&#x27;</span>: <span class="hljs-number">4127</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(tel.keys())<br>[<span class="hljs-string">&#x27;irv&#x27;</span>, <span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(tel.keys())<br>[<span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-string">&#x27;irv&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;guido&#x27;</span> <span class="hljs-keyword">in</span> tel<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;jack&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> tel<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;&gt;&gt; <span class="hljs-title function_">dict</span>(<span class="hljs-params">[(<span class="hljs-string">&#x27;sape&#x27;</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">&#x27;guido&#x27;</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">4098</span>)]</span>)<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>, <span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;guido&#x27;</span>: <span class="hljs-number">4127</span>&#125;<br></code></pre></td></tr></table></figure><p>此外，字典推导可以用来创建任意键和值的表达式词典：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&gt;&gt;&gt;</span> &#123;<span class="hljs-attr">x:</span> <span class="hljs-string">x**2</span> <span class="hljs-string">for</span> <span class="hljs-string">x</span> <span class="hljs-string">in</span> <span class="hljs-string">(2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span><span class="hljs-string">)</span>&#125;<br>&#123;<span class="hljs-attr">2:</span> <span class="hljs-number">4</span>, <span class="hljs-attr">4:</span> <span class="hljs-number">16</span>, <span class="hljs-attr">6:</span> <span class="hljs-number">36</span>&#125;<br></code></pre></td></tr></table></figure><p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; dict(<span class="hljs-attribute">sape</span>=4139, <span class="hljs-attribute">guido</span>=4127, <span class="hljs-attribute">jack</span>=4098)<br>&#123;<span class="hljs-string">&#x27;sape&#x27;</span>: 4139, <span class="hljs-string">&#x27;jack&#x27;</span>: 4098, <span class="hljs-string">&#x27;guido&#x27;</span>: 4127&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h2><p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">knights = &#123;<span class="hljs-string">&#x27;gallahad&#x27;</span>: <span class="hljs-string">&#x27;the pure&#x27;</span>, <span class="hljs-string">&#x27;robin&#x27;</span>: <span class="hljs-string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> knights.items():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(k, v)</span><br><span class="hljs-meta prompt_">...</span><br>gallahad the pure<br>robin the brave<br></code></pre></td></tr></table></figure><p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;tic&#x27;</span>, <span class="hljs-string">&#x27;tac&#x27;</span>, <span class="hljs-string">&#x27;toe&#x27;</span>]):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(i, v)</span><br><span class="hljs-meta prompt_">...</span><br>0 tic<br>1 tac<br>2 toe<br></code></pre></td></tr></table></figure><p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">questions = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;quest&#x27;</span>, <span class="hljs-string">&#x27;favorite color&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">answers = [<span class="hljs-string">&#x27;lancelot&#x27;</span>, <span class="hljs-string">&#x27;the holy grail&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> q, a <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(questions, answers):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(q, a))</span><br><span class="hljs-meta prompt_">...</span><br>What is your name?  It is lancelot.<br>What is your quest?  It is the holy grail.<br>What is your favorite color?  It is blue.<br></code></pre></td></tr></table></figure><p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(i)</span><br><span class="hljs-meta prompt_">...</span><br>9<br>7<br>5<br>3<br>1<br></code></pre></td></tr></table></figure><p>要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">basket = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(basket)):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(f)</span><br><span class="hljs-meta prompt_">...</span><br>apple<br>banana<br>orange<br>pear<br></code></pre></td></tr></table></figure><h1 id="Python3模块"><a href="#Python3模块" class="headerlink" title="Python3模块"></a>Python3模块</h1><p>在前面的几个章节中我们基本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p><p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p><p>下面是一个使用 python 标准库中模块的例子。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 文件名: using_sys.py</span><br> <br>import sys<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;命令行参数如下:&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.argv:<br>   <span class="hljs-built_in">print</span>(i)<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n\nPython 路径为：&#x27;</span>, sys.path, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ python using_sys.py 参数<span class="hljs-number">1</span> 参数<span class="hljs-number">2</span><br>命令行参数如下:<br>using_sys.py<br>参数<span class="hljs-number">1</span><br>参数<span class="hljs-number">2</span><br><br><br><span class="hljs-type">Python</span> 路径为： [&#x27;<span class="hljs-regexp">/root&#x27;, &#x27;/</span>usr<span class="hljs-regexp">/lib/</span>python3.<span class="hljs-number">4</span>&#x27;, &#x27;<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3.4/</span>plat<span class="hljs-operator">-</span>x86_64<span class="hljs-operator">-</span>linux<span class="hljs-operator">-</span>gnu&#x27;, &#x27;<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3.4/</span>lib<span class="hljs-operator">-</span>dynload&#x27;, &#x27;<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>python3.<span class="hljs-number">4</span><span class="hljs-regexp">/dist-packages&#x27;, &#x27;/</span>usr<span class="hljs-regexp">/lib/</span>python3<span class="hljs-operator">/</span>dist<span class="hljs-operator">-</span>packages&#x27;] <br></code></pre></td></tr></table></figure><ul><li>1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。</li><li>2、sys.argv 是一个包含命令行参数的列表。</li><li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li></ul><h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><p>想使用Python源文件，只需在另一个源文件里执行import语句，语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">import</span> <span class="hljs-keyword">module</span><span class="hljs-number">1</span>[, <span class="hljs-keyword">module</span><span class="hljs-number">2</span>[,... moduleN]<br></code></pre></td></tr></table></figure><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p><p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Filename: support.py</span><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_func</span>(<span class="hljs-params"> par </span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Hello : &quot;</span>, par)<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>test.py 引入 support 模块：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># Filename: test.py</span><br> <br><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> support<br> <br><span class="hljs-comment"># 现在可以调用模块里包含的函数了</span><br>support.print_func(<span class="hljs-string">&quot;Runoob&quot;</span>)<br><span class="hljs-comment">#以上实例输出结果：</span><br><span class="hljs-variable">$ </span>python3 test.py <br><span class="hljs-title class_">Hello</span> :  <span class="hljs-title class_">Runoob</span><br></code></pre></td></tr></table></figure><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p><p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p><p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p><p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&gt;&gt;&gt;</span> <span class="hljs-keyword">import</span> sys<br><span class="hljs-operator">&gt;&gt;&gt;</span> sys.path<br>[&#x27;&#x27;, &#x27;<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3.4&#x27;, &#x27;/</span>usr<span class="hljs-regexp">/lib/</span>python3.<span class="hljs-number">4</span><span class="hljs-regexp">/plat-x86_64-linux-gnu&#x27;, &#x27;/</span>usr<span class="hljs-regexp">/lib/</span>python3.<span class="hljs-number">4</span><span class="hljs-regexp">/lib-dynload&#x27;, &#x27;/</span>usr<span class="hljs-regexp">/local/</span>lib<span class="hljs-regexp">/python3.4/</span>dist<span class="hljs-operator">-</span>packages&#x27;, &#x27;<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3/</span>dist<span class="hljs-operator">-</span>packages&#x27;]<br><span class="hljs-operator">&gt;&gt;&gt;</span> <br></code></pre></td></tr></table></figure><p>sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p><p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p><p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p><p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 斐波那契(fibonacci)数列模块</span><br> <br>def fib(n):    <span class="hljs-comment"># 定义到 n 的斐波那契数列</span><br>    <span class="hljs-keyword">a</span>, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> b &lt; n:<br>        print(b, <span class="hljs-keyword">end</span>=<span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-keyword">a</span>, b = b, <span class="hljs-keyword">a</span>+b<br>    print()<br> <br>def fib2(n): <span class="hljs-comment"># 返回到 n 的斐波那契数列</span><br>    <span class="hljs-built_in">result</span> = []<br>    <span class="hljs-keyword">a</span>, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> b &lt; n:<br>        <span class="hljs-built_in">result</span>.append(b)<br>        <span class="hljs-keyword">a</span>, b = b, <span class="hljs-keyword">a</span>+b<br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p>然后进入Python解释器，使用下面的命令导入这个模块：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> fibo</span><br></code></pre></td></tr></table></figure><p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p><p>可以使用模块名称来访问函数：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">&gt;&gt;&gt;fibo.fib(1000)<br>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>5<span class="hljs-number"> 8 </span>13<span class="hljs-number"> 21 </span>34<span class="hljs-number"> 55 </span>89<span class="hljs-number"> 144 </span>233<span class="hljs-number"> 377 </span>610 987<br>&gt;&gt;&gt; fibo.fib2(100)<br>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]<br>&gt;&gt;&gt; fibo.__name__<br>&#x27;fibo&#x27;<br></code></pre></td></tr></table></figure><p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">&gt;&gt;&gt; fib = fibo.fib<br>&gt;&gt;&gt; fib(500)<br>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>5<span class="hljs-number"> 8 </span>13<span class="hljs-number"> 21 </span>34<span class="hljs-number"> 55 </span>89<span class="hljs-number"> 144 </span>233 377<br></code></pre></td></tr></table></figure><h2 id="from-…-import-语句"><a href="#from-…-import-语句" class="headerlink" title="from … import 语句"></a>from … import 语句</h2><p>Python的from语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> name1[, name2[, ... nameN]]<br></code></pre></td></tr></table></figure><p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> fibo <span class="hljs-keyword">import</span> fib, fib2</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fib(<span class="hljs-number">500</span>)</span><br>1 1 2 3 5 8 13 21 34 55 89 144 233 377<br></code></pre></td></tr></table></figure><p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p><h2 id="from-…-import-语句-1"><a href="#from-…-import-语句-1" class="headerlink" title="from … import * 语句"></a>from … import * 语句</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p><h2 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h2><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p><p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p><p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。</p><p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。</p><p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p><p>还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> fibo <span class="hljs-keyword">import</span> fib, fib2</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fib(<span class="hljs-number">500</span>)</span><br>1 1 2 3 5 8 13 21 34 55 89 144 233 377<br></code></pre></td></tr></table></figure><p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。</p><p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> fibo <span class="hljs-keyword">import</span> *</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fib(<span class="hljs-number">500</span>)</span><br>1 1 2 3 5 8 13 21 34 55 89 144 233 377<br></code></pre></td></tr></table></figure><p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="_name__属性"></a>_name__属性</h2><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Filename: using_name.py</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序自身在运行&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我来自另一模块&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行输出如下：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">$ python using_name.py<br>程序自身在运行<br>$ python<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> using_name</span><br>我来自另一模块<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 每个模块都有一个__name__属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p><p>说明：<strong><strong>name</strong></strong> 与 <em><strong>*main*</strong></em> 底下是双下划线， <strong>_ _</strong> 是这样去掉中间的那个空格。</p><h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h2><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fibo, sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(fibo)<br>[<span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;fib&#x27;</span>, <span class="hljs-string">&#x27;fib2&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(sys)  <br>[<span class="hljs-string">&#x27;__displayhook__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__excepthook__&#x27;</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>,<br> <span class="hljs-string">&#x27;__package__&#x27;</span>, <span class="hljs-string">&#x27;__stderr__&#x27;</span>, <span class="hljs-string">&#x27;__stdin__&#x27;</span>, <span class="hljs-string">&#x27;__stdout__&#x27;</span>,<br> <span class="hljs-string">&#x27;_clear_type_cache&#x27;</span>, <span class="hljs-string">&#x27;_current_frames&#x27;</span>, <span class="hljs-string">&#x27;_debugmallocstats&#x27;</span>, <span class="hljs-string">&#x27;_getframe&#x27;</span>,<br> <span class="hljs-string">&#x27;_home&#x27;</span>, <span class="hljs-string">&#x27;_mercurial&#x27;</span>, <span class="hljs-string">&#x27;_xoptions&#x27;</span>, <span class="hljs-string">&#x27;abiflags&#x27;</span>, <span class="hljs-string">&#x27;api_version&#x27;</span>, <span class="hljs-string">&#x27;argv&#x27;</span>,<br> <span class="hljs-string">&#x27;base_exec_prefix&#x27;</span>, <span class="hljs-string">&#x27;base_prefix&#x27;</span>, <span class="hljs-string">&#x27;builtin_module_names&#x27;</span>, <span class="hljs-string">&#x27;byteorder&#x27;</span>,<br> <span class="hljs-string">&#x27;call_tracing&#x27;</span>, <span class="hljs-string">&#x27;callstats&#x27;</span>, <span class="hljs-string">&#x27;copyright&#x27;</span>, <span class="hljs-string">&#x27;displayhook&#x27;</span>,<br> <span class="hljs-string">&#x27;dont_write_bytecode&#x27;</span>, <span class="hljs-string">&#x27;exc_info&#x27;</span>, <span class="hljs-string">&#x27;excepthook&#x27;</span>, <span class="hljs-string">&#x27;exec_prefix&#x27;</span>,<br> <span class="hljs-string">&#x27;executable&#x27;</span>, <span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-string">&#x27;flags&#x27;</span>, <span class="hljs-string">&#x27;float_info&#x27;</span>, <span class="hljs-string">&#x27;float_repr_style&#x27;</span>,<br> <span class="hljs-string">&#x27;getcheckinterval&#x27;</span>, <span class="hljs-string">&#x27;getdefaultencoding&#x27;</span>, <span class="hljs-string">&#x27;getdlopenflags&#x27;</span>,<br> <span class="hljs-string">&#x27;getfilesystemencoding&#x27;</span>, <span class="hljs-string">&#x27;getobjects&#x27;</span>, <span class="hljs-string">&#x27;getprofile&#x27;</span>, <span class="hljs-string">&#x27;getrecursionlimit&#x27;</span>,<br> <span class="hljs-string">&#x27;getrefcount&#x27;</span>, <span class="hljs-string">&#x27;getsizeof&#x27;</span>, <span class="hljs-string">&#x27;getswitchinterval&#x27;</span>, <span class="hljs-string">&#x27;gettotalrefcount&#x27;</span>,<br> <span class="hljs-string">&#x27;gettrace&#x27;</span>, <span class="hljs-string">&#x27;hash_info&#x27;</span>, <span class="hljs-string">&#x27;hexversion&#x27;</span>, <span class="hljs-string">&#x27;implementation&#x27;</span>, <span class="hljs-string">&#x27;int_info&#x27;</span>,<br> <span class="hljs-string">&#x27;intern&#x27;</span>, <span class="hljs-string">&#x27;maxsize&#x27;</span>, <span class="hljs-string">&#x27;maxunicode&#x27;</span>, <span class="hljs-string">&#x27;meta_path&#x27;</span>, <span class="hljs-string">&#x27;modules&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>,<br> <span class="hljs-string">&#x27;path_hooks&#x27;</span>, <span class="hljs-string">&#x27;path_importer_cache&#x27;</span>, <span class="hljs-string">&#x27;platform&#x27;</span>, <span class="hljs-string">&#x27;prefix&#x27;</span>, <span class="hljs-string">&#x27;ps1&#x27;</span>,<br> <span class="hljs-string">&#x27;setcheckinterval&#x27;</span>, <span class="hljs-string">&#x27;setdlopenflags&#x27;</span>, <span class="hljs-string">&#x27;setprofile&#x27;</span>, <span class="hljs-string">&#x27;setrecursionlimit&#x27;</span>,<br> <span class="hljs-string">&#x27;setswitchinterval&#x27;</span>, <span class="hljs-string">&#x27;settrace&#x27;</span>, <span class="hljs-string">&#x27;stderr&#x27;</span>, <span class="hljs-string">&#x27;stdin&#x27;</span>, <span class="hljs-string">&#x27;stdout&#x27;</span>,<br> <span class="hljs-string">&#x27;thread_info&#x27;</span>, <span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-string">&#x27;version_info&#x27;</span>, <span class="hljs-string">&#x27;warnoptions&#x27;</span>]<br></code></pre></td></tr></table></figure><p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fibo<br><span class="hljs-meta">&gt;&gt;&gt; </span>fib = fibo.fib<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>() <span class="hljs-comment"># 得到一个当前模块中定义的属性列表</span><br>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;fib&#x27;</span>, <span class="hljs-string">&#x27;fibo&#x27;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">5</span> <span class="hljs-comment"># 建立一个新的变量 &#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>()<br>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a <span class="hljs-comment"># 删除变量名a</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>()<br>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h2 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h2><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。</p><p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p><p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。</p><p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.ps1<br><span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.ps2<br><span class="hljs-string">&#x27;... &#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="hljs-string">&#x27;C&gt; &#x27;</span><br>C&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob!&#x27;</span>)<br>Runoob!<br>C&gt; <br></code></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p><p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p><p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p><p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p><p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p><p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p><p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p><p>这里给出了一种可能的包结构（在分层的文件系统中）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sound/                          顶层包<br>      __init__<span class="hljs-selector-class">.py</span>               初始化 sound 包<br>      formats/                  文件格式转换子包<br>              __init__<span class="hljs-selector-class">.py</span><br>              wavread<span class="hljs-selector-class">.py</span><br>              wavwrite<span class="hljs-selector-class">.py</span><br>              aiffread<span class="hljs-selector-class">.py</span><br>              aiffwrite<span class="hljs-selector-class">.py</span><br>              auread<span class="hljs-selector-class">.py</span><br>              auwrite<span class="hljs-selector-class">.py</span><br>              ...<br>      effects/                  声音效果子包<br>              __init__<span class="hljs-selector-class">.py</span><br>              echo<span class="hljs-selector-class">.py</span><br>              surround<span class="hljs-selector-class">.py</span><br>              reverse<span class="hljs-selector-class">.py</span><br>              ...<br>      filters/                  filters 子包<br>              __init__<span class="hljs-selector-class">.py</span><br>              equalizer<span class="hljs-selector-class">.py</span><br>              vocoder<span class="hljs-selector-class">.py</span><br>              karaoke<span class="hljs-selector-class">.py</span><br>              ...<br></code></pre></td></tr></table></figure><p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p><p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p><p>最简单的情况，放一个空的 :file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。</p><p>用户可以每次只导入一个包里面的特定模块，比如:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sound.effects.echo<br></code></pre></td></tr></table></figure><p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sound.effects.echo.echofilter(input, output, <span class="hljs-attribute">delay</span>=0.7, <span class="hljs-attribute">atten</span>=4)<br></code></pre></td></tr></table></figure><p>还有一种导入子模块的方法是:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sound.effects <span class="hljs-keyword">import</span> echo<br></code></pre></td></tr></table></figure><p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">echo.echofilter(input, output, <span class="hljs-attribute">delay</span>=0.7, <span class="hljs-attribute">atten</span>=4)<br></code></pre></td></tr></table></figure><p>还有一种变化就是直接导入一个函数或者变量:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sound.effects.echo <span class="hljs-keyword">import</span> echofilter<br></code></pre></td></tr></table></figure><p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">echofilter(input, output, <span class="hljs-attribute">delay</span>=0.7, <span class="hljs-attribute">atten</span>=4)<br></code></pre></td></tr></table></figure><p>注意当使用 <strong>from package import item</strong> 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p><p>import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <strong>:exc:ImportError</strong> 异常。</p><p>反之，如果使用形如 <strong>import item.subitem.subsubitem</strong> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p><h2 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h2><p>如果我们使用 <strong>from sound.effects import *</strong> 会发生什么呢？</p><p>Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。</p><p>但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。</p><p>在 Windows 平台平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。</p><p>为了解决这个问题，我们只需要提供一个精确包的索引。</p><p>导入语句遵循如下规则：如果包定义文件 <em>***init*<em>.py*</em> 存在一个叫做 *</em>*<em>all*</em>** 的列表变量，那么在使用 <strong>from package import *</strong> 的时候就把这个列表中的所有名字作为包内容导入。</p><p>作为包的作者，可别忘了在更新包之后保证 <em><strong>*all*</strong></em> 也更新了啊。</p><p>以下实例在 file:sounds&#x2F;effects&#x2F;<strong>init</strong>.py 中包含如下代码:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">__all__</span> = [<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;surround&quot;</span>, <span class="hljs-string">&quot;reverse&quot;</span>]<br></code></pre></td></tr></table></figure><p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p><p>如果 <strong><strong>all</strong></strong> 真的没有定义，那么使用**from sound.effects import ***这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。</p><p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sound.effects.echo<br><span class="hljs-keyword">import</span> sound.effects.surround<br><span class="hljs-title">from</span> sound.effects <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p>这个例子中，在执行 from…import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 <strong>all</strong> 就更没问题了）</p><p>通常我们并不主张使用 ***** 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p><p>记住，使用 <strong>from Package import specific_submodule</strong> 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p><p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> echo<br><span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> formats<br><span class="hljs-keyword">from</span> ..filters <span class="hljs-keyword">import</span> equalizer<br></code></pre></td></tr></table></figure><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p><p>包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p><p>这个功能并不常用，一般用来扩展包里面的模块。</p><h1 id="Python3输入和输出"><a href="#Python3输入和输出" class="headerlink" title="Python3输入和输出"></a>Python3输入和输出</h1><h2 id="输出格式美化"><a href="#输出格式美化" class="headerlink" title="输出格式美化"></a>输出格式美化</h2><p>Python两种输出值的方式: 表达式语句和 print() 函数。</p><p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。</p><p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p><p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p><ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">&#x27;Hello, Runoob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">str</span>(s)</span><br>&#x27;Hello, Runoob&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">repr</span>(s)</span><br>&quot;&#x27;Hello, Runoob&#x27;&quot;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>/<span class="hljs-number">7</span>)</span><br>&#x27;0.14285714285714285&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x = <span class="hljs-number">10</span> * <span class="hljs-number">3.25</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">y = <span class="hljs-number">200</span> * <span class="hljs-number">200</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">&#x27;x 的值为： &#x27;</span> + <span class="hljs-built_in">repr</span>(x) + <span class="hljs-string">&#x27;,  y 的值为：&#x27;</span> + <span class="hljs-built_in">repr</span>(y) + <span class="hljs-string">&#x27;...&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(s)</span><br>x 的值为： 32.5,  y 的值为：40000...<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment">#  repr() 函数可以转义字符串中的特殊字符</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">hello = <span class="hljs-string">&#x27;hello, runoob\n&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">hellos = <span class="hljs-built_in">repr</span>(hello)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(hellos)</span><br>&#x27;hello, runoob\n&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># repr() 的参数可以是 Python 的任何对象</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-built_in">repr</span>((x, y, (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>)))</span><br>&quot;(32.5, 40000, (&#x27;Google&#x27;, &#x27;Runoob&#x27;))&quot;<br></code></pre></td></tr></table></figure><p>这里有两种方式输出一个平方与立方的表:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">&gt;&gt;&gt; for x in range(1, 11):<br>...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=&#x27; &#x27;)<br>...     <span class="hljs-comment"># 注意前一行 &#x27;end&#x27; 的使用</span><br>...     print(repr(x*x*x).rjust(4))<br>...<br><span class="hljs-number"> 1 </span> <span class="hljs-number"> 1 </span>   1<br><span class="hljs-number"> 2 </span> <span class="hljs-number"> 4 </span>   8<br><span class="hljs-number"> 3 </span> <span class="hljs-number"> 9 </span>  27<br><span class="hljs-number"> 4 </span><span class="hljs-number"> 16 </span>  64<br><span class="hljs-number"> 5 </span><span class="hljs-number"> 25 </span> 125<br><span class="hljs-number"> 6 </span><span class="hljs-number"> 36 </span> 216<br><span class="hljs-number"> 7 </span><span class="hljs-number"> 49 </span> 343<br><span class="hljs-number"> 8 </span><span class="hljs-number"> 64 </span> 512<br><span class="hljs-number"> 9 </span><span class="hljs-number"> 81 </span> 729<br>10<span class="hljs-number"> 100 </span>1000<br><br>&gt;&gt;&gt; for x in range(1, 11):<br>...     print(&#x27;&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;&#x27;.format(x, x*x, x*x*x))<br>...<br><span class="hljs-number"> 1 </span> <span class="hljs-number"> 1 </span>   1<br><span class="hljs-number"> 2 </span> <span class="hljs-number"> 4 </span>   8<br><span class="hljs-number"> 3 </span> <span class="hljs-number"> 9 </span>  27<br><span class="hljs-number"> 4 </span><span class="hljs-number"> 16 </span>  64<br><span class="hljs-number"> 5 </span><span class="hljs-number"> 25 </span> 125<br><span class="hljs-number"> 6 </span><span class="hljs-number"> 36 </span> 216<br><span class="hljs-number"> 7 </span><span class="hljs-number"> 49 </span> 343<br><span class="hljs-number"> 8 </span><span class="hljs-number"> 64 </span> 512<br><span class="hljs-number"> 9 </span><span class="hljs-number"> 81 </span> 729<br>10<span class="hljs-number"> 100 </span>1000<br></code></pre></td></tr></table></figure><p>**注意：**在第一个例子中, 每列间的空格由 print() 添加。</p><p>这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。</p><p>还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。</p><p>另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt; &#x27;12&#x27;.zfill<span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><br>&#x27;<span class="hljs-number">0001</span>2&#x27;<br>&gt;&gt;&gt; &#x27;-3.14&#x27;.zfill<span class="hljs-punctuation">(</span><span class="hljs-number">7</span><span class="hljs-punctuation">)</span><br>&#x27;-003.14&#x27;<br>&gt;&gt;&gt; &#x27;3.<span class="hljs-number">1415926535</span>9&#x27;.zfill<span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><br>&#x27;3.<span class="hljs-number">1415926535</span>9&#x27;<br></code></pre></td></tr></table></figure><p>str.format() 的基本使用如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>))<br>菜鸟教程网址： <span class="hljs-string">&quot;www.runoob.com!&quot;</span><br></code></pre></td></tr></table></figure><p>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。</p><p>在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>))</span><br>Google 和 Runoob<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;1&#125; 和 &#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>))</span><br>Runoob 和 Google<br></code></pre></td></tr></table></figure><p>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;name&#125;网址： &#123;site&#125;&#x27;</span>.format(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>, <span class="hljs-attribute">site</span>=<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>))<br>菜鸟教程网址： www.runoob.com<br></code></pre></td></tr></table></figure><p>位置及关键字参数可以任意的结合:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;站点列表 &#123;0&#125;, &#123;1&#125;, 和 &#123;other&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, other=<span class="hljs-string">&#x27;Taobao&#x27;</span>))</span><br>站点列表 Google, Runoob, 和 Taobao。<br></code></pre></td></tr></table></figure><p><strong>!a</strong> (使用 <strong>ascii()</strong>), <strong>!s</strong> (使用 <strong>str()</strong>) 和 <strong>!r</strong> (使用 <strong>repr()</strong>) 可以用于在格式化某个值之前对其进行转化:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> math</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;常量 PI 的值近似为： &#123;&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(math.pi))</span><br>常量 PI 的值近似为： 3.141592653589793。<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;常量 PI 的值近似为： &#123;!r&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(math.pi))</span><br>常量 PI 的值近似为： 3.141592653589793。<br></code></pre></td></tr></table></figure><p>可选项 <strong>:</strong> 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> math</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(math.pi))</span><br>常量 PI 的值近似为 3.142。<br></code></pre></td></tr></table></figure><p>在 <strong>:</strong> 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">table = &#123;<span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> name, number <span class="hljs-keyword">in</span> table.items():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, number))</span><br><span class="hljs-meta prompt_">...</span><br>Google     ==&gt;          1<br>Runoob     ==&gt;          2<br>Taobao     ==&gt;          3<br></code></pre></td></tr></table></figure><p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。</p><p>最简单的就是传入一个字典, 然后使用方括号 <strong>[]</strong> 来访问键值 :</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">table = &#123;<span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(table))</span><br>Runoob: 2; Google: 1; Taobao: 3<br></code></pre></td></tr></table></figure><p>也可以通过在 table 变量前使用 ****** 来实现相同的功能：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">table = &#123;<span class="hljs-string">&#x27;Google&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>: <span class="hljs-number">3</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Runoob: &#123;Runoob:d&#125;; Google: &#123;Google:d&#125;; Taobao: &#123;Taobao:d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(**table))</span><br>Runoob: 2; Google: 1; Taobao: 3<br></code></pre></td></tr></table></figure><h2 id="旧式字符串格式化"><a href="#旧式字符串格式化" class="headerlink" title="旧式字符串格式化"></a>旧式字符串格式化</h2><p><strong>%</strong> 操作符也可以实现字符串格式化。 它将左边的参数作为类似 <strong>sprintf()</strong> 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> math</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;常量 PI 的值近似为：%5.3f。&#x27;</span> % math.pi)</span><br>常量 PI 的值近似为：3.142。<br></code></pre></td></tr></table></figure><p>因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p><h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python 提供了 [input() 内置函数]从标准输入读入一行文本，默认的标准输入是键盘。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">str</span> = <span class="hljs-keyword">input</span>(<span class="hljs-string">&quot;请输入：&quot;</span>)<span class="hljs-comment">;</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;你输入的内容是: &quot;</span>, <span class="hljs-keyword">str</span>)<br></code></pre></td></tr></table></figure><p>这会产生如下的对应着输入的结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">请输入：菜鸟教程<br><span class="hljs-section">你输入的内容是:  菜鸟教程</span><br></code></pre></td></tr></table></figure><h2 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h2><p>open() 将会返回一个 file 对象，基本语法格式如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(filename, mode)</span></span><br></code></pre></td></tr></table></figure><ul><li>filename：包含了你要访问的文件名称的字符串值。</li><li>mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li></ul><p>不同模式打开文件的完全列表：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>下图很好的总结了这几种模式：</p><p><a href="https://www.runoob.com/wp-content/uploads/2013/11/2112205-861c05b2bdbc9c28.png"><img src="https://www.runoob.com/wp-content/uploads/2013/11/2112205-861c05b2bdbc9c28.png" alt="img"></a></p><table><thead><tr><th>模式</th><th>r</th><th>r+</th><th>w</th><th>w+</th><th>a</th><th>a+</th></tr></thead><tbody><tr><td>读</td><td>+</td><td>+</td><td></td><td>+</td><td></td><td>+</td></tr><tr><td>写</td><td></td><td>+</td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>创建</td><td></td><td></td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>覆盖</td><td></td><td></td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>指针在开始</td><td>+</td><td>+</td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>指针在结尾</td><td></td><td></td><td></td><td></td><td>+</td><td>+</td></tr></tbody></table><p>以下实例将字符串写入到文件 foo.txt 中：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><br>f.<span class="hljs-built_in">write</span>( <span class="hljs-string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )<br><br><span class="hljs-comment"># 关闭打开的文件</span><br>f.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><ul><li>第一个参数为要打开的文件名。</li><li>第二个参数描述文件如何使用的字符。 mode 可以是 ‘r’ 如果文件只读, ‘w’ 只用于写 (如果存在同名文件则将被删除), 和 ‘a’ 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. ‘r+’ 同时用于读写。 mode 参数是可选的; ‘r’ 将是默认值。</li></ul><p>此时打开文件 foo.txt,显示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /tmp/foo.txt</span> <br>Python 是一个非常好的语言。<br>是的，的确非常好!!<br></code></pre></td></tr></table></figure><h2 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h2><p>本节中剩下的例子假设已经创建了一个称为 f 的文件对象。</p><h3 id="f-read"><a href="#f-read" class="headerlink" title="f.read()"></a>f.read()</h3><p>为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。</p><p>size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。</p><p>以下实例假定文件 foo.txt 已存在（上面实例中已创建）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br><br><span class="hljs-built_in">str</span> = f.read()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment"># 关闭打开的文件</span><br>f.close()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">执行以上程序，输出结果为：<br><br>Python 是一个非常好的语言。<br>是的，的确非常好!!<br></code></pre></td></tr></table></figure><h3 id="f-readline"><a href="#f-readline" class="headerlink" title="f.readline()"></a>f.readline()</h3><p>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br><br><span class="hljs-built_in">str</span> = f.readline()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment"># 关闭打开的文件</span><br>f.close()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Python</span> 是一个非常好的语言。<br></code></pre></td></tr></table></figure><h3 id="f-readlines"><a href="#f-readlines" class="headerlink" title="f.readlines()"></a>f.readlines()</h3><p>f.readlines() 将返回该文件中包含的所有行。</p><p>如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br><br><span class="hljs-built_in">str</span> = f.readlines()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment"># 关闭打开的文件</span><br>f.close()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;Python</span> 是一个非常好的语言。\n&#x27;, <span class="hljs-symbol">&#x27;是的，的确非常好!!</span>\n&#x27;]<br></code></pre></td></tr></table></figure><p>另一种方式是迭代一个文件对象然后读取每行:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> f:<br>    print(<span class="hljs-built_in">line</span>, <span class="hljs-keyword">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 关闭打开的文件</span><br>f.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Python 是一个非常好的语言。<br>是的，的确非常好!!<br></code></pre></td></tr></table></figure><p>这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同, 最好不要混用。</p><h3 id="f-write"><a href="#f-write" class="headerlink" title="f.write()"></a>f.write()</h3><p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><br><span class="hljs-built_in">num</span> = f.<span class="hljs-built_in">write</span>( <span class="hljs-string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )<br>print(<span class="hljs-built_in">num</span>)<br><span class="hljs-comment"># 关闭打开的文件</span><br>f.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">29<br></code></pre></td></tr></table></figure><p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 打开一个文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/tmp/foo1.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><br><span class="hljs-built_in">value</span> = (<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>, <span class="hljs-number">14</span>)<br>s = str(<span class="hljs-built_in">value</span>)<br>f.<span class="hljs-built_in">write</span>(s)<br><br><span class="hljs-comment"># 关闭打开的文件</span><br>f.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p>执行以上程序，打开 foo1.txt 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /tmp/foo1.txt <br>(<span class="hljs-string">&#x27;www.runoob.com&#x27;</span>, 14)<br></code></pre></td></tr></table></figure><h3 id="f-tell"><a href="#f-tell" class="headerlink" title="f.tell()"></a>f.tell()</h3><p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</p><h3 id="f-seek"><a href="#f-seek" class="headerlink" title="f.seek()"></a>f.seek()</h3><p>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p><p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：</p><ul><li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li><li>seek(x,1) ： 表示从当前位置往后移动x个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li></ul><p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="hljs-string">&#x27;rb+&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.write(<span class="hljs-string">b&#x27;0123456789abcdef&#x27;</span>)</span><br>16<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.seek(<span class="hljs-number">5</span>)     <span class="hljs-comment"># 移动到文件的第六个字节</span></span><br>5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.read(<span class="hljs-number">1</span>)</span><br>b&#x27;5&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.seek(-<span class="hljs-number">3</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 移动到文件的倒数第三字节</span></span><br>13<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.read(<span class="hljs-number">1</span>)</span><br>b&#x27;d&#x27;<br></code></pre></td></tr></table></figure><h3 id="f-close"><a href="#f-close" class="headerlink" title="f.close()"></a>f.close()</h3><p>在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。</p><p>当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">&gt;&gt;&gt; <span class="hljs-keyword">f</span>.<span class="hljs-keyword">close</span>()<br>&gt;&gt;&gt; <span class="hljs-keyword">f</span>.<span class="hljs-keyword">read</span>()<br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in ?<br>ValueError: I/O operation <span class="hljs-keyword">on</span> closed <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    read_data = f.read()</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.closed</span><br>True<br></code></pre></td></tr></table></figure><p>文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。</p><h2 id="pickle-模块"><a href="#pickle-模块" class="headerlink" title="pickle 模块"></a>pickle 模块</h2><p>python的pickle模块实现了基本的数据序列和反序列化。</p><p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p><p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>基本接口：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">pickle.<span class="hljs-keyword">dump</span>(obj, <span class="hljs-keyword">file</span>, [,protocol])<br></code></pre></td></tr></table></figure><p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> pickle.load(file)<br></code></pre></td></tr></table></figure><p>**注解：**从 file 中读取一个字符串，并将它重构为原来的python对象。</p><p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-comment"># 使用pickle模块将数据对象保存到文件</span><br>data1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>+<span class="hljs-number">6j</span>],<br>         <span class="hljs-string">&#x27;b&#x27;</span>: (<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-string">u&#x27;Unicode string&#x27;</span>),<br>         <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br><br>selfref_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>selfref_list.append(selfref_list)<br><br>output = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br><br><span class="hljs-comment"># Pickle dictionary using protocol 0.</span><br>pickle.dump(data1, output)<br><br><span class="hljs-comment"># Pickle the list using the highest protocol available.</span><br>pickle.dump(selfref_list, output, -<span class="hljs-number">1</span>)<br><br>output.close()<br><span class="hljs-keyword">import</span> pprint, pickle<br><br><span class="hljs-comment">#使用pickle模块从文件中重构python对象</span><br>pkl_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br><br>data1 = pickle.load(pkl_file)<br>pprint.pprint(data1)<br><br>data2 = pickle.load(pkl_file)<br>pprint.pprint(data2)<br><br>pkl_file.close()<br></code></pre></td></tr></table></figure><h1 id="Python3-File-文件-方法"><a href="#Python3-File-文件-方法" class="headerlink" title="Python3 File(文件) 方法"></a>Python3 File(文件) 方法</h1><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open() 方法"></a>open() 方法</h3><p>Python open（）方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出OSError。</p><p>**注意：**使用open（）方法一定要保证关闭文件对象，即调用close（）方法。</p><p>open（）函数常用形式是接收两个参数：文件名（file）和模式（mode）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">open(file, <span class="hljs-attribute">mode</span>=<span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-comment">#完整语法格式</span><br>open(file, <span class="hljs-attribute">mode</span>=<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-attribute">buffering</span>=-1, <span class="hljs-attribute">encoding</span>=None, <span class="hljs-attribute">errors</span>=None, <span class="hljs-attribute">newline</span>=None, <span class="hljs-attribute">closefd</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">opener</span>=None)<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li></ul><p>mode 参数有：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（<strong>Python 3 不支持</strong>）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p><h3 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h3><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th>序号</th><th>方法及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a>**Python 3 中的 File 对象不支持 next() 方法。**返回文件下一行。</td></tr><tr><td>6</td><td>[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td>7</td><td>[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td>8</td><td>[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td>9</td><td>[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td>11</td><td>[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><h1 id="Python3-OS-文件-目录方法"><a href="#Python3-OS-文件-目录方法" class="headerlink" title="Python3 OS 文件&#x2F;目录方法"></a>Python3 OS 文件&#x2F;目录方法</h1><p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p><table><thead><tr><th>序号</th><th>方法及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/python3/python3-os-access.html">os.access(path, mode)</a> 检验权限模式</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/python3/python3-os-chdir.html">os.chdir(path)</a> 改变当前工作目录</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/python3/python3-os-chflags.html">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/python3/python3-os-chmod.html">os.chmod(path, mode)</a> 更改权限</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/python3/python3-os-chown.html">os.chown(path, uid, gid)</a> 更改文件所有者</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/python3/python3-os-chroot.html">os.chroot(path)</a> 改变当前进程的根目录</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/python3/python3-os-close.html">os.close(fd)</a> 关闭文件描述符 fd</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/python3/python3-os-closerange.html">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/python3/python3-os-dup.html">os.dup(fd)</a> 复制文件描述符 fd</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/python3/python3-os-dup2.html">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td></tr><tr><td>11</td><td><a href="https://www.runoob.com/python3/python3-os-fchdir.html">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/python3/python3-os-fchmod.html">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td></tr><tr><td>13</td><td><a href="https://www.runoob.com/python3/python3-os-fchown.html">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td></tr><tr><td>14</td><td><a href="https://www.runoob.com/python3/python3-os-fdatasync.html">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td></tr><tr><td>15</td><td>[os.fdopen(fd<a href="https://www.runoob.com/python3/python3-os-fdopen.html">, mode[, bufsize]])</a> 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td></tr><tr><td>16</td><td><a href="https://www.runoob.com/python3/python3-os-fpathconf.html">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td></tr><tr><td>17</td><td><a href="https://www.runoob.com/python3/python3-os-fstat.html">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td></tr><tr><td>18</td><td><a href="https://www.runoob.com/python3/python3-os-fstatvfs.html">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td></tr><tr><td>19</td><td><a href="https://www.runoob.com/python3/python3-os-fsync.html">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td></tr><tr><td>20</td><td><a href="https://www.runoob.com/python3/python3-os-ftruncate.html">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td></tr><tr><td>21</td><td><a href="https://www.runoob.com/python3/python3-os-getcwd.html">os.getcwd()</a> 返回当前工作目录</td></tr><tr><td>22</td><td><a href="https://www.runoob.com/python3/python3-os-getcwdb.html">os.getcwdb()</a> 返回一个当前工作目录的Unicode对象</td></tr><tr><td>23</td><td><a href="https://www.runoob.com/python3/python3-os-isatty.html">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td></tr><tr><td>24</td><td><a href="https://www.runoob.com/python3/python3-os-lchflags.html">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td></tr><tr><td>25</td><td><a href="https://www.runoob.com/python3/python3-os-lchmod.html">os.lchmod(path, mode)</a> 修改连接文件权限</td></tr><tr><td>26</td><td><a href="https://www.runoob.com/python3/python3-os-lchown.html">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td></tr><tr><td>27</td><td><a href="https://www.runoob.com/python3/python3-os-link.html">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td></tr><tr><td>28</td><td><a href="https://www.runoob.com/python3/python3-os-listdir.html">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td></tr><tr><td>29</td><td><a href="https://www.runoob.com/python3/python3-os-lseek.html">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td></tr><tr><td>30</td><td><a href="https://www.runoob.com/python3/python3-os-lstat.html">os.lstat(path)</a> 像stat(),但是没有软链接</td></tr><tr><td>31</td><td><a href="https://www.runoob.com/python3/python3-os-major.html">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td></tr><tr><td>32</td><td><a href="https://www.runoob.com/python3/python3-os-makedev.html">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td></tr><tr><td>33</td><td>[os.makedirs(path<a href="https://www.runoob.com/python3/python3-os-makedirs.html">, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td></tr><tr><td>34</td><td><a href="https://www.runoob.com/python3/python3-os-minor.html">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td></tr><tr><td>35</td><td>[os.mkdir(path<a href="https://www.runoob.com/python3/python3-os-mkdir.html">, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td></tr><tr><td>36</td><td>[os.mkfifo(path<a href="https://www.runoob.com/python3/python3-os-mkfifo.html">, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td></tr><tr><td>37</td><td>[os.mknod(filename<a href="https://www.runoob.com/python3/python3-os-mknod.html">, mode&#x3D;0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td></tr><tr><td>38</td><td>[os.open(file, flags<a href="https://www.runoob.com/python3/python3-os-open.html">, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td></tr><tr><td>39</td><td><a href="https://www.runoob.com/python3/python3-os-openpty.html">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td></tr><tr><td>40</td><td><a href="https://www.runoob.com/python3/python3-os-pathconf.html">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td></tr><tr><td>41</td><td><a href="https://www.runoob.com/python3/python3-os-pipe.html">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td></tr><tr><td>42</td><td>[os.popen(command<a href="https://www.runoob.com/python3/python3-os-popen.html">, mode[, bufsize]])</a> 从一个 command 打开一个管道</td></tr><tr><td>43</td><td><a href="https://www.runoob.com/python3/python3-os-read.html">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td></tr><tr><td>44</td><td><a href="https://www.runoob.com/python3/python3-os-readlink.html">os.readlink(path)</a> 返回软链接所指向的文件</td></tr><tr><td>45</td><td><a href="https://www.runoob.com/python3/python3-os-remove.html">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td></tr><tr><td>46</td><td><a href="https://www.runoob.com/python3/python3-os-removedirs.html">os.removedirs(path)</a> 递归删除目录。</td></tr><tr><td>47</td><td><a href="https://www.runoob.com/python3/python3-os-rename.html">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td></tr><tr><td>48</td><td><a href="https://www.runoob.com/python3/python3-os-renames.html">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td></tr><tr><td>49</td><td><a href="https://www.runoob.com/python3/python3-os-rmdir.html">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td></tr><tr><td>50</td><td><a href="https://www.runoob.com/python3/python3-os-stat.html">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td></tr><tr><td>51</td><td>[os.stat_float_times(<a href="https://www.runoob.com/python3/python3-os-stat_float_times.html">newvalue])</a> 决定stat_result是否以float对象显示时间戳</td></tr><tr><td>52</td><td><a href="https://www.runoob.com/python3/python3-os-statvfs.html">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td></tr><tr><td>53</td><td><a href="https://www.runoob.com/python3/python3-os-symlink.html">os.symlink(src, dst)</a> 创建一个软链接</td></tr><tr><td>54</td><td><a href="https://www.runoob.com/python3/python3-os-tcgetpgrp.html">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td></tr><tr><td>55</td><td><a href="https://www.runoob.com/python3/python3-os-tcsetpgrp.html">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td></tr><tr><td>56</td><td>os.tempnam([dir[, prefix]]) **Python3 中已删除。**返回唯一的路径名用于创建临时文件。</td></tr><tr><td>57</td><td>os.tmpfile() **Python3 中已删除。**返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td></tr><tr><td>58</td><td>os.tmpnam() **Python3 中已删除。**为创建一个临时文件返回一个唯一的路径</td></tr><tr><td>59</td><td><a href="https://www.runoob.com/python3/python3-os-ttyname.html">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td></tr><tr><td>60</td><td><a href="https://www.runoob.com/python3/python3-os-unlink.html">os.unlink(path)</a> 删除文件路径</td></tr><tr><td>61</td><td><a href="https://www.runoob.com/python3/python3-os-utime.html">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td></tr><tr><td>62</td><td>[os.walk(top[, topdown&#x3D;True[, onerror&#x3D;None[, followlinks&#x3D;False]]])](<a href="https://www.runoob.com/python3/python3-os-walk.html">https://www.runoob.com/python3/python3-os-walk.html</a>) 输出在文件夹中的文件名通过在树中游走，向上或者向下。</td></tr><tr><td>63</td><td><a href="https://www.runoob.com/python3/python3-os-write.html">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td></tr><tr><td>64</td><td><a href="https://www.runoob.com/python3/python3-os-path.html">os.path 模块</a> 获取文件的属性信息。</td></tr><tr><td>65</td><td><a href="https://www.runoob.com/python3/python3-os-pardir.html">os.pardir()</a> 获取当前目录的父目录，以字符串形式显示目录名。</td></tr></tbody></table><h1 id="Python3-错误和异常"><a href="#Python3-错误和异常" class="headerlink" title="Python3 错误和异常"></a>Python3 错误和异常</h1><p>作为 Python 初学者，在刚学习 Python 编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。</p><p>Python 有两种错误很容易辨认：语法错误和异常。</p><p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="hljs-keyword">in</span> ?<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br>                   ^<br>SyntaxError: invalid syntax<br></code></pre></td></tr></table></figure><p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号 <strong>:</strong> 。</p><p>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。<strong>运行期</strong>检测到的错误被称为异常。</p><p>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">&gt;&gt;&gt; <span class="hljs-number">10</span> * (<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)             # <span class="hljs-number">0</span> 不能作为除数，触发异常<br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in ?<br>ZeroDivisionError: division by zero<br>&gt;&gt;&gt; <span class="hljs-number">4</span> + spam*<span class="hljs-number">3</span>             # spam 未定义，触发异常<br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in ?<br>NameError: name <span class="hljs-string">&#x27;spam&#x27;</span> <span class="hljs-keyword">is</span> not defined<br>&gt;&gt;&gt; <span class="hljs-string">&#x27;2&#x27;</span> + <span class="hljs-number">2</span>               # <span class="hljs-keyword">int</span> 不能与 str 相加，触发异常<br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>TypeError: can <span class="hljs-keyword">only</span> concatenate str (not <span class="hljs-string">&quot;int&quot;</span>) <span class="hljs-keyword">to</span> str<br></code></pre></td></tr></table></figure><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。</p><p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-except"><a href="#try-except" class="headerlink" title="try&#x2F;except"></a>try&#x2F;except</h3><p>异常捕捉可以使用 <strong>try&#x2F;except</strong> 语句。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/07/try_except.png"><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except.png" alt="img"></a></p><p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">while</span></span> <span class="hljs-variable"><span class="hljs-literal">True</span></span>:<br>    <span class="hljs-variable"><span class="hljs-keyword">try</span></span>:<br>        <span class="hljs-variable">x</span> = <span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-title">input</span>(<span class="hljs-string">&quot;请输入一个数字: &quot;</span>))</span><br>        <span class="hljs-variable">break</span><br>    <span class="hljs-variable"><span class="hljs-keyword">except</span></span> <span class="hljs-variable">ValueError</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;您输入的不是数字，请再次尝试输入！&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>try 语句按照如下方式工作；</p><ul><li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。</li><li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li><li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。</li><li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li></ul><p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">except</span> (RuntimeError, TypeError, NameError):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;myfile.txt&#x27;</span>)<br>    s = f.readline()<br>    i = <span class="hljs-built_in">int</span>(s.strip())<br><span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> err:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;OS error: &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(err))<br><span class="hljs-keyword">except</span> ValueError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Could not convert data to an integer.&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unexpected error:&quot;</span>, sys.exc_info()[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure><h3 id="try-except…else"><a href="#try-except…else" class="headerlink" title="try&#x2F;except…else"></a>try&#x2F;except…else</h3><p><strong>try&#x2F;except</strong> 语句还有一个可选的 <strong>else</strong> 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。</p><p>else 子句将在 try 子句没有发生任何异常的时候执行。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else.png"><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else.png" alt="img"></a></p><p>以下实例在 try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> <span class="hljs-built_in">arg</span> <span class="hljs-keyword">in</span> sys.argv[<span class="hljs-number">1</span>:]:<br>    try:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-built_in">arg</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    except IOError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;cannot open&#x27;</span>, <span class="hljs-built_in">arg</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">arg</span>, <span class="hljs-string">&#x27;has&#x27;</span>, <span class="hljs-built_in">len</span>(f.readlines()), <span class="hljs-string">&#x27;lines&#x27;</span>)<br>        f.<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。</p><p>异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">this_fails</span>():<br>        x = <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br>   <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br>        this_fails()<br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> err:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Handling run-time error:&#x27;</span>, err)<br>   <br>Handling run-time error: <span class="hljs-built_in">int</span> division <span class="hljs-keyword">or</span> modulo by zero<br></code></pre></td></tr></table></figure><h3 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h3><p>try-finally 语句无论是否发生异常都将执行最后的代码。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else_finally.png"><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else_finally.png" alt="img"></a></p><p>以下实例中 finally 语句无论异常是否发生都会执行：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">try</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">runoob</span>()</span><br><span class="hljs-variable"><span class="hljs-keyword">except</span></span> <span class="hljs-variable">AssertionError</span> <span class="hljs-variable">as</span> <span class="hljs-variable">error</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">error</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-variable"><span class="hljs-keyword">try</span></span>:<br>        <span class="hljs-variable">with</span> <span class="hljs-function"><span class="hljs-title">open</span>(<span class="hljs-string">&#x27;file.log&#x27;</span>) <span class="hljs-variable">as</span> <span class="hljs-variable">file</span>:</span><br><span class="hljs-function">            <span class="hljs-variable">read_data</span> = <span class="hljs-variable">file.read</span>()</span><br>    <span class="hljs-variable"><span class="hljs-keyword">except</span></span> <span class="hljs-variable">FileNotFoundError</span> <span class="hljs-variable">as</span> <span class="hljs-variable">fnf_error</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">fnf_error</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">finally</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;这句话，无论异常是否发生都会执行。&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>Python 使用 raise 语句抛出一个指定的异常。</p><p>raise语法格式如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">raise <span class="hljs-comment">[Exception <span class="hljs-comment">[, args <span class="hljs-comment">[, traceback]</span>]</span>]</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/07/raise.png"><img src="https://www.runoob.com/wp-content/uploads/2019/07/raise.png" alt="img"></a></p><p>以下实例如果 x 大于 5 就触发异常:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">x</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> <span class="hljs-attribute">x</span> &gt; <span class="hljs-number">5</span>:<br>    raise <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;</span><span class="hljs-selector-class">.format</span>(<span class="hljs-attribute">x</span>))<br></code></pre></td></tr></table></figure><p>执行以上代码会触发异常：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Traceback (most recent <span class="hljs-keyword">call</span> last):<br>  File <span class="hljs-string">&quot;test.py&quot;</span><span class="hljs-punctuation">,</span> line <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> in &lt;<span class="hljs-keyword">module</span>&gt;<br>    raise Exception(&#x27;<span class="hljs-keyword">x</span> 不能大于 <span class="hljs-number">5</span>。<span class="hljs-keyword">x</span> 的值为: &#123;&#125;&#x27;.format(<span class="hljs-keyword">x</span>))<br>Exception: <span class="hljs-keyword">x</span> 不能大于 <span class="hljs-number">5</span>。<span class="hljs-keyword">x</span> 的值为: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p><p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">&gt;&gt;&gt; try:<br>        raise NameError(&#x27;HiThere&#x27;)<br>    except NameError:<br>        <span class="hljs-keyword">print</span>(&#x27;<span class="hljs-keyword">An</span> exception flew <span class="hljs-keyword">by</span>!&#x27;)<br>        raise<br>   <br><span class="hljs-keyword">An</span> exception flew <span class="hljs-keyword">by</span>!<br>Traceback (most recent call last):<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-keyword">line</span> 2, <span class="hljs-keyword">in</span> ?<br>NameError: HiThere<br></code></pre></td></tr></table></figure><h2 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h2><p>你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-title class_">Exception</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, value</span>):<br>            <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>            <span class="hljs-keyword">return</span> repr(<span class="hljs-variable language_">self</span>.value)<br>   <br>&gt;&gt;&gt; <span class="hljs-symbol">try:</span><br>        <span class="hljs-keyword">raise</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)<br>    except <span class="hljs-title class_">MyError</span> as <span class="hljs-symbol">e:</span><br>        print(<span class="hljs-string">&#x27;My exception occurred, value:&#x27;</span>, e.value)<br>   <br><span class="hljs-title class_">My</span> exception occurred, <span class="hljs-symbol">value:</span> <span class="hljs-number">4</span><br>&gt;&gt;&gt; <span class="hljs-keyword">raise</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-string">&#x27;oops!&#x27;</span>)<br><span class="hljs-title class_">Traceback</span> (most recent call last):<br>  <span class="hljs-title class_">File</span> <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> ?<br>__main__.<span class="hljs-title class_">MyError</span>: <span class="hljs-string">&#x27;oops!&#x27;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，类 Exception 默认的 <strong>init</strong>() 被覆盖。</p><p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        expression -- input expression in which the error occurred</span><br><span class="hljs-string">        message -- explanation of the error</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, expression, message</span>):<br>        <span class="hljs-variable language_">self</span>.expression = expression<br>        <span class="hljs-variable language_">self</span>.message = message<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransitionError</span>(<span class="hljs-title class_ inherited__">Error</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not</span><br><span class="hljs-string">    allowed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        previous -- state at beginning of transition</span><br><span class="hljs-string">        next -- attempted new state</span><br><span class="hljs-string">        message -- explanation of why the specific transition is not allowed</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, previous, <span class="hljs-built_in">next</span>, message</span>):<br>        <span class="hljs-variable language_">self</span>.previous = previous<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-variable language_">self</span>.message = message<br></code></pre></td></tr></table></figure><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p><h2 id="定义清理行为"><a href="#定义清理行为" class="headerlink" title="定义清理行为"></a>定义清理行为</h2><p>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">try</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">raise</span> KeyboardInterrupt</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-keyword">finally</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Goodbye, world!&#x27;</span>)</span><br><span class="hljs-meta prompt_">...</span><br>Goodbye, world!<br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;<br>KeyboardInterrupt<br></code></pre></td></tr></table></figure><p>以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。</p><p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，<strong>那么这个异常会在 finally 子句执行后被抛出。</strong></p><p>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; def <span class="hljs-built_in">divide</span>(x, y):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">result</span> = x / y<br>        except ZeroDivisionError:<br>            print(<span class="hljs-string">&quot;division by zero!&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;result is&quot;</span>, <span class="hljs-built_in">result</span>)<br>        <span class="hljs-keyword">finally</span>:<br>            print(<span class="hljs-string">&quot;executing finally clause&quot;</span>)<br>   <br>&gt;&gt;&gt; <span class="hljs-built_in">divide</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">result</span> is <span class="hljs-number">2.0</span><br>executing <span class="hljs-keyword">finally</span> clause<br>&gt;&gt;&gt; <span class="hljs-built_in">divide</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>division <span class="hljs-keyword">by</span> <span class="hljs-literal">zero</span>!<br>executing <span class="hljs-keyword">finally</span> clause<br>&gt;&gt;&gt; <span class="hljs-built_in">divide</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>executing <span class="hljs-keyword">finally</span> clause<br>Traceback (most recent call <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> ?<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> <span class="hljs-built_in">divide</span><br>TypeError: unsupported operand type(s) <span class="hljs-keyword">for</span> /: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="预定义的清理行为"><a href="#预定义的清理行为" class="headerlink" title="预定义的清理行为"></a>预定义的清理行为</h2><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p><p>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">for</span> <span class="hljs-keyword">line</span> in open(<span class="hljs-string">&quot;myfile.txt&quot;</span>):<br>    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">line</span>, <span class="hljs-keyword">end</span>=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p><p>关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;myfile.txt&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> f:<br>        print(<span class="hljs-built_in">line</span>, <span class="hljs-keyword">end</span>=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p><h1 id="Python3-面向对象"><a href="#Python3-面向对象" class="headerlink" title="Python3 面向对象"></a>Python3 面向对象</h1><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</p><p>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。</p><p>接下来我们先来简单的了解下面向对象的一些基本特征。</p><h2 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h2><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>**方法：**类中定义的函数。</li><li>**类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>**数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>**局部变量：**定义在方法中的变量，只作用于当前实例的类。</li><li>**实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li>**实例化：**创建一个类的实例，类的具体对象。</li><li>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p><p>对象可以包含任意数量和类型的数据</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>语法格式如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">class ClassName:<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p><h2 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h2><p>类对象支持两种操作：属性引用和实例化。</p><p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p><p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br>    i = <span class="hljs-number">12345</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-comment"># 实例化类</span><br>x = MyClass()<br> <br><span class="hljs-comment"># 访问类的属性和方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())<br></code></pre></td></tr></table></figure><p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p><p>执行以上程序输出结果为：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> 类的属性 i 为： <span class="hljs-number">12345</span><br><span class="hljs-keyword">MyClass</span> 类的方法 f 输出为： hello world<br></code></pre></td></tr></table></figure><p>类有一个名为 <strong>init</strong>() 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，像下面这样：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.data = []<br></code></pre></td></tr></table></figure><p>类定义了 <strong>init</strong>() 方法，类的实例化操作会自动调用 <strong>init</strong>() 方法。如下实例化类 MyClass，对应的 <strong>init</strong>() 方法就会被调用:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> MyClass()<br></code></pre></td></tr></table></figure><p>当然， <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。例如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Complex:<br>    <span class="hljs-attribute">def</span> __init__(self, realpart, imagpart):<br>        <span class="hljs-attribute">self</span>.r = realpart<br>        <span class="hljs-attribute">self</span>.i = imagpart<br><span class="hljs-attribute">x</span> = Complex(<span class="hljs-number">3</span>.<span class="hljs-number">0</span>, -<span class="hljs-number">4</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span>(x.r, x.i)   # 输出结果：<span class="hljs-number">3</span>.<span class="hljs-number">0</span> -<span class="hljs-number">4</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h3><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prt</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-variable language_">self</span>)<br>        print(<span class="hljs-variable language_">self</span>.__class__)<br> <br>t = <span class="hljs-title class_">Test</span>()<br>t.prt()<br></code></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">&lt;__main__.Test<span class="hljs-built_in"> instance </span>at 0x100771878&gt;<br>__main__.Test<br></code></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p><p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">class</span> <span class="hljs-variable">Test</span>:<br>    <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">prt</span>(<span class="hljs-variable">runoob</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-variable">runoob</span>)</span><br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">runoob.__class__</span>)</span><br> <br><span class="hljs-variable">t</span> = <span class="hljs-function"><span class="hljs-title">Test</span>()</span><br><span class="hljs-variable">t.prt</span>()<br></code></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">&lt;__main__.Test<span class="hljs-built_in"> instance </span>at 0x100771878&gt;<br>__main__.Test<br></code></pre></td></tr></table></figure><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">people:</span><br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,n,a,w</span>):<br>        <span class="hljs-variable language_">self</span>.name = n<br>        <span class="hljs-variable language_">self</span>.age = a<br>        <span class="hljs-variable language_">self</span>.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> <span class="hljs-string">%(self.name,self.age)</span>)<br> <br><span class="hljs-comment"># 实例化类</span><br>p = people(<span class="hljs-string">&#x27;runoob&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>)<br>p.speak()<br></code></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span> 说: 我 <span class="hljs-number">10</span> 岁。<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">class DerivedClassName(BaseClassName):<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClassName</span>(modname.BaseClassName):<br><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        <span class="hljs-variable language_">self</span>.name = n<br>        <span class="hljs-variable language_">self</span>.age = a<br>        <span class="hljs-variable language_">self</span>.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(<span class="hljs-variable language_">self</span>,n,a,w)<br>        <span class="hljs-variable language_">self</span>.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.age,<span class="hljs-variable language_">self</span>.grade))<br> <br> <br> <br>s = student(<span class="hljs-string">&#x27;ken&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>s.speak()<br></code></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ken</span> 说: 我 <span class="hljs-number">10</span> 岁了，我在读 <span class="hljs-number">3</span> 年级<br></code></pre></td></tr></table></figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-type">Base1</span>, <span class="hljs-type">Base2</span>, <span class="hljs-type">Base3</span>):</span><br><span class="hljs-class">    &lt;statement-1&gt;</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    &lt;statement-<span class="hljs-type">N</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        <span class="hljs-variable language_">self</span>.name = n<br>        <span class="hljs-variable language_">self</span>.age = a<br>        <span class="hljs-variable language_">self</span>.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(<span class="hljs-variable language_">self</span>,n,a,w)<br>        <span class="hljs-variable language_">self</span>.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.age,<span class="hljs-variable language_">self</span>.grade))<br> <br><span class="hljs-comment">#另一个类，多重继承之前的准备</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">speaker</span>():<br>    topic = <span class="hljs-string">&#x27;&#x27;</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,t</span>):<br>        <span class="hljs-variable language_">self</span>.name = n<br>        <span class="hljs-variable language_">self</span>.topic = t<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.topic))<br> <br><span class="hljs-comment">#多重继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sample</span>(speaker,student):<br>    a =<span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g,t</span>):<br>        student.__init__(<span class="hljs-variable language_">self</span>,n,a,w,g)<br>        speaker.__init__(<span class="hljs-variable language_">self</span>,n,t)<br> <br>test = sample(<span class="hljs-string">&quot;Tim&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">80</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;Python&quot;</span>)<br>test.speak()   <span class="hljs-comment">#方法名同，默认调用的是在括号中排前地父类的方法</span><br></code></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">我叫 Tim，我是一个演说家，我演讲的主题是 Python<br></code></pre></td></tr></table></figure><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>:        <span class="hljs-comment"># 定义父类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用父类方法&#x27;</span>)<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_">Parent</span>): <span class="hljs-comment"># 定义子类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用子类方法&#x27;</span>)<br> <br>c = <span class="hljs-title class_">Child</span>()          <span class="hljs-comment"># 子类实例</span><br>c.myMethod()         <span class="hljs-comment"># 子类调用重写方法</span><br><span class="hljs-variable language_">super</span>(<span class="hljs-title class_">Child</span>,c).myMethod() <span class="hljs-comment">#用子类对象调用父类已被覆盖的方法</span><br></code></pre></td></tr></table></figure><p>super() 函数是用于调用父类(超类)的一个方法。</p><p>执行以上程序输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">调用子类方法<br>调用父类方法<br></code></pre></td></tr></table></figure><h2 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h2><h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><h3 id="类的方法-1"><a href="#类的方法-1" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p><h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>类的私有属性实例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JustCounter</span>:<br>    __secret<span class="hljs-title class_ inherited__">Count</span> = 0  # 私有变量<br>    <span class="hljs-keyword">public</span><span class="hljs-title class_ inherited__">Count</span> = 0    # 公开变量<br> <br>    def count(<span class="hljs-keyword">self</span>):<br>        <span class="hljs-keyword">self</span>.__secret<span class="hljs-title class_ inherited__">Count</span> += 1<br>        <span class="hljs-keyword">self</span>.public<span class="hljs-title class_ inherited__">Count</span> += 1<br>        print (<span class="hljs-keyword">self</span>.__secret<span class="hljs-title class_ inherited__">Count</span>)<br> <br>counter = <span class="hljs-title class_ inherited__">JustCounter</span>()<br>counter.count()<br>counter.count()<br>print (counter.public<span class="hljs-title class_ inherited__">Count</span>)<br>print (counter.__secret<span class="hljs-title class_ inherited__">Count</span>)  # 报错，实例不能访问私有变量<br></code></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">16</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    <span class="hljs-keyword">print</span> (counter.__secretCount)  # 报错，实例不能访问私有变量<br>AttributeError: <span class="hljs-string">&#x27;JustCounter&#x27;</span> object <span class="hljs-built_in">has</span> <span class="hljs-keyword">no</span> attribute <span class="hljs-string">&#x27;__secretCount&#x27;</span><br></code></pre></td></tr></table></figure><p>类的私有方法实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Site</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, url</span>):<br>        <span class="hljs-variable language_">self</span>.name = name       <span class="hljs-comment"># public</span><br>        <span class="hljs-variable language_">self</span>.__url = url   <span class="hljs-comment"># private</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name  : &#x27;</span>, <span class="hljs-variable language_">self</span>.name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;url : &#x27;</span>, <span class="hljs-variable language_">self</span>.__url)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__foo</span>(<span class="hljs-params">self</span>):          <span class="hljs-comment"># 私有方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是私有方法&#x27;</span>)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):            <span class="hljs-comment"># 公共方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是公共方法&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.__foo()<br> <br>x = Site(<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>)<br>x.who()        <span class="hljs-comment"># 正常输出</span><br>x.foo()        <span class="hljs-comment"># 正常输出</span><br>x.__foo()      <span class="hljs-comment"># 报错</span><br></code></pre></td></tr></table></figure><h3 id="类的专有方法-所有方法名左右都有两条横线-："><a href="#类的专有方法-所有方法名左右都有两条横线-：" class="headerlink" title="类的专有方法(所有方法名左右都有两条横线)："></a>类的专有方法(所有方法名左右都有两条横线)：</h3><ul><li><strong><em>*init*</em> :</strong> 构造函数，在生成对象时调用</li><li><strong><em>*del*</em> :</strong> 析构函数，释放对象时使用</li><li><strong><em>*repr*</em> :</strong> 打印，转换</li><li><strong><em>*setitem*</em> :</strong> 按照索引赋值</li><li><strong><em>*getitem*</em>:</strong> 按照索引获取值</li><li><strong><em>*len*</em>:</strong> 获得长度</li><li><strong><em>*cmp*</em>:</strong> 比较运算</li><li><strong><em>*call*</em>:</strong> 函数调用</li><li><strong><em>*add*</em>:</strong> 加运算</li><li><strong><em>*sub*</em>:</strong> 减运算</li><li><strong>mul</strong>：乘运算</li><li><strong><em>*truediv*</em>:</strong> 除运算</li><li><strong><em>*mod*</em>:</strong> 求余运算</li><li><strong><em>*pow*</em>:</strong> 乘方</li></ul><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, a, b</span>):<br>      <span class="hljs-variable language_">self</span>.a = a<br>      <span class="hljs-variable language_">self</span>.b = b<br> <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector (%d, %d)&#x27;</span> % (<span class="hljs-variable language_">self</span>.a, <span class="hljs-variable language_">self</span>.b)<br>   <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,other</span>):<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-variable language_">self</span>.a + other.a, <span class="hljs-variable language_">self</span>.b + other.b)<br> <br>v1 = <span class="hljs-title class_">Vector</span>(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>)<br>v2 = <span class="hljs-title class_">Vector</span>(<span class="hljs-number">5</span>,-<span class="hljs-number">2</span>)<br>print (v1 + v2)<br></code></pre></td></tr></table></figure><p>以上代码执行结果如下所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)</span></span><br></code></pre></td></tr></table></figure><h1 id="Python3-命名空间和作用域"><a href="#Python3-命名空间和作用域" class="headerlink" title="Python3 命名空间和作用域"></a>Python3 命名空间和作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>先看看官方文档的一段话：</p><p><em>A namespace is a mapping from names to objects.Most namespaces are currently implemented as Python dictionaries。</em></p><p>命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><p>我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/09/0129A8E9-30FE-431D-8C48-399EA4841E9D.jpg"><img src="https://www.runoob.com/wp-content/uploads/2019/09/0129A8E9-30FE-431D-8C48-399EA4841E9D.jpg" alt="img"></a></p><p>一般有三种命名空间：</p><ul><li><strong>内置名称（built-in names</strong>）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/types_namespace-1.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/types_namespace-1.png" alt="img"></a></p><p>命名空间查找顺序:</p><p>假设我们要使用变量 runoob，则 Python 的查找顺序为：<strong>局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p><p>如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">NameError:<span class="hljs-built_in"> name</span> <span class="hljs-string">&#x27;runoob&#x27;</span> <span class="hljs-literal">is</span><span class="hljs-built_in"> not</span> defined。<br></code></pre></td></tr></table></figure><p>命名空间的生命周期：</p><p>命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p><p>因此，我们无法从外部命名空间访问内部命名空间的对象。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># var1 是全局名称</span><br>var1 = <span class="hljs-number">5</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">some_func</span>():<br> <br>    <span class="hljs-comment"># var2 是局部名称</span><br>    var2 = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">some_inner_func</span>():<br> <br>        <span class="hljs-comment"># var3 是内嵌的局部名称</span><br>        var3 = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>如下图所示，相同的对象名称可以存在于多个命名空间中。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/namespaces.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/namespaces.png" alt="img"></a></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><em>A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace.</em></p><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><p>在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</p><p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：</p><p>有四种作用域：</p><ul><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数&#x2F;方法内部。</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li><li><strong>B（Built-in）</strong>： 包含了内建的变量&#x2F;关键字等。，最后被搜索</li></ul><p>规则顺序： <strong>L –&gt; E –&gt; G –&gt;gt; B</strong>。</p><p>在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/05/1418490-20180906153626089-1835444372.png"><img src="https://www.runoob.com/wp-content/uploads/2014/05/1418490-20180906153626089-1835444372.png" alt="img"></a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">g_count = <span class="hljs-number">0</span>  <span class="hljs-meta"># 全局作用域</span><br><span class="hljs-function">def <span class="hljs-title">outer</span>():</span><br><span class="hljs-function">    o_count</span> = <span class="hljs-number">1</span>  <span class="hljs-meta"># 闭包函数外的函数中</span><br>    <span class="hljs-function">def <span class="hljs-title">inner</span>():</span><br><span class="hljs-function">        i_count</span> = <span class="hljs-number">2</span>  <span class="hljs-meta"># 局部作用域</span><br></code></pre></td></tr></table></figure><p>内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> builtins</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">dir</span>(builtins)</span><br>#查看预定义了什么变量<br></code></pre></td></tr></table></figure><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if&#x2F;elif&#x2F;else&#x2F;、try&#x2F;except、for&#x2F;while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"> msg = <span class="hljs-string">&#x27;I am from Runoob&#x27;</span></span><br><span class="hljs-meta prompt_">...</span> <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">msg</span><br>&#x27;I am from Runoob&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <br></code></pre></td></tr></table></figure><p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。</p><p>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    msg_inner = <span class="hljs-string">&#x27;I am from Runoob&#x27;</span></span><br><span class="hljs-meta prompt_">...</span> <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">msg_inner</span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>NameError: name &#x27;msg_inner&#x27; is not defined<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <br></code></pre></td></tr></table></figure><p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">total</span> = 0 # 这是一个全局变量<br># 可写函数说明<br>def <span class="hljs-built_in">sum</span>( arg1, arg2 ):<br>    #返回2个参数的和.&quot;<br>    <span class="hljs-keyword">total</span> = arg1 + arg2 # <span class="hljs-keyword">total</span>在这里是局部变量.<br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;函数内是局部变量 : &quot;</span>, <span class="hljs-keyword">total</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">total</span><br> <br>#调用<span class="hljs-keyword">sum</span>函数<br><span class="hljs-built_in">sum</span>( 10, 20 )<br><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;函数外是全局变量 : &quot;</span>, <span class="hljs-keyword">total</span>)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">函数内是局部变量 :  30<br>函数外是全局变量 :  0<br></code></pre></td></tr></table></figure><h3 id="global-和-nonlocal关键字"><a href="#global-和-nonlocal关键字" class="headerlink" title="global 和 nonlocal关键字"></a>global 和 nonlocal关键字</h3><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。</p><p>以下实例修改全局变量 num：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br>def fun1():<br>    global <span class="hljs-built_in">num</span>  # 需要使用 global 关键字声明<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>) <br>    <span class="hljs-built_in">num</span> = <span class="hljs-number">123</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>)<br>fun1()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>)<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>123<br>123<br></code></pre></td></tr></table></figure><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():<br>    num = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-keyword">nonlocal</span> num   <span class="hljs-comment"># nonlocal关键字声明</span><br>        num = <span class="hljs-number">100</span><br>        <span class="hljs-built_in">print</span>(num)<br>    inner()<br>    <span class="hljs-built_in">print</span>(num)<br>outer()<br></code></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">100<br>100<br></code></pre></td></tr></table></figure><p>另外有一种特殊情况，假设下面这段代码被运行：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">a</span> = <span class="hljs-number">10</span><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">test</span>():</span><br><span class="hljs-function">    <span class="hljs-variable">a</span> = <span class="hljs-variable">a</span> + <span class="hljs-number">1</span></span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">a</span>)</span><br><span class="hljs-function"><span class="hljs-title">test</span>()</span><br></code></pre></td></tr></table></figure><p>以上程序执行，报错信息如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Traceback (most recent call <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    test()<br>  File <span class="hljs-string">&quot;test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">5</span>, <span class="hljs-keyword">in</span> test<br>    <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span> + <span class="hljs-number">1</span><br>UnboundLocalError: <span class="hljs-built_in">local</span> <span class="hljs-built_in">variable</span> <span class="hljs-string">&#x27;a&#x27;</span> referenced <span class="hljs-keyword">before</span> assignment<br></code></pre></td></tr></table></figure><p>错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。</p><p>修改 a 为全局变量：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span> = <span class="hljs-number">10</span><br>def test():<br>    <span class="hljs-built_in">global</span> <span class="hljs-keyword">a</span><br>    <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span> + <span class="hljs-number">1</span><br>    print(<span class="hljs-keyword">a</span>)<br>test()<br></code></pre></td></tr></table></figure><p>执行输出结果为：</p><p>11</p><p>也可以通过函数参数传递：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span> = <span class="hljs-number">10</span><br>def test(<span class="hljs-keyword">a</span>):<br>    <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span> + <span class="hljs-number">1</span><br>    print(<span class="hljs-keyword">a</span>)<br>test(<span class="hljs-keyword">a</span>)<br></code></pre></td></tr></table></figure><h1 id="Python3-标准库概览"><a href="#Python3-标准库概览" class="headerlink" title="Python3 标准库概览"></a>Python3 标准库概览</h1><h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><p>os模块提供了不少与操作系统相关联的函数。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> os</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">os.getcwd()      <span class="hljs-comment"># 返回当前的工作目录</span></span><br>&#x27;C:\\Python34&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">os.chdir(<span class="hljs-string">&#x27;/server/accesslogs&#x27;</span>)   <span class="hljs-comment"># 修改当前的工作目录</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">os.system(<span class="hljs-string">&#x27;mkdir today&#x27;</span>)   <span class="hljs-comment"># 执行系统命令 mkdir </span></span><br>0<br></code></pre></td></tr></table></figure><p>建议使用 “import os” 风格而非 “from os import *”。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。</p><p>在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> os</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">dir</span>(os)</span><br>&lt;returns a list of all module functions&gt;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>(os)</span><br>&lt;returns an extensive manual page created from the module&#x27;s docstrings&gt;<br></code></pre></td></tr></table></figure><p>针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> shutil</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">shutil.copyfile(<span class="hljs-string">&#x27;data.db&#x27;</span>, <span class="hljs-string">&#x27;archive.db&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">shutil.move(<span class="hljs-string">&#x27;/build/executables&#x27;</span>, <span class="hljs-string">&#x27;installdir&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="文件通配符"><a href="#文件通配符" class="headerlink" title="文件通配符"></a>文件通配符</h2><p>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> glob<br><span class="hljs-meta">&gt;&gt;&gt; </span>glob.glob(<span class="hljs-string">&#x27;*.py&#x27;</span>)<br>[<span class="hljs-string">&#x27;primes.py&#x27;</span>, <span class="hljs-string">&#x27;random.py&#x27;</span>, <span class="hljs-string">&#x27;quote.py&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="命令行参数-1"><a href="#命令行参数-1" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 “python demo.py one two three” 后可以得到以下输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(sys.argv)<br>[<span class="hljs-string">&#x27;demo.py&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="错误输出重定向和程序终止"><a href="#错误输出重定向和程序终止" class="headerlink" title="错误输出重定向和程序终止"></a>错误输出重定向和程序终止</h2><p>sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; sys.<span class="hljs-keyword">stderr</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;Warning, log file not found starting a new one\n&#x27;</span>)<br>Warning, <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">not</span> found starting <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><p>大多脚本的定向终止都使用 “sys.exit()”。</p><h2 id="字符串正则匹配"><a href="#字符串正则匹配" class="headerlink" title="字符串正则匹配"></a>字符串正则匹配</h2><p>re模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.findall(<span class="hljs-string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="hljs-string">&#x27;which foot or hand fell fastest&#x27;</span>)<br>[<span class="hljs-string">&#x27;foot&#x27;</span>, <span class="hljs-string">&#x27;fell&#x27;</span>, <span class="hljs-string">&#x27;fastest&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.sub(<span class="hljs-string">r&#x27;(\b[a-z]+) \1&#x27;</span>, <span class="hljs-string">r&#x27;\1&#x27;</span>, <span class="hljs-string">&#x27;cat in the the hat&#x27;</span>)<br><span class="hljs-string">&#x27;cat in the hat&#x27;</span><br></code></pre></td></tr></table></figure><p>如果只需要简单的功能，应该首先考虑字符串方法，因为它们非常简单，易于阅读和调试:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">&gt;&gt;&gt; <span class="hljs-symbol">&#x27;tea</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">too</span><span class="hljs-string">&#x27;.replace(&#x27;</span>too<span class="hljs-string">&#x27;, &#x27;</span>two<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">&#x27;</span>tea <span class="hljs-keyword">for</span> <span class="hljs-title class_">two</span><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>math模块为浮点运算提供了对底层C函数库的访问:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;&gt;&gt; import <span class="hljs-built_in">math</span><br>&gt;&gt;&gt; <span class="hljs-built_in">math</span>.<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">pi</span> / <span class="hljs-number">4</span>)<br><span class="hljs-number">0.70710678118654757</span><br>&gt;&gt;&gt; <span class="hljs-built_in">math</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">10.0</span><br></code></pre></td></tr></table></figure><p>random提供了生成随机数的工具。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> random</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">random.choice([<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>])</span><br>&#x27;apple&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">random.sample(<span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>), <span class="hljs-number">10</span>)   <span class="hljs-comment"># sampling without replacement</span></span><br>[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">random.random()    <span class="hljs-comment"># random float</span></span><br>0.17970987693706186<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">random.randrange(<span class="hljs-number">6</span>)    <span class="hljs-comment"># random integer chosen from range(6)</span></span><br>4<br></code></pre></td></tr></table></figure><h2 id="访问-互联网"><a href="#访问-互联网" class="headerlink" title="访问 互联网"></a>访问 互联网</h2><p>有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib.request 以及用于发送电子邮件的 smtplib:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> urlopen(<span class="hljs-string">&#x27;http://tycho.usno.navy.mil/cgi-bin/timer.pl&#x27;</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    line = line.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># Decoding the binary data to text.</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;EST&#x27;</span> <span class="hljs-keyword">in</span> line <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;EDT&#x27;</span> <span class="hljs-keyword">in</span> line:  <span class="hljs-comment"># look for Eastern Time</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        <span class="hljs-built_in">print</span>(line)</span><br><br>&lt;BR&gt;Nov. 25, 09:43:32 PM EST<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> smtplib</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">server = smtplib.SMTP(<span class="hljs-string">&#x27;localhost&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">server.sendmail(<span class="hljs-string">&#x27;soothsayer@example.org&#x27;</span>, <span class="hljs-string">&#x27;jcaesar@example.org&#x27;</span>,</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">&quot;&quot;&quot;To: jcaesar@example.org</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">From: soothsayer@example.org</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">Beware the Ides of March.</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">&quot;&quot;&quot;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">server.quit()</span><br></code></pre></td></tr></table></figure><p>注意第二个例子需要本地有一个在运行的邮件服务器。</p><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>datetime模块为日期和时间处理同时提供了简单和复杂的方法。</p><p>支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。</p><p>该模块还支持时区处理:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># dates are easily constructed and formatted</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">now = date.today()</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">now</span><br>datetime.date(2003, 12, 2)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">now.strftime(<span class="hljs-string">&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;</span>)</span><br>&#x27;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&#x27;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># dates support calendar arithmetic</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">birthday = date(<span class="hljs-number">1964</span>, <span class="hljs-number">7</span>, <span class="hljs-number">31</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">age = now - birthday</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">age.days</span><br>14368<br></code></pre></td></tr></table></figure><h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> zlib</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">b&#x27;witch which has which witches wrist watch&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(s)</span><br>41<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t = zlib.compress(s)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(t)</span><br>37<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">zlib.decompress(t)</span><br>b&#x27;witch which has which witches wrist watch&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">zlib.crc32(s)</span><br>226805979<br></code></pre></td></tr></table></figure><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。</p><p>例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> timeit <span class="hljs-keyword">import</span> Timer</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Timer(<span class="hljs-string">&#x27;t=a; a=b; b=t&#x27;</span>, <span class="hljs-string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br>0.57535828626024577<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Timer(<span class="hljs-string">&#x27;a,b = b,a&#x27;</span>, <span class="hljs-string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br>0.54962537085770791<br></code></pre></td></tr></table></figure><p>相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。</p><h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><p>开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试</p><p>doctest模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。</p><p>测试构造如同简单的<strong>将它的输出结果剪切并粘贴到文档字符串中</strong>。</p><p>通过用户提供的例子，它强化了文档，允许 doctest 模块确认代码的结果是否与文档一致:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">values</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; print(average([20, 30, 70]))</span><br><span class="hljs-string">    40.0</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(values) / <span class="hljs-built_in">len</span>(values)<br><br><span class="hljs-keyword">import</span> doctest<br>doctest.testmod()   <span class="hljs-comment"># 自动验证嵌入测试</span><br></code></pre></td></tr></table></figure><p>unittest模块不像 doctest模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">TestStatisticalFunctions</span>(<span class="hljs-title">unittest</span>.<span class="hljs-type">TestCase</span>):</span><br><span class="hljs-class"></span><br><span class="hljs-class">    def test_average(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        self.assertEqual(<span class="hljs-title">average</span>([20, 30, 70]), 40.0)</span><br><span class="hljs-class">        self.assertEqual(<span class="hljs-title">round</span>(<span class="hljs-title">average</span>([1, 5, 7]), 1), 4.3)</span><br><span class="hljs-class">        self.assertRaises(<span class="hljs-type">ZeroDivisionError</span>, <span class="hljs-title">average</span>, [])</span><br><span class="hljs-class">        self.assertRaises(<span class="hljs-type">TypeError</span>, <span class="hljs-title">average</span>, 20, 30, 70)</span><br><span class="hljs-class"></span><br><span class="hljs-class">unittest.main() # <span class="hljs-type">Calling</span> from the command line invokes all tests</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Java中的反射和动态代理</title>
    <link href="/2021/03/24/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2021/03/24/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="java的编译期和运行期"><a href="#java的编译期和运行期" class="headerlink" title="java的编译期和运行期"></a>java的编译期和运行期</h4><p>参考博文：</p><p><a href="https://blog.csdn.net/zl1zl2zl3/article/details/107425987">https://blog.csdn.net/zl1zl2zl3/article/details/107425987</a></p><p>首先我觉得应该了解一下java中的编译期和运行期的概念。</p><p>一张图片：</p><p><a href="https://imgtu.com/i/6XCjbV"><img src="https://z3.ax1x.com/2021/03/25/6XCjbV.png" alt="6XCjbV.png"></a></p><ol><li>一个.java文件完成运行需要经过哪些步骤？</li></ol><p>（1）Java源码–&gt;java字节码</p><p>（2）加载java字节码并运行</p><ol><li>编译期间做些什么？</li></ol><p>编译器的作用：源代码（原始语言）–&gt; 目标语言</p><p>（1）解析与填充符号表：通过词法语法分析，填充符号表。</p><p>（2）注解处理器：当我们处理注解时，如果修改了语法树的话，会重新执行分析以及符号填充过程，把注解也填充进来，直到处理完所有的注解。</p><p>（3）语义分析：编译器获得语法树之后，无法确定源程序是符合逻辑的。</p><p>（4）解语法糖：虚拟机不支持java中的语法糖，他们在编译阶段就被还原成了简单的基础语法结构。</p><p>（5）字节码生成：主要工作就是把语法树和符号表加工成字节码文件。</p><ol><li>运行期间做些什么？</li></ol><p>java运行期间主要是处理编译器产生的字节码，包括加载与执行。</p><ol><li><p>java程序是如何运行的？</p><p>首先需要把源代码（高级语言）编译成虚拟机可执行的语言（字节码），其次，需要把字节码解释运行后编译成操作系统级别的机器语言，用于执行函数调用。</p><p>另外，java语言是平台独立的，但是虚拟机不是。每个操作系统都要下载对应的虚拟机，主要是由于它最终调用的函数库以及线程模型不同。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li></ol><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>反射是一种<strong>间接操纵目标对象</strong>机制。前提是java程序<strong>在运行状态中</strong>，对于<strong>任意</strong>一个类，都能知道这个类的<strong>所有属性和方法</strong>；对于<strong>任意</strong>一个对象，都能够调用它的<strong>任意</strong>一个方法。</p><p>反射就是把java类中的各种成分<strong>映射</strong>成相应的java类，然后进行调用。</p><h4 id="反射原理是什么？"><a href="#反射原理是什么？" class="headerlink" title="反射原理是什么？"></a>反射原理是什么？</h4><p>在JVM（java虚拟机，通过jvm，获得字节码，java语言在不同平台运行时不需要重新编译。）运行时才会动态的加载类，但是我们有时候在编译期不知道运行的对象是谁，编译成.class文件之后。通过反射，运行中的java程序也可以获取类的信息，并且可以操作类或对象的内部属性，它是在运行时根据需要才加载。</p><p><em>java反射就是当程序运行时，在内存中获得.class对象之后，反向获取该class对象的类的属性和方法等各种信息</em>。</p><p>从面向对象的角度来看，我们平时用到的“类”，“构造器”，“属性”，“方法”其实也是一个“类”，它们在jdk中分别对应Class、Constructor、Field、Method类。其中Class相当于“类的类”，可称为“元类”，从这个角度看，我们平时自定义的“类”可以理解为Class的一个对象。</p><h4 id="反射有哪些好处？"><a href="#反射有哪些好处？" class="headerlink" title="反射有哪些好处？"></a>反射有哪些好处？</h4><p>反射允许静态语言在运行时检查、修改程序的结构和行为。在静态语言中，使用一个变量，必须知道它的类型。换句话说就是，程序在运行时的行为都是固定的。如果想在运行时改变，就需要反射来解决。</p><p>“无反射，不框架；无代理，不框架”。反射是框架设计的灵魂。</p><p>反射广泛应用于那些需要在运行时检测或修改程序行为的程序中。</p><p>当我们想要输入一个对象和类，并想调用它的属性和方法时，一按点号，编译器就会自动列出它的属性和方法。这里用到的就是反射。</p><h4 id="反射怎么用？"><a href="#反射怎么用？" class="headerlink" title="反射怎么用？"></a>反射怎么用？</h4><p><strong>功能</strong>：</p><ol><li><p>在<strong>运行</strong>时判断<strong>任意</strong>一个对象所属的类。</p></li><li><p>在运行时构造任意一个类的对象。</p></li><li><p>在运行时判断任意一个类所具有的成员变量和方法。</p></li><li><p>在运行时调用任意一个对象的方法。</p></li><li><p>生成<strong>动态代理</strong>。</p><p><strong>获取Class的三种方法：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Student stu1 <span class="hljs-operator">=</span> new Student()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>（1）Object –&gt; getClass</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Class stuClass <span class="hljs-operator">=</span> stu1.getClass()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>（2）任何数据类型（包括基本的数据类型）都有一个”静态“的class属性。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">Class</span> stuClass2 = Student.<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>（3）通过class类的静态方法：forName（String className）</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">Class</span> stuClass3 = <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;Stu.Student&quot;</span>)<span class="hljs-comment">//此路径是真实地路径</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在运行期间，一个类只有一个Class对象产生。</p><p><strong>通过反射获取构造方法并使用：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Class clazz <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Stu.Student&quot;</span>)<span class="hljs-comment">;</span><br>Constructor[] conArray <span class="hljs-operator">=</span> clazz.getConstructors()<span class="hljs-comment">;</span><br>//所有公有地构造方法。<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">conArray</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructors()<span class="hljs-comment">;</span><br>//所有的构造方法。<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">con</span> = <span class="hljs-title">clazz</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">(null)</span>;</span><br><span class="hljs-comment">//获取公有并且无参的构造方法。</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">con</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(char.class)<span class="hljs-comment">;</span><br>//获取私有的构造方法，并调用。<br></code></pre></td></tr></table></figure><p><strong>获取成员变量并调用：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Field[] fieldArray <span class="hljs-operator">=</span> stuClass.getFields()<span class="hljs-comment">;</span><br>//获取所有公有地字段<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">fieldArray</span> <span class="hljs-operator">=</span> stuClass.getDeclaredFields()<span class="hljs-comment">;</span><br>//获取所有的字段<br>Field f <span class="hljs-operator">=</span> stuClass.getField(<span class="hljs-string">&quot;name&quot;</span>)<br>    //获取公有字段并调用<br><span class="hljs-attribute">f</span> <span class="hljs-operator">=</span> stuClass.getDeclaredField(<span class="hljs-string">&quot;phoneNum&quot;</span>)<br>    //获取私有字段并调用<br></code></pre></td></tr></table></figure><p><strong>获取成员方法并调用：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Method[] methodArray = stuClass.<span class="hljs-built_in">getMethods</span>();<br><span class="hljs-comment">//获取所有公有地方法</span><br>methodArray = stuClass.<span class="hljs-built_in">getDeclaredMethods</span>();<br><span class="hljs-comment">//获取所有的方法，包括私有的</span><br>Method m = stuClass.<span class="hljs-built_in">getMethod</span>(<span class="hljs-string">&quot;show1&quot;</span>,<span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);<br><span class="hljs-comment">//获取公有的show1()方法</span><br>m = stuClass.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">&quot;show4&quot;</span>,<span class="hljs-type">int</span>.<span class="hljs-keyword">class</span>);<br><span class="hljs-comment">//获取私有的show4()方法</span><br></code></pre></td></tr></table></figure><p><strong>反射main方法：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Class</span> clazz = <span class="hljs-keyword">Class</span>.forName(&quot;fanshe.main.Student&quot;);<br><span class="hljs-keyword">Method</span> methodMain = clazz.getMethod(&quot;main&quot;,String[].<span class="hljs-keyword">class</span>);<br>methodMain.invoke(<span class="hljs-keyword">null</span>,(<span class="hljs-keyword">object</span>)<span class="hljs-built_in">new</span> String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;)<br></code></pre></td></tr></table></figure><p><strong>反射方法的其他使用之—通过反射运行配置文件内容</strong>：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">getValue</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>) <span class="hljs-keyword">throws</span> IOException&#123;<br>    Properties pro = <span class="hljs-keyword">new </span><span class="hljs-class title_">Properties</span>();<br>    FileReader in = <span class="hljs-keyword">new </span><span class="hljs-class title_">FileReader</span>(<span class="hljs-string">&quot;pro.txt&quot;</span>);<br>    pro.<span class="hljs-property">load</span>(in);<br>    in.<span class="hljs-property">close</span>();<br>    <span class="hljs-keyword">return</span> pro.<span class="hljs-property">getProperty</span>(<span class="hljs-built_in">key</span>);<br>&#125;<span class="hljs-comment">//此方法接收一个key，在配置文件中获取相应的value</span><br></code></pre></td></tr></table></figure><p><strong>反射方法的其他使用之—通过反射越过泛型检查：</strong></p><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的。</p><h4 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h4><p><a href="https://imgtu.com/i/6OH7Lj"><img src="https://z3.ax1x.com/2021/03/25/6OH7Lj.png" alt="6OH7Lj.png"></a></p><p>使用代理的目的是：对目标对象（的方法）进行功能增强。</p><p>既然是对目标对象的方法进行增强，代理对象的方法中一定会调用目标对象的方法。而且一般会在目标对象的方法<strong>调用前后（或者其他时机）做一些其他的处理</strong>以达到增强的效果。</p><h4 id="什么是静态代理？"><a href="#什么是静态代理？" class="headerlink" title="什么是静态代理？"></a>什么是静态代理？</h4><p>代理类和实现类实现<strong>同一个接口</strong>，代理类里面有一个实现类的<strong>引用</strong>，客户调用代理类的方法时，代理类就调用实现类的方法。称为静态，是因为<strong>代理类和实现类是写死的</strong>，就是在编译阶段就确定了。</p><p>静态方法可以在代理类调用实现类的方法<strong>前后加上一些代码</strong>；在构造方法中也可以<strong>通过网络加载器</strong>加载到别的机器上的类，这样本地调用时，感觉不到远程机器，就像调用本地代码一样。</p><h4 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h4><p>如果有很多类需要代理，就要写很多的代理类，就比较麻烦。</p><h4 id="动态代理的本质是什么？"><a href="#动态代理的本质是什么？" class="headerlink" title="动态代理的本质是什么？"></a>动态代理的本质是什么？</h4><p>动态代理的本质就是用户提供类名、方法名、参数、代理类执行方法，返回结果。用类加载器可以将类加载到虚拟机，用Class clazz表示，有这个对象，就可以执行它的方法。（这就是反射）</p><h4 id="动态代理的使用？"><a href="#动态代理的使用？" class="headerlink" title="动态代理的使用？"></a>动态代理的使用？</h4><p>Proxy实现类是由Proxy的static方法在执行时刻生成的，这个类和被代理类有相同的接口，并且它的构造函数的参数是InvocationHandler。因为这个类是在运行时刻生成的，可以根据传入不同的参数，生成不同的代理类，所以是动态代理。</p><p>动态代理类不是由程序员写的，而是根据传入的参数，由Proxy类在运行时生成的，所以可以传入不同的参数，这样就可以在运行时产生不同的代理类，所以是动态的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Foo f = (Foo)Proxy.newProxyInstance(Foo.<span class="hljs-keyword">class</span>.getClassLoader(), <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>&lt;?&gt;[]&#123;Foo.<span class="hljs-keyword">class</span>&#125;, <span class="hljs-keyword">handler</span>);<br></code></pre></td></tr></table></figure><h4 id="动态代理的内涵？"><a href="#动态代理的内涵？" class="headerlink" title="动态代理的内涵？"></a>动态代理的内涵？</h4><p>java动态代理类位于Java.lang.reflect包下，一般涉及到以下的两个类：</p><p>（1）Interface InvocationHandler：该接口中仅定义了一个方法Object:invoke(Object obj，Method method，Object[] args）。在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，args为该方法的参数数组。这个抽象方法在代理类中动态实现。</p><p>（2）Proxy：该类即为动态代理类，主要包含以下内容：Protected Proxy（InvocationHandler h）：构造函数，用于给内部的h赋值。</p><p>Static Class getProxyClass（ClassLoader loader，Class[] interfaces）：获得一个代理类，其中loader是类装载器，interface是真实类所拥有的全部接口的数组。</p><p>Static Object newProxyInstance（ClassLoader loader，Class[] interface， InvocationHandler h）：返回代理类的一个实例，返回后的代理类可以当作被代理类使用（可使用被代理类的在Subject接口中声明过的方法）。</p><h4 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h4><p><a href="https://blog.csdn.net/yangwu007/article/details/109116421">https://blog.csdn.net/yangwu007/article/details/109116421</a></p><p><a href="https://blog.csdn.net/ju_362204801/article/details/90578678">https://blog.csdn.net/ju_362204801/article/details/90578678</a></p><p><a href="https://fxnfk.blog.csdn.net/article/details/78905997">https://fxnfk.blog.csdn.net/article/details/78905997</a></p><p><a href="https://blog.csdn.net/he90227/article/details/39155613">https://blog.csdn.net/he90227/article/details/39155613</a></p><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">https://blog.csdn.net/sinat_38259539/article/details/71799078</a></p><p><a href="https://blog.csdn.net/he90227/article/details/39155613">https://blog.csdn.net/he90227/article/details/39155613</a></p><p><a href="https://cloud.tencent.com/developer/article/1561114">https://cloud.tencent.com/developer/article/1561114</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的map详解</title>
    <link href="/2021/03/17/Java%E4%B8%AD%E7%9A%84map%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/17/Java%E4%B8%AD%E7%9A%84map%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>先看一张图片：</strong></p><p><a href="https://imgtu.com/i/66tBHe"><img src="https://s3.ax1x.com/2021/03/17/66tBHe.png" alt="66tBHe.png"></a></p><p><em>关于Collection和map关系</em>：<a href="https://www.cnblogs.com/111testing/p/8100148.html">https://www.cnblogs.com/111testing/p/8100148.html</a></p><h1 id="问题汇总："><a href="#问题汇总：" class="headerlink" title="问题汇总："></a>问题汇总：</h1><h4 id="1-Java中的map到底是什么？运行机制或者基本原理是什么？"><a href="#1-Java中的map到底是什么？运行机制或者基本原理是什么？" class="headerlink" title="1. Java中的map到底是什么？运行机制或者基本原理是什么？"></a><strong>1. Java中的map到底是什么？运行机制或者基本原理是什么？</strong></h4><p>java.util中包含Collection和Map接口，然后产生了Map类的集合。可以把它理解成一个数据字典，然后可以给每个数据对象制定代号。下次可以直接根据代号找到数据，而不用像数组、列表那样要从头到尾查找一遍。</p><h4 id="2-什么是Collection？"><a href="#2-什么是Collection？" class="headerlink" title="2. 什么是Collection？"></a><strong>2. 什么是Collection？</strong></h4><p>Collection集合和Map集合一样，由接口产生类，但是是单列集合体系，包含List和Set。其中List是有序的单列集合接口，存入的数据可以重复且有序，Set是无序的单列接口，存入数据不可重复。</p><p><em>关于Collection</em>：<a href="https://blog.csdn.net/qq_41635282/article/details/112116998">https://blog.csdn.net/qq_41635282/article/details/112116998</a></p><h4 id="3-什么是Set"><a href="#3-什么是Set" class="headerlink" title="3. 什么是Set?"></a><strong>3. 什么是Set?</strong></h4><p>是接口，也是一种Set集合，类似于一个罐子，程序可以一次把多个对象“丢进”Set集合，而Set集合通常不能记住元素的添加顺序。实际上Set就是Collection只是Set不允许包含重复元素。</p><p>*关于Set集合的实例：*<a href="https://blog.csdn.net/mashaokang1314/article/details/83721792">https://blog.csdn.net/mashaokang1314/article/details/83721792</a></p><p>*关于Set集合HashSet、LinkedHashSet、TreeSet的源码分析：*<a href="https://blog.csdn.net/xiaoxiaovbb/article/details/80439643">https://blog.csdn.net/xiaoxiaovbb/article/details/80439643</a></p><h4 id="4-什么是java中的迭代器？"><a href="#4-什么是java中的迭代器？" class="headerlink" title="4. 什么是java中的迭代器？"></a><strong>4. 什么是java中的迭代器</strong>？</h4><p>集合体系中的迭代器就是遍历，集合取出元素的方式，迭代器可以取出并操作集合中的元素。</p><p>特点：每个集合都有存和取的方式，而且每个集合的数据结构不一样，所以他们存和取的动作也不一样，添加通过add（）能完成添加操作，但是取的动作比较复杂，所以把取的动作封装成了对象，包含hasNext（）、next（）、remove（）三个共同的方法，由于集合本身最知道该怎么取元素和迭代器对象需要用到集合内部的元素，所以把迭代器封装成了集合类的内部类，通过一个方法把迭代器提供给外部，就是iterator（）。</p><h4 id="5-Java中的Iterator（）方法是什么？"><a href="#5-Java中的Iterator（）方法是什么？" class="headerlink" title="5. Java中的Iterator（）方法是什么？"></a><strong>5. Java中的Iterator（）方法是什么？</strong></h4><p>iterator就是java中的迭代器，迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象。</p><p>*iterator迭代器的实现及相关实例：*<a href="https://www.cnblogs.com/xujian2014/p/5846128.html">https://www.cnblogs.com/xujian2014/p/5846128.html</a></p><p>*用法：*<a href="https://www.cnblogs.com/lxqiaoyixuan/p/7156944.html">https://www.cnblogs.com/lxqiaoyixuan/p/7156944.html</a></p><h4 id="6-Map集合和Collection集合的区别是什么？"><a href="#6-Map集合和Collection集合的区别是什么？" class="headerlink" title="6. Map集合和Collection集合的区别是什么？"></a><strong>6. Map集合和Collection集合的区别是什么？</strong></h4><p>Map集合是一种键和值的映射关系（双列集合），Collection集合是单列集合，只能存储一种类型的元素。</p><p>同时两者也有关系：HashSet依赖于Map接口的子类实现类HashMap，TreeSet依赖于Map接口的子实现类TreeMap。</p><h4 id="7-HashMap遍历有哪些方法？"><a href="#7-HashMap遍历有哪些方法？" class="headerlink" title="7. HashMap遍历有哪些方法？"></a><strong>7. HashMap遍历有哪些方法？</strong></h4><p>一种是通过keySet（）获取所有的set值进行操作</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; doubleSet = hashMap.keySet();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">Integer</span> aDouble: doubleSet)&#123;<br>        <span class="hljs-type">Double</span> <span class="hljs-keyword">value</span> = hashMap.<span class="hljs-keyword">get</span>(aDouble);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(aDouble + &quot;=&quot; + <span class="hljs-keyword">value</span>);<br>    &#125;//使用<span class="hljs-keyword">foreach</span>进行遍历<br><br>Iterator&lt;<span class="hljs-type">Integer</span>&gt; iterator = doubleSet.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            <span class="hljs-type">Integer</span> aDouble = iterator.next();<br>            <span class="hljs-type">Double</span> <span class="hljs-keyword">value</span> = hashMap.<span class="hljs-keyword">get</span>(aDouble);<br>           <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(aDouble+&quot;===&quot;+<span class="hljs-keyword">value</span>)<br>        &#125;//使用迭代器进行遍历<br></code></pre></td></tr></table></figure><p>另一种是通过HashMap的entrySet（）方法，获取的返回值为Set&lt;Entry&lt;Key,Value&gt;&gt;,然后通过遍历获取到HashMap钟的所有值。</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs irpf90">Set&lt;Map.<span class="hljs-built_in">Entry</span>&lt;<span class="hljs-keyword">Integer</span>,<span class="hljs-keyword">Double</span>&gt;&gt; entries = hashMap.entrySet();<br>for(Map.<span class="hljs-built_in">Entry</span>&lt;<span class="hljs-keyword">Integer</span>,<span class="hljs-keyword">Double</span>&gt; <span class="hljs-built_in">entry</span> : entries)&#123;<br>        <span class="hljs-keyword">Integer</span> key = <span class="hljs-built_in">entry</span>.getKey();<br>        <span class="hljs-keyword">Double</span> <span class="hljs-keyword">value</span> = <span class="hljs-built_in">entry</span>.getValue();<br>        System.<span class="hljs-keyword">out</span>.println(key+<span class="hljs-string">&quot;===&quot;</span>+<span class="hljs-keyword">value</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p>*Java讲Map和Collection集合细节最详细的一篇：*<a href="https://www.cnblogs.com/111testing/p/8100148.html">https://www.cnblogs.com/111testing/p/8100148.html</a></p><p>*Java基础 Map集合：*<a href="https://blog.csdn.net/kai46385076/article/details/94769759">https://blog.csdn.net/kai46385076/article/details/94769759</a></p><p>阅读笔记：</p><ol><li>Map集合的概念和相关方法。</li><li>通过阅读能更了解遍历map方式的基本原理。</li></ol><p>*Java中的Map及其使用：*<a href="https://blog.csdn.net/taraex/article/details/90243965">https://blog.csdn.net/taraex/article/details/90243965</a></p><p>阅读笔记：主要讲Map集合的子类的用法和Collection集合的用法。</p><p>*Java Map集合类简介：*<a href="https://www.oracle.com/cn/database/technology/maps.html">https://www.oracle.com/cn/database/technology/maps.html</a></p><p>阅读笔记：讲的Map非常详细！！！</p><p>*Java中的Map接口的解析：*<a href="https://blog.csdn.net/jiguquan3839/article/details/84546835">https://blog.csdn.net/jiguquan3839/article/details/84546835</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>怎么在Gitee上创建自己的博客</title>
    <link href="/2021/03/13/%E6%80%8E%E4%B9%88%E5%9C%A8Gitee%E4%B8%8A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/03/13/%E6%80%8E%E4%B9%88%E5%9C%A8Gitee%E4%B8%8A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本想跟大多数人一样，创建个地方用来记录学习心得。经过学长介绍，知道了可以在网上用gitee创建自己的仓库，来创建自己的博客，于是在网上找了很多步骤来搭建。</p><p>如果你也想创建个博客，或许看了我的收藏可以事半功倍！</p><p><strong>搭建的步骤</strong>：<a href="https://blog.csdn.net/qq_46036214/article/details/110137239">https://blog.csdn.net/qq_46036214/article/details/110137239</a></p><p>我看到的最详细的一篇，从安装到使用都有！</p><p><strong>创建过程中可能遇到的问题：</strong></p><p><a href="https://imgtu.com/i/60R1IS"><img src="https://s3.ax1x.com/2021/03/14/60R1IS.png" alt="60R1IS.png"></a></p><p><em>问题1</em>. 已经输入了用户名和邮箱了怎么办？不用慌，看这个：</p><p><a href="https://blog.csdn.net/qq_38130747/article/details/100548568">https://blog.csdn.net/qq_38130747/article/details/100548568</a></p><p><em>问题2</em>. Error: ENOENT: no such file or directory, scandir ‘C:\projects**’</p><p><em>解决方法</em>：<a href="https://blog.csdn.net/weixin_41888813/article/details/90290129">https://blog.csdn.net/weixin_41888813/article/details/90290129</a></p><p><em>问题3</em>. git命令报错fatal: repository ‘xxx.git&#x2F;‘ not found</p><p>*解决方法：*<a href="https://blog.csdn.net/u010289343/article/details/88827943">https://blog.csdn.net/u010289343/article/details/88827943</a></p><p>如果遇到其他问题，希望可以相互交流！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
